<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    
    <title>Flask_First_Api - Jefine</title>
    <meta charset="utf-8">
    
    <meta name="title" content="Flask_First_Api - Jefine">
    <meta name="description" content="">
    <meta property="og:image" content="/favicon.png">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    
    <link href="https://fonts.loli.net/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.loli.net/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Source Han Serif TC', 'Noto Serif CJK TC', 'Noto Serif SC', serif;
        }
    </style>
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/arduino-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script>
<link rel="alternate" href="/atom.xml" title="Jefine" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Jefine</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
            
            
            <li class="menu-item">
                
                <a href="/" class="menu-item-link">Home</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/archives" class="menu-item-link">Archives</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/about" class="menu-item-link">About</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/atom.xml" class="menu-item-link">Rss</a>
                
            </li>
            
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
    <div class="post-title">
        <h1 class="title">Flask_First_Api</h2>
    </div>
    <div class="post-content">
        <p>Flask 作为一个轻量级的 Python 前端网页框架，正在逐渐壮大，而在一些近期的一些项目中，也常出现其身影，作为前端和后端相互结合的框架，适合我们去快速构建一个服务器端的服务应用，同时也方便了自己的维护，更重要的是构建起较为完善的技术栈。</p>
  <a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在本次的 Flask 的初步学习中采用的环境是:<br>Python 3.85 + VScode + Conda + Flask2.1</p>
<h3 id="关于-VScode-配置"><a href="#关于-VScode-配置" class="headerlink" title="关于 VScode 配置"></a>关于 VScode 配置</h3><p>关于 Pycharm 还是 VScode，这里采用了 VScode，主要是觉得 Pycharm 有时打开时刻比较笨重，而且最近对于 Python 的开发比较少的在 VScode 中进行，希望能够因此而熟悉一下相关    操作。</p>
<p>VScode 的 Python 命令行配置<br>在编写完成一个 helloworld 的时候，我们想要使用 VScode 进行终端的操作，但是默认的 VScode 的终端操作是 Powershell（默认的前缀是 ps），不是很友好，而且对于 Conda 的适配不好，所以尽量更改为 cmd 环境。<br>在我们的 CMD 环境中，我们可以使用 Flask 命令进行更好的操作。</p>
<p>首先在右下角的终端处进行简单更多选项的箭头，选择默认配置文件<br><img src="/2022/05/14/Flask_First_Api/image20220513192022828.png" alt></p>
<p>进而选择 Command Prompt（这里我更改过了，所以默认就是 cmd）</p>
<p>然而，在我们再次打开 VScode 的时候，cmd 并不会自动激活 conda 或者进入相关路径，这时，我们自己在右下角新建一个终端即可。这样 cmd 的配置就可以了，Conda 会自动激活当前环境，Python 的编译器会在左下角进行选择，而更多的关于 VScode 的 Python 的环境配置，可以在互联网中进行搜索解决。</p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>主要使用的文档是官方文档的 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#" target="_blank" rel="noopener">QuickStart</a><br>开始第一个 Demo 吧<br><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
app = Flask(__name__)  
<span class="hljs-meta">@app.route("/")</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span></code></pre></p>
<p>如果将自己的 Python 文件命名为 app.py 就不用去设置环境变量了<br>如果命名为其他的需要去 声明一个环境变量（根据不同的 终端环境进行设置）其中 hello 为自己无 py 后缀的文件名。</p>
<pre><code class="hljs cmd">#在 <span class="hljs-built_in">cmd</span> 下
<span class="hljs-built_in">set</span> FLASK_APP=hello</code></pre>
<pre><code class="hljs bash"><span class="hljs-comment">#在bash下</span>
<span class="hljs-built_in">export</span> FLASK_APP=hello</code></pre>
<h3 id="对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下"><a href="#对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下" class="headerlink" title="对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下"></a>对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下</h3><pre><code class="hljs bash">File <span class="hljs-string">"E:\python3.8\lib\site-packages\jinja2\filters.py"</span>, line 13, <span class="hljs-keyword">in</span> &lt;module&gt;
    from markupsafe import soft_unicode
ImportError: cannot import name <span class="hljs-string">'soft_unicode'</span> from <span class="hljs-string">'markupsafe'</span> (E:\python3.8\lib\site-packages\markupsafe\__init__.py)</code></pre>
<p>可以尝试去降级 MarkupSafe 以解决问题<br><code>pip install MarkupSafe==2.0.1</code></p>
<p>继续运行程序<br><pre><code class="hljs bash">flask run</code></pre><br>单击或自行访问出现的 <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> 即可查看到运行结果<br><img src="/2022/05/14/Flask_First_Api/image20220513193229672.png" alt><br><img src="/2022/05/14/Flask_First_Api/image20220513193448880.png" alt></p>
<p>可以看到在前面的 @app.route(“/“) 中引号内的内容，表示了 URL 路径。<br>我们可以添加一下代码，然后重新运行（需要关闭当前的 Flask 运行界面，然后重现 flask run）</p>
<pre><code class="hljs Python"><span class="hljs-meta">@app.route("/apple")</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Apple</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"returned an apple!"</span></code></pre>
<p><img src="/2022/05/14/Flask_First_Api/image20220513194739396.png" alt></p>
<p>这样就实现了 API 的访问 （wow）<br>但是我们默认返回的是 String 字符串，这点需要注意。</p>
<h2 id="如何使用其他的访问方式-如-post？"><a href="#如何使用其他的访问方式-如-post？" class="headerlink" title="如何使用其他的访问方式 如 post？"></a>如何使用其他的访问方式 如 post？</h2><p>观察到我们命令行出现的提示信息：<br><pre><code class="hljs bash">127.0.0.1 - - [13/May/2022 19:45:15] <span class="hljs-string">"GET /apple HTTP/1.1"</span> 200 -</code></pre><br>采用的 获取方式都是 Get，一方面是因为 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#http-methods" target="_blank" rel="noopener">Flask 的默认方式</a> 就是 Get，另一方面是因为采用浏览器访问，访问就是 Get 方式。</p>
<h3 id="如何处理-post-请求，Flask-方面的解决办法是"><a href="#如何处理-post-请求，Flask-方面的解决办法是" class="headerlink" title="如何处理 post 请求，Flask 方面的解决办法是"></a>如何处理 post 请求，Flask 方面的解决办法是</h3><p>添加模块<br><code>from flask import request</code><br>然后对比修改代码，如下：</p>
<pre><code class="hljs Python"><span class="hljs-meta">@app.route("/",methods=['GET', 'POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"here is a post"</span>
    <span class="hljs-keyword">else</span> :
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span></code></pre>
<p>需要注意，对于模块的 import 如果大小写引入错误，将会无法正常运行，同样需要注意 method 和 methods 的区分</p>
<h3 id="如何发送-post-请求"><a href="#如何发送-post-请求" class="headerlink" title="如何发送 post 请求"></a>如何发送 post 请求</h3><p>这里采用 postman 本地应用进行发送 post 请求<br><img src="/2022/05/14/Flask_First_Api/image20220513200854627.png" alt></p>
<h2 id="如何返回-JSON"><a href="#如何返回-JSON" class="headerlink" title="如何返回 JSON"></a>如何返回 JSON</h2><p>JSON 是一个结构化的数据，可以方便我们进行数据的处理<br>对于 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#about-responses" target="_blank" rel="noopener">JSON 的返回值处理</a> ，我们根据文档可以看出，如果采用字典返回那么自动就会通过 一个方法<code>jsonify</code>转换成json<br><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json")</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> dict(name = <span class="hljs-string">'a'</span>,num = <span class="hljs-number">100</span>)</code></pre></p>
<p>添加代码后，重启服务，访问 <a href="http://127.0.0.1:5000/json" target="_blank" rel="noopener">http://127.0.0.1:5000/json</a><br><img src="/2022/05/14/Flask_First_Api/image20220513224148375.png" alt><br>可以看到， Firefox 浏览器自动将其解析为了 Json ，并进行了梅花，方便了阅读和处理。</p>
<h2 id="如何从前端获取数据到后端"><a href="#如何从前端获取数据到后端" class="headerlink" title="如何从前端获取数据到后端"></a>如何从前端获取数据到后端</h2><p>在 web 开发的过程中，从客户端获取信息到服务器上，就需要对于 Request 作出一定的处理：</p>
<h3 id="在-URL-中添加-参数-信息"><a href="#在-URL-中添加-参数-信息" class="headerlink" title="在 URL 中添加 参数 信息"></a>在 URL 中添加 参数 信息</h3><p>通常使用 get 进行操作<br>代码参考如下：<br><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json_another")</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json_another</span><span class="hljs-params">()</span>:</span>
    name = request.args.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)
    <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'qaq'</span>):
        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)
    <span class="hljs-keyword">else</span> :
        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'flase'</span>)</code></pre><br>如果在访问 <a href="http://127.0.0.1:5000/json_another" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another</a> 而不加任何参数的时候，就会获取不到相关的内容，进而判断失败。</p>
<p><img src="/2022/05/14/Flask_First_Api/image20220513230539337.png" alt></p>
<p>如果 <a href="http://127.0.0.1:5000/json_another?name=qaq" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another?name=qaq</a> 输入正确的用户名和变量名称，那么就可以检测成功。</p>
<p><img src="/2022/05/14/Flask_First_Api/image20220513230650761.png" alt></p>
<h3 id="采用-body-的form-和-json-形式传输数据"><a href="#采用-body-的form-和-json-形式传输数据" class="headerlink" title="采用 body 的form 和 json 形式传输数据"></a>采用 body 的form 和 json 形式传输数据</h3><p>而在文档上，也提供给了我们 <a href="https://flask.palletsprojects.com/en/2.1.x/api/#flask.Request.form" target="_blank" rel="noopener" title="flask.Request.form"><code>form</code></a> 的形式，通常我们如果需要发送数据到服务器上去，往往采用 post 和 put 这样比较规范的操作（据说使用get也可以，但是有的公司万物皆哈梭 get ，总是不太好，丧失了规范性）</p>
<p>有时同样的代码也会有一写小 bug,通过下面的一些代码，借由 Postman 软件进行发送 post 请求，进行测试</p>
<pre><code class="hljs Python">
<span class="hljs-meta">@app.route("/form",methods=['GET','POST'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">form</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:
        print(request.form.get(<span class="hljs-string">'name'</span>))
        print(request.json)
        print(request.data)
        Fname = request.form.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)
        <span class="hljs-keyword">if</span> (Fname == <span class="hljs-string">'null'</span>):
            Jname = request.json.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)
            <span class="hljs-keyword">if</span>(Jname == <span class="hljs-string">'qaq'</span>):
                <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'true'</span>)
        <span class="hljs-keyword">if</span>(Fname == <span class="hljs-string">'pap'</span>):
            <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)
        <span class="hljs-keyword">else</span> :
            <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'false'</span>)
    <span class="hljs-keyword">else</span> :
        <span class="hljs-keyword">return</span> <span class="hljs-string">"this is a get request"</span></code></pre>
<p>可以看到，/form URL 路径仅仅对于 post 请求作出了回应，如果是其他类型的请求，直接返回  “this is a get request”<br>对于 post 请求，我们在里面放置了两种在 Body 里面的格式内容，分别是 form 和 json<br>这两种我们都将会去使用：为了避免冲突，所以将 json 和 form 的调试放在了有些不一样的 if 分支里面。<br>对于 form：<br><img src="/2022/05/14/Flask_First_Api/image20220514075344866.png" alt><br>对于 json<br><img src="/2022/05/14/Flask_First_Api/image20220514075407137.png" alt></p>
<p>部分参考链接：<br><a href="https://www.bilibili.com/video/BV1Fz4y1d7kc" target="_blank" rel="noopener">Bilibili 视频</a></p>

    </div>
    <div class="post-meta">
        
    <span class="post-time">二〇二二年五月十四日</span>
    </div>
</article>

<div class="prev_next">
    <nav id="prev_next">

<div class="prev">
    
    <p>Newer</p>
    <a href="/2022/06/16/蓝桥杯单片机手册/"><div class="article-nav-title">蓝桥杯单片机手册</div></a>
    
</div>
<div class="next">
    
    <p>Older</p>
    <a href="/2022/05/10/干饭小助手Meal_Alter_Bot/"><div class="article-nav-title">干饭小助手 Meal_Alter_Bot</div></a>
    
</div>

</nav>
</div>

<div class="post-comment">
    



</div>

    </main>

    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>

</html>