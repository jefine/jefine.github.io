<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020学校各相关比赛，资格证书的时间</title>
    <url>/2020/01/16/2020%E5%AD%A6%E6%A0%A1%E5%90%84%E7%9B%B8%E5%85%B3%E6%AF%94%E8%B5%9B%EF%BC%8C%E8%B5%84%E6%A0%BC%E8%AF%81%E4%B9%A6%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>[[2020]]各大比赛，资格证书时间，例如蓝桥杯、挑战杯、ACM、互联网+大赛比赛报名时间，校固定的机器人大赛，学业规划大赛等时间，教资、计算机二级、四六级等职业资格证书报名时间</p>
  <a id="more"></a>
<ol>
<li><p>蓝桥杯：</p>
<p>报名截至日期为2019年12月13日</p>
<p>初赛（省赛）2020年4月19日（星期日）</p>
<p>决赛6月举行</p>
<p>国际赛拟于2020年10月末至11月初在西班牙举行</p>
</li>
<li><p>挑战杯：</p>
<p>a. 首先是校级创青春比赛：</p>
<p> 1、立项报名 </p>
<p>（1）创意立项（2019年12月1日—12月25日）</p>
<p>各项目负责人填写立项申请表（见附件一），并将电子版和纸质版各1份交至所属学院。各学院汇总后将立项申请表和立项汇总表（见附件二）电子版和纸质版各1份上交至竞赛办公室，最晚提交时间为12月25日12：00。</p>
<p>（2）立项审核（2019年12月25日—2020年1月3日）</p>
<p>创意立项审核，审核通过的项目，予以立项。准予立项项目详细信息将通过荷花网进行公示，各学院负责通知本学院通过立项的参赛团队。</p>
<p>（3）团队组建（2020年1月4日—1月9日）</p>
<p>有意参赛的同学根据荷花网公示结果，自行联系项目负责人。项目负责人根据作品创作和运行需要进行团队组建。原则上应由不同学科背景、不同学院学生交叉组队（不超过7人）。各团队负责人将团队成员信息统计表（附件三）交至所在学院，各学院将统计表汇总后，于1月9日12:00之前将纸质版和电子版各1份交至竞赛办公室。</p>
<p>2、初赛</p>
<p>（1）组队创作培训阶段（2020年1月9日—2月20日）</p>
<p>组织相关专家就计划书撰写、财务管理、法律法规、市场营销、人力资源管理等方面对参赛选手进行培训。学生完善选题，进行课题研究以及市场调研，撰写项目执行概要，编写创业计划书。</p>
<p>（2）学院评审和作品上报阶段（2020年2月20日—2月23日）</p>
<p>参赛者将项目执行概要（1500字）和创业计划书交至学院，经学院评审后，于2月23日12：00之前将执行概要和创业计划书电子版和纸质版各1份交至竞赛办公室。</p>
<p>（3）学校评审阶段（2020年2月23日—3月2日）</p>
<p>学校对各学院报送的优秀作品进行书面评审，评选出进入学校复赛的作品。</p>
<p>3、复赛</p>
<p>（1）项目完善阶段（2020年3月2日—4月7日）</p>
<p>参赛团队对作品进行修改与完善，开展与项目相关的实践调研与项目论证。有条件的团队在学校指导下进行项目落地和公司注册。</p>
<p>（2）项目提交阶段（2020年4月7日—4月10日）</p>
<p>各学院组织参赛学生将修改好的作品再次提交至各学院，由各学院汇总后于4月10日12:00之前将创业计划书电子版和纸质版各1份上交至竞赛办公室。</p>
<p>（3）学校审核阶段（2020年4月10日—4月18日）</p>
<p>评审专家对上报作品进行书面评审。择优进入校内决赛。</p>
<p>4、决赛</p>
<p>答辩阶段（2020年4月底，具体时间另行通知）</p>
<p>决赛团队就作品进行答辩。</p>
<p>b. 国家级挑战杯报名时间待定</p>
</li>
<li><p>ACM(icpc)：</p>
<p> 区域预赛：每年的 9-12 月在各大洲举行<br>全球总决赛：每年的 3-4 月举行 </p>
</li>
<li><p>互联网+大赛（2019全国大学生“互联网+” 创新大赛暨第七届“发现杯”全国大学生互联网软件设计大奖赛)：</p>
<p>2019.09.10 - 2020.01.31<br>报名</p>
<p>在大网站完成<a href="http://www.dajiangsai.org/loginAndRegist/regist.jsp" target="_blank" rel="noopener">报名注册</a></p>
<p>2020.02.01-2020.03.09<br>提交作品</p>
<p>按照大赛赛项，准备参赛作品/方案，参赛内容详见<a href="http://www.dajiangsai.org/static/about/matchcontent.html" target="_blank" rel="noopener">比赛内容</a></p>
<p>2020.03.10 - 2020.04.15<br>区域赛</p>
<p>区域赛评审，准备决赛</p>
<p>2020.04.25<br>决赛</p>
<p>现场答辩</p>
</li>
<li><p>学业规划大赛：</p>
<p>（一）宣传动员和撰写学业规划书阶段（即日起至下学期开学初）</p>
<p>（二）初赛及集训阶段(下学期开学第3周—第4周)</p>
<p>（三）校级复赛及集训阶段（下学期第6周）</p>
<p>（四）校级决赛及集训阶段（下学期第八周）</p>
</li>
<li><p>全国计算机等级考试（NCRE）：</p>
<p>2020年全国计算机等级考试（NCRE）将举办四次考试：</p>
<p>时间分别为：</p>
<p>3月28日至30日（第58次）、</p>
<p>5月30日（第59次）、</p>
<p>9月26日至28日（第60次）</p>
<p>12月5日（第61次）。</p>
<p>其中3月和9月考试开考全部级别全部科目，5月和12月考试开考一、二级全部科目。各省级承办机构可根据实际情况决定是否开考5月和12月考试。 </p>
</li>
<li><p>教师资格证：</p>
<p>（一）网上报名时间：2020年1月9日至11日17:00。</p>
<p>（二）网上审核时间：2020年1月9日至12日17:00。</p>
<p>（三）网上缴费时间：2020年1月9日至13日24:00。</p>
<p>（四）全国统一考试日期2020年3月14日。</p>
</li>
<li><p>四六级（CET）：</p>
<p>CET笔试每年开考两次，为每年的6月和12月，6月开考英语及非英语所有科目，12月仅开考英语科目。各语种的四级考试时间为上午，六级考试时间为下午。</p>
<p>CET口试每年开考两次，为每年5月和11月，每次考试两个考试日，第一考试日科目为CET-SET4，第二考试日科目为CET-SET6。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>record</category>
      </categories>
      <tags>
        <tag>xcu</tag>
      </tags>
  </entry>
  <entry>
    <title>2020</title>
    <url>/2020/01/02/2020/</url>
    <content><![CDATA[<h3 id="2020来咯。"><a href="#2020来咯。" class="headerlink" title="2020来咯。"></a>2020来咯。</h3><p>我们一直以为出现在科幻和未来的2020年，他来了。</p>
<p>[[2020]]更是10年的总结。当然第一批90后30岁了，结合当下的互联网形式，预计今年的35岁梗会愈发汹涌，焦虑会更快的弥漫在这个飞速发展的互联行业中。有人说2019是过去十年中最差的一年，但也是未来十年中最好的一年。曾有人说：每一个行业都有他的黄金十年，白银十年，青铜十年。最好的黄金十年由于移动互联网的爆发持续了20年，那么？互联网要进入白银十年了么？互联网会像传统行业一样逐渐的失去风头么？那么未来什么又是新的未来呢？没有人知道。5g带给我们的究竟是什么样的巨变，我们可能有一些遐想，但未来会不会出现新的增长点（5g+区块链+物联网我还是很看好的）但看未来吧！我辈必将前行。</p>
<p>在2019跨年演讲《与时间做朋友》中罗振宇（不是罗永浩哈）给我的启发有：</p>
<h6 id="做-做事的人；做与人交流的人；做最好的自己；"><a href="#做-做事的人；做与人交流的人；做最好的自己；" class="headerlink" title="做 做事的人；做与人交流的人；做最好的自己；"></a>做 做事的人；做与人交流的人；做最好的自己；</h6><h6 id="每个人都是一盏灯，人点亮人"><a href="#每个人都是一盏灯，人点亮人" class="headerlink" title="每个人都是一盏灯，人点亮人"></a>每个人都是一盏灯，人点亮人</h6><h6 id="未来，我来！"><a href="#未来，我来！" class="headerlink" title="未来，我来！"></a>未来，我来！</h6><h6 id><a href="#" class="headerlink" title=" "></a> </h6>]]></content>
      <categories>
        <category>record</category>
      </categories>
      <tags>
        <tag>newyear</tag>
      </tags>
  </entry>
  <entry>
    <title>4GES600S开发</title>
    <url>/2021/08/24/4GES600SEVB/</url>
    <content><![CDATA[<p>移远通信 ES600S开发板的Demo和一些基础的操作指南</p>
  <a id="more"></a>
<h1 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h1><h2 id="配置环境与基本认识文档："><a href="#配置环境与基本认识文档：" class="headerlink" title="配置环境与基本认识文档："></a>配置环境与基本认识文档：</h2><p><a href="https://python.quectel.com/doc/doc/Quick_start/zh/index.html" target="_blank" rel="noopener">QuecPython</a></p>
<p><a href="固件下载与脚本下载图解.pdf">固件下载与脚本下载图解.pdf</a></p>
<h3 id="开发板使用几大步骤："><a href="#开发板使用几大步骤：" class="headerlink" title="开发板使用几大步骤："></a>开发板使用几大步骤：</h3><p>1.插上模组；</p>
<p>2.模组开机（具体步骤：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；</a></p>
<p>3.驱动安装（注意事项：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；</a></p>
<p>4.烧录QuecPython固件</p>
<p>注意事项见：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节</a></p>
<p>具体步骤的视频连接：<a href="https://www.bilibili.com/video/BV1ci4y1w7g8/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ci4y1w7g8/</a></p>
<p>5.下载Demo程序（官网的下载专区<a href="https://python.quectel.com/download有个Demo的文件夹）" target="_blank" rel="noopener">https://python.quectel.com/download有个Demo的文件夹）</a></p>
<p>6.例程无法跑通请先自查并参考官网wiki（<a href="https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库" target="_blank" rel="noopener">https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库</a></p>
<h3 id="开发板需要注意的地方："><a href="#开发板需要注意的地方：" class="headerlink" title="开发板需要注意的地方："></a>开发板需要注意的地方：</h3><p><a href="Quectel_EC600x-CN兼容性设计讲稿_-0506.pdf">Quectel_EC600x-CN(_QuecOpen)兼容性设计讲稿_-0506.pdf</a></p>
<p>Page24</p>
<p>EC600N-CN/EC600S-CN (QuecOpen)接喇叭则需增加外部PA设计（放大听<br>筒信号）</p>
<p>EC600N-CN/EC600S-CN QuecOpen 复用键盘引脚（PIN 48~57）也可以复用成<br>GPIO功能使用，在不用键盘情况下可使用<br>复用成GPIO口时要注意开机默认状态和电源域，具体参考Quectel_EC600x-CN<br>QuecOpen_GPIO配置表_V1.0</p>
<p>EC600S-CN/EC600N-CN QuecOpen 开机默认是PU，用于控灯、电机和外部电源<br>使能之类要注意模块上电时有上拉动作</p>
<p>天线设计</p>
<p><a href="Quectel_天线设计指导_V3.2.pdf">Quectel_天线设计指导_V3.2.pdf</a></p>
<h1 id="小实验："><a href="#小实验：" class="headerlink" title="小实验："></a>小实验：</h1><h2 id="如何将软硬件结合？"><a href="#如何将软硬件结合？" class="headerlink" title="如何将软硬件结合？"></a>如何将软硬件结合？</h2><p>另外在查询开发板上的GPIO的号码时，可以看看板子中间的引脚介绍，可以解决不少问题，查找不到的可以按照下面的方法进行查找。</p>
<p>即如何查找软件 GPIO 或 ADC 等接口与物理开发板接口的位置</p>
<p>下面以查找KEY2所对应的GPIO号为例：</p>
<p>首先打开 <a href="EC600X_QuecPython_EVB_V1.3_SCH.pdf">EC600X_QuecPython_EVB_V1.3_SCH.pdf</a> 文件</p>
<p>然后根据需要切换到第六GPIO+UART这一页也是最经常查找的</p>
<p><img src="/2021/08/24/4GES600SEVB/Untitled.png" alt="p"></p>
<p> 可以看到左下角的S4,S5即是我们所要寻找的，找到引脚号PIN60后</p>
<p>即可根据<a href="https://python.quectel.com/wiki/#/zh-cn/api/QuecPythonClasslib?id=pin" target="_blank" rel="noopener">API</a>查询到相关的GPIO号码，如图12 即为所求。</p>
<p>有部分不易寻找到内容可以采取多种类似说法，大小写，简要内容的搜索来查找。</p>
<p><img src="/2021/08/24/4GES600SEVB/Untitled 1.png" alt="p"></p>
<h2 id="简单的外设Demo"><a href="#简单的外设Demo" class="headerlink" title="简单的外设Demo"></a>简单的外设Demo</h2><p><a href="https://python.quectel.com/doc/doc/little_demo/zh/QuecPythonTest/QuecPythonLED.html" target="_blank" rel="noopener">QuecPython</a></p>
<h3 id="UART串口："><a href="#UART串口：" class="headerlink" title="UART串口："></a>UART串口：</h3><p><img src="/2021/08/24/4GES600SEVB/Untitled 2.png" alt="p1"></p>
<p><img src="/2021/08/24/4GES600SEVB/Untitled 3.png" alt="p"></p>
<h3 id="External-interrupt外部中断"><a href="#External-interrupt外部中断" class="headerlink" title="External_interrupt外部中断"></a>External_interrupt外部中断</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> ExtInt<br><br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><br><span class="hljs-comment"># 参考自 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=extint</span><br><br>state = <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callBack</span><span class="hljs-params">(args)</span>:</span><br><br>    <span class="hljs-keyword">global</span> state<br><br>    print(<span class="hljs-string">'### interrupt  &#123;&#125; ###'</span>.format(args))<br>    <span class="hljs-comment">#传入的应该是一个List，[GPIOX,X] ,第二个参数不清楚</span><br><br>    state = state - <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br><br>    <span class="hljs-comment"># 映射GPIO12的下降沿触发回调函数</span><br>    <span class="hljs-comment"># GPIO12即key2</span><br><br>    extint = ExtInt(ExtInt.GPIO12, ExtInt.IRQ_FALLING, ExtInt.PULL_PU, callBack)<br><br>    <span class="hljs-comment"># 等待按键按下，触发</span><br><br>    <span class="hljs-keyword">while</span> state:<br>        time.sleep_ms(<span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 停止映射外部中断</span><br><br>    extint.disable()<br><br>    print(<span class="hljs-string">"The main function has exited"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    main()<br></code></pre></td></tr></table></figure>
<h3 id="WatchDog-看门狗"><a href="#WatchDog-看门狗" class="headerlink" title="WatchDog 看门狗"></a>WatchDog 看门狗</h3><p>看门狗的复位指的是<strong>重启机器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实验1：	独立看门狗实验</span><br><span class="hljs-comment"># API资料参考连接：  https://python.quectel.com/wiki/#/zh-cn/api/?id=wdt</span><br><br><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> WDT<br><span class="hljs-keyword">import</span> utime<br><br>wdt = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 定义全部变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Watchdog</span><span class="hljs-params">()</span>:</span>  <span class="hljs-comment"># 2秒钟内调用喂狗函数，否则系统复位</span><br>    <span class="hljs-keyword">global</span> wdt  <span class="hljs-comment"># 声明全部变量</span><br>    <span class="hljs-keyword">if</span> wdt <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        wdt = WDT(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 启动看门狗，间隔时长 单位 秒</span><br>    wdt.feed()  <span class="hljs-comment"># 喂狗</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_1</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 1'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_2</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 2'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_3</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 3'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 3_2'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_4</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)<br>    print(<span class="hljs-string">'功能函数 4'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    print(<span class="hljs-string">'尝试在5s后喂狗'</span>)<br>    utime.sleep_ms(<span class="hljs-number">5000</span>)  <span class="hljs-comment"># 延时5秒</span><br>    Watchdog()<br>    print(<span class="hljs-string">'来不及喂狗，系统已经复位'</span>)<span class="hljs-comment">#此行代码不会显示因为机器已经重启了</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_1()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_2()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_3()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_4()  <span class="hljs-comment"># 用户程序</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    main()<br></code></pre></td></tr></table></figure>
<h3 id="温湿度检测"><a href="#温湿度检测" class="headerlink" title="温湿度检测"></a>温湿度检测</h3><p>测得不准，勉强能看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''<br>File: i2c_aht10.py<br>Project: i2c<br>File Created: Monday, 28th December 2020 5:17:28 pm<br>Author: chengzhu.zhou<br>-----<br>Last Modified: Tuesday, 29th December 2020 9:01:35 pm<br>Modified By: chengzhu.zhou<br>-----<br>Copyright 2020 - 2020 quectel<br>'''</span><br><br><span class="hljs-keyword">import</span> log<br><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> I2C<br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><span class="hljs-string">"""<br>1. calibration<br>2. Trigger measurement<br>3. read data<br>"""</span><br><br><span class="hljs-comment"># API  手册 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=i2c</span><br><span class="hljs-comment"># AHT10 说明书</span><br><span class="hljs-comment">#  https://server4.eca.ir/eshop/AHT10/Aosong_AHT10_en_draft_0c.pdf</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aht10class</span><span class="hljs-params">()</span>:</span><br>    i2c_log = <span class="hljs-literal">None</span><br>    i2c_dev = <span class="hljs-literal">None</span><br>    i2c_addre = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># Initialization command</span><br>    AHT10_CALIBRATION_CMD = <span class="hljs-number">0xE1</span><br>    <span class="hljs-comment"># Trigger measurement</span><br>    AHT10_START_MEASURMENT_CMD = <span class="hljs-number">0xAC</span><br>    <span class="hljs-comment"># reset</span><br>    AHT10_RESET_CMD = <span class="hljs-number">0xBA</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_data</span><span class="hljs-params">(self, data)</span>:</span><br>        self.i2c_dev.write(self.i2c_addre,<br>                           bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,<br>                           bytearray(data), len(data))<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data</span><span class="hljs-params">(self, length)</span>:</span><br>        r_data = [<span class="hljs-number">0x00</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length)]<br>        r_data = bytearray(r_data)<br>        self.i2c_dev.read(self.i2c_addre,<br>                          bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,<br>                          r_data, length,<br>                          <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> list(r_data)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_init</span><span class="hljs-params">(self, addre=<span class="hljs-number">0x38</span>, Alise=<span class="hljs-string">"Ath10"</span>)</span>:</span><br>        self.i2c_log = log.getLogger(Alise)<br>        self.i2c_dev = I2C(I2C.I2C1, I2C.STANDARD_MODE)  <span class="hljs-comment"># 返回i2c对象</span><br>        self.i2c_addre = addre<br>        self.sensor_init()<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_transformation_temperature</span><span class="hljs-params">(self, data)</span>:</span><br>        r_data = data<br>        <span class="hljs-comment">#　根据数据手册的描述来转化温度</span><br>        humidity = (r_data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">12</span>) | (<br>            r_data[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">4</span>) | ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>)<br>        humidity = (humidity/(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) * <span class="hljs-number">100.0</span><br>        print(<span class="hljs-string">"current humidity is &#123;0&#125;%"</span>.format(humidity))<br>        temperature = ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xf</span>) &lt;&lt; <span class="hljs-number">16</span>) | (<br>            r_data[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | r_data[<span class="hljs-number">4</span>]<br>        temperature = (temperature * <span class="hljs-number">200.0</span> / (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) - <span class="hljs-number">50</span><br>        print(<span class="hljs-string">"current temperature is &#123;0&#125;°C"</span>.format(temperature))<br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sensor_init</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># calibration</span><br>        self.write_data([self.AHT10_CALIBRATION_CMD, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>])<br>        time.sleep_ms(<span class="hljs-number">300</span>)  <span class="hljs-comment"># at last 300ms</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ath10_reset</span><span class="hljs-params">(self)</span>:</span><br>        self.write_data([self.AHT10_RESET_CMD])<br>        time.sleep_ms(<span class="hljs-number">20</span>)  <span class="hljs-comment"># at last 20ms</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Trigger_measurement</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># Trigger data conversion</span><br>        self.write_data([self.AHT10_START_MEASURMENT_CMD, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>])<br>        time.sleep_ms(<span class="hljs-number">200</span>)  <span class="hljs-comment"># at last delay 75ms</span><br>        <span class="hljs-comment"># check has success</span><br>        r_data = self.read_data(<span class="hljs-number">6</span>)<br>        <span class="hljs-comment"># check bit7</span><br>        <span class="hljs-keyword">if</span> (r_data[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">7</span>) != <span class="hljs-number">0x0</span>:<br>            print(<span class="hljs-string">"Conversion has error"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.aht10_transformation_temperature(r_data[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">i2c_aht10_test</span><span class="hljs-params">()</span>:</span><br>    ath_dev = aht10class()<br>    ath_dev.aht10_init()<br><br>    <span class="hljs-comment"># 测试十次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        ath_dev.Trigger_measurement()<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    i2c_aht10_test()<br></code></pre></td></tr></table></figure>
<h3 id="Photoresistor-光敏电阻"><a href="#Photoresistor-光敏电阻" class="headerlink" title="Photoresistor 光敏电阻"></a>Photoresistor 光敏电阻</h3><p>得到的数值为ADC电压值</p>
<p><img src="/2021/08/24/4GES600SEVB/Untitled 4.png" alt="p"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''<br>File: Photoresistor.py<br>Project: adc<br>File Created: Thursday, 24th December 2020 5:44:08 pm<br>Author: chengzhu.zhou<br>-----<br>Last Modified: Wednesday, 30th December 2020 10:10:33 am<br>Modified By: chengzhu.zhou<br>-----<br>Copyright 2020 - 2020 quectel<br>'''</span><br><br><span class="hljs-keyword">from</span> misc <span class="hljs-keyword">import</span> ADC<br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><span class="hljs-keyword">import</span> _thread<br><br><span class="hljs-comment"># unit as Ω</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Voltage_to_Resistance</span><span class="hljs-params">(Volt)</span>:</span><br>    <span class="hljs-comment">#</span><br>    Va = <span class="hljs-number">2</span> * Volt<br>    resistance = (<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * <span class="hljs-number">40200</span> * Va)/(<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * (<span class="hljs-number">3300</span> - Va) - (<span class="hljs-number">40200</span> * Va))<br>    <span class="hljs-keyword">return</span> resistance<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Photoresistor_thread</span><span class="hljs-params">(delay, retryCount)</span>:</span><br>    <span class="hljs-comment"># creat a adc device</span><br>    AdcDevice = ADC()<br>    <span class="hljs-keyword">while</span> retryCount:<br>        retryCount = retryCount - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># get ADC.ADC0 value</span><br>        adcvalue = AdcDevice.read(ADC.ADC0)<br>        print(<span class="hljs-string">"get ADC.ADC0 Voltage value as &#123;0&#125;mv"</span>.format(adcvalue))<br>        <span class="hljs-comment"># Converted to resistance</span><br>        resistance = Voltage_to_Resistance(adcvalue)<br>        print(<span class="hljs-string">"Photoresistor  resistance as  &#123;0&#125;Ω"</span>.format(resistance))<br>        time.sleep(delay)<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># creat a thread Convert ADC to Voltage</span><br>    _thread.start_new_thread(Photoresistor_thread, (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>    print(<span class="hljs-string">"creent main thread has exit"</span>)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>ES600S</tag>
      </tags>
  </entry>
  <entry>
    <title>2021</title>
    <url>/2021/01/01/2021/</url>
    <content><![CDATA[<p>​                                                                    <strong>[[2020]]</strong>—-&gt;<strong>[[2021]]</strong></p>
<p><strong>活着</strong></p>
<p><img src="/2021/01/01/2021/2021.jpg" alt="2021-2020"></p>
]]></content>
      <categories>
        <category>record</category>
      </categories>
      <tags>
        <tag>newyear</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS小结</title>
    <url>/2020/07/15/BFS%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.</p>
<p>todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）</p>
  <a id="more"></a>
<h2 id="BFS是什么"><a href="#BFS是什么" class="headerlink" title="BFS是什么?"></a>BFS是什么?</h2><blockquote>
<p> <strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href="https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">图形搜索算法</a>。简单的说，BFS是从<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">根节点</a>开始，沿着树的宽度遍历树的<a href="https://zh.wikipedia.org/wiki/节点" target="_blank" rel="noopener">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。  (<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">链接</a>)</p>
</blockquote>
<h2 id="BFS流程是"><a href="#BFS流程是" class="headerlink" title="BFS流程是?"></a>BFS流程是?</h2><p>从起点出发,将到终点之间将所有的路几乎全部走一遍。</p>
<p>一般用来寻找最短路程.</p>
<p>思想上来说是穷举所有的情况,踩遍所有的可能点或找到终点。</p>
<p>我们通常是这样做的:</p>
<p>需要: </p>
<ul>
<li><p>一个状态所需要的内容作为一个节点。（比如坐标等）</p>
</li>
<li><p>一个足够大的位置集合,来表示我们是否来过(可能是二维数组甚至更高维度，也可能是其他的形式，要看具体状态的要求).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[max];<br></code></pre></td></tr></table></figure>
</li>
<li><p>一个队列,表示我们即将将队列中的每一个元素作为一个新的起点去重新出发.(queue).</p>
</li>
<li><p>一个起点,一个终点.</p>
</li>
<li><p>可能需要: 一个记录步数的数组(或其他形式),用来记录是第几步向外，一般放在节点结构里.int step[];</p>
</li>
</ul>
<h4 id="什么时候开始"><a href="#什么时候开始" class="headerlink" title="什么时候开始?"></a>什么时候开始?</h4><p>我们常常从起点开始<del>(废话)</del>, 起点仅仅只有一个点, 我们先将其标记一下,表示我们来过了,然后我们将其加入队列.</p>
<p>我们将从起点开始的每一个可能可以去的位置,都进行遍历,然后将它们添加到队列中去.</p>
<p>上面的步骤可以说是每一道题目的必需步骤了,然后我们就要依据题目的条件进行分析咯~</p>
<h4 id="我们什么时候结束"><a href="#我们什么时候结束" class="headerlink" title="我们什么时候结束?"></a>我们什么时候结束?</h4><p><strong>当队列为空的时候</strong>,何时队列为空呢——当我们踩扁所有的点的时候(不能踩的当然就算了).</p>
<p>我们依据题目,在地图上的点,并不是每个点都可以踩的,<del>要不然还这么辛苦干么.</del></p>
<p>那我们就要总结出来: 什么是往下一个点的规律(可以往那里移动?),什么点是不能踩的,约束条件是什么.</p>
<p>所以,我们往往判断一个点可不可以踩的时候我们要对他有很多的约束条件.</p>
<p>例如，在二维的地图上，不能越界，不能进入禁止的点，没有来过此点等等。</p>
<p>例如,小老鼠走迷宫的问题:那么我们就可以根据题目,得到我们小老鼠不能碰的那些点,每次小老鼠可以怎样走动呢?上下左右都可以走,我们就还要判断他们是否出界.进行挑选出那些<strong>从一点可以到该点所能触及的所有不违反规则的点</strong>,别忘了,我们还要判断他们是不是我们要寻找的终点.</p>
<p>在一层一层的脱离过程中我们会发现还要根据题目要求记下一些东西,往往是所走的路程是多少,那么刚刚提及的最后一个记录步数的数组就可以起效了,我们往往这样使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">step[next] = step[front]+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>因为我们从一点出发往往会经过许许多多的点,然而这些点都是我们一步可以走到的点.不能将他们累加起来作为我们的实际步数.</p>
<p>宏观上看,我们其实更像是一个池塘中的波纹,每一个波纹有小及大的向外扩散.那么看起来与BFS的算法思想是极为相似的,我们也是从一点抛下一颗小石子,然后等波纹自己寻找到终点(水中的另外一颗小石头的位置).可以想象到我们如果碰触到终点后不停止,那么水波将不断的向远处扩散,知道池塘全部被波及.但我们往往不需要那样做,那样通常是最坏的情况了(也意味着我们要踩所有的可能点呢).</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h4><ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。 <ul>
<li>如果找到目标，则结束搜索并回传结果。</li>
<li>否则将它所有尚未检验过的直接子节点加入队列中。</li>
</ul>
</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
<p>其中重要 的就是我们需要限制的约束条件和下一个位置的可能点.</p>
<p>当然[[bfs]]是一个思想并不拘泥于为某道题目而服务,所以我们往往需要多加练习,在面对求最短路径的时候,才能从容不迫的写出题解.</p>
<h3 id="需要注意的几个小点点："><a href="#需要注意的几个小点点：" class="headerlink" title="需要注意的几个小点点："></a>需要注意的几个小点点：</h3><ol>
<li><p>vis是为了防止我们将踩过的点再次踩入</p>
<p>想象一下，我们水花的方向是四周的一圈，那么也一定会有的向着我们已经走过的路的水波方向，我们要做好辨别工作，那么就给他们加上一个vis的判断。他们的范围就是所有的可能涉及的区域集合。可能通常是数组。</p>
<p>这样，我们不必花费过多的时间去判断该行为是否会造成逆流，我们只需要进行有效的标注即可！</p>
<p>杜绝了同样的状态二次出现！</p>
</li>
<li><p>我们通常会遇到需要记录层数的时刻，那么最好是使用一个node 里面放上cnt来记录当前节点的层数。</p>
</li>
<li><p>我们在对于一个节点进行多个动作时候，需要注意，我们要将其恢复为front的状态，或者更方便一些的，我们直接将其 cnt++；在循环的过程中，我们一直采用front来判断条件或者是对即将入队的节点进行赋值。</p>
<p>eg：在洛谷1135的题目中我们在队列的循环过程中的front进行变动的做法：而不是对t进行改动。在其他的题目中也经常适用，不要改变t，除非即将入队，判断采用front的+-等进行操作即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">t.cnt = front.cnt+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(CHECK((front.h+high[front.h])))&#123;<br>    t.h = front.h+high[front.h];<br>    vis[t.h] = <span class="hljs-number">1</span>;<br>    q.push(t);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>我们如果需要记录可以达到多少个点，那么我们在队列中，只要 !vis 我们就可以给他count++；一般是放在动作里面的。如上面的代码情况就放在vis[t.h]=1 下面一行即可。</p>
</li>
<li><p>如果我们需要遍历出到每一个点的最短步数，如洛谷p1443，我们最暴力的想法就是给定每一点作为终点，不断地去跑bfs，然而这样是复杂度很高的，完全没有必要这样做，我们既然目标是所有的点，那么我们再 声明一个和vis的范围相同的一个ans数组来记录一个queue的每个点（！vis）的时候的步数即可，未记录的即为无法达到，通过遍历ans数组即可获得相关内容。</p>
</li>
<li><p>遇到三维的状态（hdu1204）时，只需要注意输入，接着按照正常的bfs动作流程即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF_VScode配置环境</title>
    <url>/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>ESP32官方推荐的IDF开发环境，可以作为插件，在VScode中进行编译烧录。<br>需要安装数G环境，如果不是必须，可以尽量使用 Arduino 方式进行编程。</p>
  <a id="more"></a>
<ol>
<li>安装 vscode</li>
<li>到<a href="https://dl.espressif.com/dl/esp-idf/?idf=4.3" target="_blank" rel="noopener">连接中</a>下载离线的 idf 安装器</li>
</ol>
<p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled.png" alt="pic"></p>
<p>一定要使用离线版本的，因为在线版本安装的时候需要下载依赖，而且由于国内网络环境问题，所以很慢，甚至还很可能发生失败。</p>
<ol>
<li>打开 vscode，安装插件 esp-idf<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 1.png" alt="pic"></li>
<li>配置 idf 源码的位置和 tools 的位置，这个位置就是刚开始安装 offline 这个环境时选<br>择的位置。</li>
</ol>
<p>具体的是 按下 ctrl+p 然后输入 &gt;ESP-IDF: configure paths 详细见箭头处<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 2.png" alt="pic"></p>
<ol>
<li>接着就是上图的方块处，配置插件</li>
</ol>
<p>应该出现的红框如果没有出现，那就意味着上一步的 path 没有配置</p>
<p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 3.png" alt="pic"></p>
<ol>
<li>接着就应该直接创建虚拟的 python 环境了，但是<strong>如果挂了代理，需要关闭</strong>，否则会出现下载失败的提示。</li>
<li>这样就配置好了。</li>
<li>使用例程创建一个工程<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 4.png" alt="pic"></li>
</ol>
<p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 5.png" alt="pic"><br>配置 device，可以选择 ESP32 也可以选择 ESP32C3。</p>
<p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 6.png" alt="pic"></p>
<ol>
<li>然后编译，下载，就行了（如果下载失败，就在其 connect 的时候先按下 boot，再按下 reset，松开reset，再松开boot就行了，应该是第一步reboot 到 boot模式没起到效果，这里手动就可以了） </li>
</ol>
<p>注意：通过 vscode 进行的编译十分缓慢 大约2min，<strong>如果使用 ESPIDF 终端，大概在30s</strong></p>
<p>而对于Menu configure 暂时不改动（基本上不需要改动）</p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32</title>
    <url>/2022/01/09/ESP32/</url>
    <content><![CDATA[<p>近期，多次使用了 ESP32 系列的模组，发现 ESP32 的一些优良特性，后期打算继续将其作为网络节点，特此介绍 ESP32 的可用性以及其特点。</p>
  <a id="more"></a>
<p><a href="https://www.espressif.com/en/products/socs/esp32" target="_blank" rel="noopener">ESP32</a> 是一颗国产芯片，由位居上海的乐鑫科技研发，在其 <a href="https://www.espressif.com/zh-hans/home" target="_blank" rel="noopener">官网</a> 上我们可看到更为详细的说明。<br>以下特点吸引了我：</p>
<ul>
<li><strong>WIFI &amp; Bluetooth</strong>： 双模的网络链接方式，让我们可以去探寻更多的物联网设备通信的可能性。（虽然我没有用过 ESP32 的蓝牙，但是我可不用，但不能没有🙈）</li>
<li><strong>MCU</strong> ：自己既可作为一个独立的模块正常工作，而且是采用了 32 架构的芯片，其性能也可以达到几百 MHz（区别于不同的型号），基本上和 STM32 性能相匹配，甚至于还要强于 STM32。</li>
<li><strong>低功耗</strong>：支持深度休眠，等等这个性能没有去测试过，但确实，从目前物联网设备的使用程度中，许多 Wi-Fi 芯片都采用了乐鑫科技出品的芯片，也证实了其可靠性，低功耗。</li>
<li><strong>易用性</strong>：上手快，可以采用 Arduino 快速上手，如果使用的开发板，那么上手的速度甚至比 Arduino uno 还要快，也是比较便宜的 Arduino 类型的产品了。</li>
<li><strong>可移植性强</strong>：这一点指的还是采用了 Arduino 的特点，所以比较方便在 ESP8266 中使用也同样应用于 ESP32（在不启用一些特殊的功能的情况下）</li>
<li><strong>RISC_V 架构</strong>：可以说是和 k210 一起推动了 RISC_V 生态的建设吧，也算是独立创新的一个努力。</li>
<li><strong>成本低</strong>：没有像 STM32 一样在芯片的涨价潮中，突飞猛进。仍然保持一个较为合理的价格。因为无论是拿来做一个通信模块或协处理器，性价都比较高。</li>
<li><strong>发展趋势良好</strong>：ESP32 系列芯片基本都支持 FreeRTOS，而且是官方的支持，同样官方也提供了 IDF 的开发套件，但是 emm 就好比 c 和 python 的区别类似，前期可以不需要去掌握 IDF。</li>
</ul>
<p>开发环境：建议采用 VScode 进行开发，同时使用 Platform 进行开发，方便快捷，而且易于编译和下载。</p>
<p><img src="/2022/01/09/ESP32/Untitled.png" alt="Untitled"></p>
<p>一些常用的相关软件：</p>
<p><a href="CP2102驱动For+WIN7+X64.rar">CP2102驱动For+WIN7+X64.rar</a></p>
<p><a href="esp_wroom_32_datasheet_cn.pdf">esp_wroom_32_datasheet_cn.pdf</a></p>
<p>下面的仓库中由一些比较有意思和可供参考的内容</p>
<p><a href="https://github.com/Homepea7/ESP32_Code" target="_blank" rel="noopener">https://github.com/Homepea7/ESP32_Code</a></p>
<p>在该仓库的Pinset中，有不少是可以直接拿来使用的。比如0.ESP32_Pinout.xlsx，就可以在实际的开发中，将其拷贝到工程下，当作一个Cubemx进行使用，来表明自己已经使用了哪些引脚，而且可以快速的查看他们之间是不是有冲突。</p>
<p><a href="https://github.com/Homepea7/ESP32_Code/tree/main/1.PinSet" target="_blank" rel="noopener">ESP32_Code/1.PinSet at main · Homepea7/ESP32_Code</a></p>
<p><a href="0.ESP32_Pinout.xlsx">0.ESP32_Pinout.xlsx</a></p>
<p><a href="1.ESP32_Touch.xlsx">1.ESP32_Touch.xlsx</a></p>
<p><a href="2.ESP32_Timer_PWM.xlsx">2.ESP32_Timer_PWM.xlsx</a></p>
<p><a href="0.ESP32_Pinout.pdf">0.ESP32_Pinout.pdf</a></p>
<p>在使用 ESP32的过程中需要注意 </p>
<ul>
<li>如果开机启用了Wi-Fi功能，那么需要注意其供电，启动时ESP32所需电流较大，需要保障电压，电流的稳定性。</li>
<li>在使用Platform进行 ESP32 nodemcu（好像是这个型号） 烧录过程中，如果无法进行一键烧录，可以尝试在烧录前/中，按下boot按键，稍等2，3s，待进度条走动时，松手即可。</li>
</ul>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266快速上手及常见问题</title>
    <url>/2021/09/12/ESP8266%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>ESP8266 是乐鑫公司所打造的一款低价，高性能的WiFI通信模块。</p>
<p>下列常见问题及解决方案均在 Win10 环境下</p>
  <a id="more"></a>
<h2 id="配置基本环境与文档"><a href="#配置基本环境与文档" class="headerlink" title="配置基本环境与文档"></a>配置基本环境与文档</h2><p>后续也许会补充。目前可以通过网络搜索快速获取。</p>
<h2 id="如何烧录8266？"><a href="#如何烧录8266？" class="headerlink" title="如何烧录8266？"></a>如何烧录8266？</h2><p>对于 NodeMCU，可以直接通过 USB 数据端口进行下载。</p>
<p>建议采用 arduino 环境开发（用 vscode 编辑），而不是使用 at 开发，今后使用 RTOS 之后再考虑其他事情。</p>
<h3 id="ESP8266-在使用过程中非常烫手？"><a href="#ESP8266-在使用过程中非常烫手？" class="headerlink" title="ESP8266 在使用过程中非常烫手？"></a>ESP8266 在使用过程中非常烫手？</h3><p>正常</p>
<h3 id="感觉代码没有问题，但数据传输时有时无，经常无效？"><a href="#感觉代码没有问题，但数据传输时有时无，经常无效？" class="headerlink" title="感觉代码没有问题，但数据传输时有时无，经常无效？"></a>感觉代码没有问题，但数据传输时有时无，经常无效？</h3><p><strong>晃动或换良好的杜邦线！</strong></p>
<h2 id="为何不显示端口号（连接后无反应）？"><a href="#为何不显示端口号（连接后无反应）？" class="headerlink" title="为何不显示端口号（连接后无反应）？"></a>为何不显示端口号（连接后无反应）？</h2><p><strong>换一根良好的数据线！</strong></p>
<p>大多数的数据线都是不支持的，只能用来供电</p>
<h2 id="如何解决使用-vscode-开发时出现的问题"><a href="#如何解决使用-vscode-开发时出现的问题" class="headerlink" title="如何解决使用 vscode 开发时出现的问题"></a>如何解决使用 vscode 开发时出现的问题</h2><h3 id="为什么出现很多红色波浪线？"><a href="#为什么出现很多红色波浪线？" class="headerlink" title="为什么出现很多红色波浪线？"></a>为什么出现很多红色波浪线？</h3><p>解决方案：</p>
<p>自己在配置 VS Code Arduino 开发环境中遇到的问题，类似这种，错误显示未定义标识符。关于 VS Code 配置 Arduino 开发环境<br>主要问题是头文件索引丢失，intellisense不能自动找到需要的头文件路径。需要在用户设置中强制intellisense使用Tag Parser,递归方式检索头文件。</p>
<p>在设置中添加如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">“C_Cpp.intelliSenseEngineFallback”: “Disabled”,<br><br>“C_Cpp.intelliSenseEngine”: “Tag Parser”,<br></code></pre></td></tr></table></figure>
<h3 id="为什么在编译时出现乱码？"><a href="#为什么在编译时出现乱码？" class="headerlink" title="为什么在编译时出现乱码？"></a>为什么在编译时出现乱码？</h3><p>打开文件：</p>
<p>C:\Users\userName.vscode\extensions\vsciot-vscode.vscode-arduino-0.4.0\out\src\common\util.js</p>
<p><img src="/2021/09/12/ESP8266%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Untitled.png" alt="Untitled"></p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/q1694222672/article/details/89214807" target="_blank" rel="noopener">NodeMCUArunino 方式</a></p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>Java无法仅读取一个字符</title>
    <url>/2020/02/25/Java%E6%97%A0%E6%B3%95%E4%BB%85%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>问题描述</p>
<p>在使用java中，有时希望可以像c语言一样单单读取一个字符，但是发现并没有nextChar()的方法可供使用。</p>
<p>解决办法</p>
<p>方法一是最常见的方法，和方法二类似都是先得到一个String字符串，然后得到第一个字符，而方法三是根本的解决办法（虽然不好用）</p>
<p><strong>方法一：</strong></p>
<p>1．先创建一个Scanner对象</p>
<p>2．调用Scanner对象的next()方法获取控制台输入，返回的是一个String类型,因为没有nextChar()方法</p>
<p>3．调用String的charAt(0)方法获取第一个字符</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br> String s = sc.next();<br><br> <span class="hljs-keyword">char</span> c = s.charAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//最后两条语句也可写为char c = sc.next().charAt(0);</span><br></code></pre></td></tr></table></figure>
<p><strong>方法二：</strong></p>
<p>使用方法，将string转换为字符数组，然后取第一个字符即可</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br><span class="hljs-keyword">char</span> c = scanner.next().toCharArray()[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>
<p><strong><em>方法三：</em></strong></p>
<p><em>需要有强制转换（因为in.read()得到的是int类型）</em></p>
<p>需要引入.io（import java.io.*;）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      t = (<span class="hljs-keyword">char</span>)System.in.read();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p> <strong>或</strong></p>
<p>2.在方法中抛出异常：public static void main(String[] args) throws IOException</p>
<p>然后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> t = <span class="hljs-number">0</span>;<br><br>t = (<span class="hljs-keyword">char</span>)System.in.read();<br></code></pre></td></tr></table></figure>
<p><img src="/2020/02/25/Java%E6%97%A0%E6%B3%95%E4%BB%85%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6/1.png" alt></p>
<p>但可以做到不影响其他的字符（真正意义上的读入一个字符）</p>
<p><img src="/2020/02/25/Java%E6%97%A0%E6%B3%95%E4%BB%85%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6/2.png" alt></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>L1-046整除光棍（模拟大数除法）</title>
    <url>/2020/01/05/L1-046%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D%EF%BC%88%E6%A8%A1%E6%8B%9F%E5%A4%A7%E6%95%B0%E9%99%A4%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p>
<p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个不以5结尾的正奇数<code>x</code>（&lt;1000）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs in">31<br></code></pre></td></tr></table></figure>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs out">3584229390681 15<br></code></pre></td></tr></table></figure>
<h3 id="题目思路分析："><a href="#题目思路分析：" class="headerlink" title="题目思路分析："></a>题目思路分析：</h3><p>第一次接触大数除法的模拟，在经历过一番思考后，选择了百度。。。</p>
<p>忽然发现思路其实就是模拟人的思路：假设我们也不知道多少个1才能将31整除。那么怎么得到那个很长的数呢？</p>
<ol>
<li>从1，11，111，一个一个去尝试。显然，不成立。（当然，我们可以直接从比除数大的111开始除，这也是后面变成的思路）</li>
<li>但如果我们实验过几次第一种方法后，我们会发现，其实我们只是在每一次的计算后（发现不能整除）我们就会添加一个1继续去除。之前的商就保留下来了，和我们使用竖式除法是一样的。我们只是需要每次除不尽的时候，填上一个1继续除便是了，之前的商直接输出不是更好。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>	<span class="hljs-keyword">int</span> x,s=<span class="hljs-number">0</span>,n=<span class="hljs-number">0</span>;<span class="hljs-comment">//除数，被除数，位数 </span><br>	<span class="hljs-built_in">cin</span>&gt;&gt;x;<br>	<span class="hljs-keyword">while</span>(s&lt;x)<br>	&#123;<br>		s=s*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//被除数末位添1直到不小于被除数 </span><br>		n++;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<span class="hljs-comment">//除法 </span><br>	&#123;<br>		<span class="hljs-built_in">cout</span>&lt;&lt;s/x;<span class="hljs-comment">//输出商（就作为开头咯） </span><br>		s%=x;<span class="hljs-comment">//被除数更改为其余数 </span><br>		<span class="hljs-keyword">if</span>(s==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//余数为0则结束（否则加1继续） </span><br>		s=s*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//被除数末位加上1</span><br>		n++; <br>	&#125;<br>	<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;n;<span class="hljs-comment">//之前已经输出了商（很大的数）</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>大数模拟，在没有更好的方法下，不如试试康康如果是我们，我们是怎么做的。。。</strong></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask_First_Api</title>
    <url>/2022/05/14/Flask_First_Api/</url>
    <content><![CDATA[<p>Flask 作为一个轻量级的 Python 前端网页框架，正在逐渐壮大，而在一些近期的一些项目中，也常出现其身影，作为前端和后端相互结合的框架，适合我们去快速构建一个服务器端的服务应用，同时也方便了自己的维护，更重要的是构建起较为完善的技术栈。</p>
  <a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在本次的 Flask 的初步学习中采用的环境是:<br>Python 3.85 + VScode + Conda + Flask2.1</p>
<h3 id="关于-VScode-配置"><a href="#关于-VScode-配置" class="headerlink" title="关于 VScode 配置"></a>关于 VScode 配置</h3><p>关于 Pycharm 还是 VScode，这里采用了 VScode，主要是觉得 Pycharm 有时打开时刻比较笨重，而且最近对于 Python 的开发比较少的在 VScode 中进行，希望能够因此而熟悉一下相关    操作。</p>
<p>VScode 的 Python 命令行配置<br>在编写完成一个 helloworld 的时候，我们想要使用 VScode 进行终端的操作，但是默认的 VScode 的终端操作是 Powershell（默认的前缀是 ps），不是很友好，而且对于 Conda 的适配不好，所以尽量更改为 cmd 环境。<br>在我们的 CMD 环境中，我们可以使用 Flask 命令进行更好的操作。</p>
<p>首先在右下角的终端处进行简单更多选项的箭头，选择默认配置文件<br><img src="/2022/05/14/Flask_First_Api/image20220513192022828.png" alt></p>
<p>进而选择 Command Prompt（这里我更改过了，所以默认就是 cmd）</p>
<p>然而，在我们再次打开 VScode 的时候，cmd 并不会自动激活 conda 或者进入相关路径，这时，我们自己在右下角新建一个终端即可。这样 cmd 的配置就可以了，Conda 会自动激活当前环境，Python 的编译器会在左下角进行选择，而更多的关于 VScode 的 Python 的环境配置，可以在互联网中进行搜索解决。</p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>主要使用的文档是官方文档的 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#" target="_blank" rel="noopener">QuickStart</a><br>开始第一个 Demo 吧<br><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)  <br><span class="hljs-meta">@app.route("/")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span><br></code></pre></td></tr></table></figure></p>
<p>如果将自己的 Python 文件命名为 app.py 就不用去设置环境变量了<br>如果命名为其他的需要去 声明一个环境变量（根据不同的 终端环境进行设置）其中 hello 为自己无 py 后缀的文件名。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#在 <span class="hljs-built_in">cmd</span> 下<br><span class="hljs-built_in">set</span> FLASK_APP=hello<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在bash下</span><br><span class="hljs-built_in">export</span> FLASK_APP=hello<br></code></pre></td></tr></table></figure>
<h3 id="对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下"><a href="#对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下" class="headerlink" title="对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下"></a>对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">File <span class="hljs-string">"E:\python3.8\lib\site-packages\jinja2\filters.py"</span>, line 13, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    from markupsafe import soft_unicode<br>ImportError: cannot import name <span class="hljs-string">'soft_unicode'</span> from <span class="hljs-string">'markupsafe'</span> (E:\python3.8\lib\site-packages\markupsafe\__init__.py)<br></code></pre></td></tr></table></figure>
<p>可以尝试去降级 MarkupSafe 以解决问题<br><code>pip install MarkupSafe==2.0.1</code></p>
<p>继续运行程序<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">flask run<br></code></pre></td></tr></table></figure><br>单击或自行访问出现的 <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> 即可查看到运行结果<br><img src="/2022/05/14/Flask_First_Api/image20220513193229672.png" alt><br><img src="/2022/05/14/Flask_First_Api/image20220513193448880.png" alt></p>
<p>可以看到在前面的 @app.route(“/“) 中引号内的内容，表示了 URL 路径。<br>我们可以添加一下代码，然后重新运行（需要关闭当前的 Flask 运行界面，然后重现 flask run）</p>
<figure class="highlight Python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/apple")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Apple</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"returned an apple!"</span><br></code></pre></td></tr></table></figure>
<p><img src="/2022/05/14/Flask_First_Api/image20220513194739396.png" alt></p>
<p>这样就实现了 API 的访问 （wow）<br>但是我们默认返回的是 String 字符串，这点需要注意。</p>
<h2 id="如何使用其他的访问方式-如-post？"><a href="#如何使用其他的访问方式-如-post？" class="headerlink" title="如何使用其他的访问方式 如 post？"></a>如何使用其他的访问方式 如 post？</h2><p>观察到我们命令行出现的提示信息：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1 - - [13/May/2022 19:45:15] <span class="hljs-string">"GET /apple HTTP/1.1"</span> 200 -<br></code></pre></td></tr></table></figure><br>采用的 获取方式都是 Get，一方面是因为 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#http-methods" target="_blank" rel="noopener">Flask 的默认方式</a> 就是 Get，另一方面是因为采用浏览器访问，访问就是 Get 方式。</p>
<h3 id="如何处理-post-请求，Flask-方面的解决办法是"><a href="#如何处理-post-请求，Flask-方面的解决办法是" class="headerlink" title="如何处理 post 请求，Flask 方面的解决办法是"></a>如何处理 post 请求，Flask 方面的解决办法是</h3><p>添加模块<br><code>from flask import request</code><br>然后对比修改代码，如下：</p>
<figure class="highlight Python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/",methods=['GET', 'POST'])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"here is a post"</span><br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span><br></code></pre></td></tr></table></figure>
<p>需要注意，对于模块的 import 如果大小写引入错误，将会无法正常运行，同样需要注意 method 和 methods 的区分</p>
<h3 id="如何发送-post-请求"><a href="#如何发送-post-请求" class="headerlink" title="如何发送 post 请求"></a>如何发送 post 请求</h3><p>这里采用 postman 本地应用进行发送 post 请求<br><img src="/2022/05/14/Flask_First_Api/image20220513200854627.png" alt></p>
<h2 id="如何返回-JSON"><a href="#如何返回-JSON" class="headerlink" title="如何返回 JSON"></a>如何返回 JSON</h2><p>JSON 是一个结构化的数据，可以方便我们进行数据的处理<br>对于 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#about-responses" target="_blank" rel="noopener">JSON 的返回值处理</a> ，我们根据文档可以看出，如果采用字典返回那么自动就会通过 一个方法<code>jsonify</code>转换成json<br><figure class="highlight Python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> dict(name = <span class="hljs-string">'a'</span>,num = <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure></p>
<p>添加代码后，重启服务，访问 <a href="http://127.0.0.1:5000/json" target="_blank" rel="noopener">http://127.0.0.1:5000/json</a><br><img src="/2022/05/14/Flask_First_Api/image20220513224148375.png" alt><br>可以看到， Firefox 浏览器自动将其解析为了 Json ，并进行了梅花，方便了阅读和处理。</p>
<h2 id="如何从前端获取数据到后端"><a href="#如何从前端获取数据到后端" class="headerlink" title="如何从前端获取数据到后端"></a>如何从前端获取数据到后端</h2><p>在 web 开发的过程中，从客户端获取信息到服务器上，就需要对于 Request 作出一定的处理：</p>
<h3 id="在-URL-中添加-参数-信息"><a href="#在-URL-中添加-参数-信息" class="headerlink" title="在 URL 中添加 参数 信息"></a>在 URL 中添加 参数 信息</h3><p>通常使用 get 进行操作<br>代码参考如下：<br><figure class="highlight Python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json_another")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json_another</span><span class="hljs-params">()</span>:</span><br>    name = request.args.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'qaq'</span>):<br>        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'flase'</span>)<br></code></pre></td></tr></table></figure><br>如果在访问 <a href="http://127.0.0.1:5000/json_another" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another</a> 而不加任何参数的时候，就会获取不到相关的内容，进而判断失败。</p>
<p><img src="/2022/05/14/Flask_First_Api/image20220513230539337.png" alt></p>
<p>如果 <a href="http://127.0.0.1:5000/json_another?name=qaq" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another?name=qaq</a> 输入正确的用户名和变量名称，那么就可以检测成功。</p>
<p><img src="/2022/05/14/Flask_First_Api/image20220513230650761.png" alt></p>
<h3 id="采用-body-的form-和-json-形式传输数据"><a href="#采用-body-的form-和-json-形式传输数据" class="headerlink" title="采用 body 的form 和 json 形式传输数据"></a>采用 body 的form 和 json 形式传输数据</h3><p>而在文档上，也提供给了我们 <a href="https://flask.palletsprojects.com/en/2.1.x/api/#flask.Request.form" target="_blank" rel="noopener" title="flask.Request.form"><code>form</code></a> 的形式，通常我们如果需要发送数据到服务器上去，往往采用 post 和 put 这样比较规范的操作（据说使用get也可以，但是有的公司万物皆哈梭 get ，总是不太好，丧失了规范性）</p>
<p>有时同样的代码也会有一写小 bug,通过下面的一些代码，借由 Postman 软件进行发送 post 请求，进行测试</p>
<figure class="highlight Python"><table><tr><td class="code"><pre><code class="hljs Python"><br><span class="hljs-meta">@app.route("/form",methods=['GET','POST'])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">form</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:<br>        print(request.form.get(<span class="hljs-string">'name'</span>))<br>        print(request.json)<br>        print(request.data)<br>        Fname = request.form.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)<br>        <span class="hljs-keyword">if</span> (Fname == <span class="hljs-string">'null'</span>):<br>            Jname = request.json.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)<br>            <span class="hljs-keyword">if</span>(Jname == <span class="hljs-string">'qaq'</span>):<br>                <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'true'</span>)<br>        <span class="hljs-keyword">if</span>(Fname == <span class="hljs-string">'pap'</span>):<br>            <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)<br>        <span class="hljs-keyword">else</span> :<br>            <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'false'</span>)<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"this is a get request"</span><br></code></pre></td></tr></table></figure>
<p>可以看到，/form URL 路径仅仅对于 post 请求作出了回应，如果是其他类型的请求，直接返回  “this is a get request”<br>对于 post 请求，我们在里面放置了两种在 Body 里面的格式内容，分别是 form 和 json<br>这两种我们都将会去使用：为了避免冲突，所以将 json 和 form 的调试放在了有些不一样的 if 分支里面。<br>对于 form：<br><img src="/2022/05/14/Flask_First_Api/image20220514075344866.png" alt><br>对于 json<br><img src="/2022/05/14/Flask_First_Api/image20220514075407137.png" alt></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-033出生年</title>
    <url>/2020/01/04/L1-033%E5%87%BA%E7%94%9F%E5%B9%B4/</url>
    <content><![CDATA[<p><img src="/2020/01/04/L1-033%E5%87%BA%E7%94%9F%E5%B9%B4/blog\hexo\source\_posts\jmK5wuZkEV4aCdJ.png" alt="image.png"></p>
<p>以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于<code>y</code>年，直到<code>x</code>岁才遇到<code>n</code>个数字都不相同的年份”这句话。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出出生年份<code>y</code>和目标年份中不同数字的个数<code>n</code>，其中<code>y</code>在[1, 3000]之间，<code>n</code>可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>根据输入，输出<code>x</code>和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“<code>n</code>个数字都不相同”是指不同的数字正好是<code>n</code>个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs in">1988 4<br></code></pre></td></tr></table></figure>
<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs out">25 2013<br></code></pre></td></tr></table></figure>
<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure>
<h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>起初打算使用int，来储存，最后使用%04的输出。但是由于分解数字等太麻烦（其实计算各个数字出现的次数才是最麻烦的）期间还使用了sort来排序，方便得到cnt（多少个不同数字）但是这样有改变了原来的年份。。。最终，还是使用了最基本的字符。</p>
<p>在实现题目要求的时候，常常遇到没有初始化而遇到到许多问题（记得初始化呀。。。</p>
<p>经过思考，采用a[4]来表示年份，b[10]来记录数字出现的次数。（直接赋值1）这样有几个1就有多少个不同的数字。（算是一种逆向吧，不怕数字重复了。。）</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//调试的好麻烦。。</span><br>	<br>	<span class="hljs-keyword">int</span> n;<br>	<span class="hljs-keyword">char</span> a[<span class="hljs-number">4</span>];<br>	<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b[<span class="hljs-number">10</span>];<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s %d"</span>,&amp;a,&amp;n);<br>	<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">strlen</span>(a)&lt;<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//将其化为四位年份 (buling)</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//from 2 to 0;</span><br>			a[i+<span class="hljs-number">1</span>]=a[i];<br>		&#125;a[<span class="hljs-number">0</span>]=<span class="hljs-string">'0'</span>;<span class="hljs-comment">//不是0而是‘0'</span><br>	&#125;<br>	<span class="hljs-keyword">int</span> start=(a[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">1000</span>+(a[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">100</span>+(a[<span class="hljs-number">2</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+a[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>;<br>	b[(a[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[(a[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[(a[<span class="hljs-number">2</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[a[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>]=<span class="hljs-number">1</span>;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(b[i])&#123;<br>			cnt++;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">while</span>(cnt!=n)&#123;<br>		cnt=<span class="hljs-number">0</span>;<br>	a[<span class="hljs-number">3</span>]++;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)b[i]=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<span class="hljs-comment">//进位 </span><br>		<span class="hljs-keyword">if</span>(a[j]==<span class="hljs-string">':'</span>)&#123;<br>			a[j]=<span class="hljs-string">'0'</span>;<br>			a[j<span class="hljs-number">-1</span>]+=<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	b[(a[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[(a[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[(a[<span class="hljs-number">2</span>]-<span class="hljs-string">'0'</span>)]=<span class="hljs-number">1</span>;<br>	b[a[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>]=<span class="hljs-number">1</span>;<br><br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(b[i])&#123;<br>			cnt++;<br>		&#125;<br>	&#125;	<br>	&#125;<br>	<span class="hljs-keyword">int</span> end=(a[<span class="hljs-number">0</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">1000</span>+(a[<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">100</span>+(a[<span class="hljs-number">2</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span>+a[<span class="hljs-number">3</span>]-<span class="hljs-string">'0'</span>;<br>	<span class="hljs-built_in">cout</span>&lt;&lt;end-start&lt;&lt;<span class="hljs-string">" "</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%04d"</span>,end);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-048矩阵A乘以B</title>
    <url>/2020/01/06/L1-048%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B/</url>
    <content><![CDATA[<p>给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出<code>Error: Ca != Rb</code>，其中<code>Ca</code>是A的列数，<code>Rb</code>是B的行数。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs in">2 3<br>1 2 3<br>4 5 6<br>3 4<br>7 8 9 0<br>-1 -2 -3 -4<br>5 6 7 8<br></code></pre></td></tr></table></figure>
<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs out">2 4<br>20 22 24 16<br>53 58 63 28<br></code></pre></td></tr></table></figure>
<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">38</span> <span class="hljs-number">26</span><br><span class="hljs-number">43</span> <span class="hljs-number">-5</span><br><span class="hljs-number">0</span> <span class="hljs-number">17</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">-11</span> <span class="hljs-number">57</span><br><span class="hljs-number">99</span> <span class="hljs-number">68</span><br><span class="hljs-number">81</span> <span class="hljs-number">72</span><br></code></pre></td></tr></table></figure>
<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>2 != 3<br></code></pre></td></tr></table></figure>
<h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>一开始，一看题目。嗯！没有思路。。。</p>
<p>什么是矩阵乘法呢？（此处可以百度了解以下）</p>
<p><img src="https://i.loli.net/2020/01/07/drTUXefu1ItHyLm.png" alt="BWqSKunTFkLpziP.png"></p>
<p>简单地说就是上述公式。百度词条中这样定义：</p>
<p><img src="https://i.loli.net/2020/01/06/vBWcMO1TzVIKuPG.png" alt="图片.png"></p>
<p>看完之后，我们就或许有了一点思路。</p>
<p>于是如果符合条件，我们就依次计算输出即可。</p>
<p>但是！！！</p>
<p>这道题最最关键的就是各种不同的自定义字母所代表的含义。（比如上图中的是b  [1 ] [1]  其实在数组中是b [0] [0];谨慎呀！！！<del>（找这个bug找的脑壳疼）</del></p>
<p>当然，也可以动态数组，但是这样更好理解一一些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>	<span class="hljs-keyword">int</span> c1,c2,r1,r2; <br>	<span class="hljs-keyword">int</span> i,j;<br>	<span class="hljs-built_in">cin</span>&gt;&gt;r1&gt;&gt;c1;	<br>	<span class="hljs-keyword">int</span> m[r1][c1];<span class="hljs-comment">//定义并得到两个数组 </span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r1;i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>;j&lt;c1;j++)<br>		&#123;<br>			<span class="hljs-built_in">cin</span>&gt;&gt;m[i][j];<br>		&#125;<br>	&#125;	<br>	<span class="hljs-built_in">cin</span>&gt;&gt;r2&gt;&gt;c2;	<br>	<span class="hljs-keyword">int</span> n[r2][c2];<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r2;i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>;j&lt;c2;j++)<br>		&#123;<br>			<span class="hljs-built_in">cin</span>&gt;&gt;n[i][j];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(c1==r2)<br>	&#123;<span class="hljs-comment">//首先排除不相等的情况 (规模是否相等） </span><br>		<span class="hljs-built_in">cout</span>&lt;&lt;r1&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;c2&lt;&lt;<span class="hljs-built_in">endl</span>;<br>		<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;r1;i++)&#123;<span class="hljs-comment">//前两个for得到n个item； </span><br>			<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;c2;j++)<br>			&#123;<span class="hljs-comment">//输出每一行； </span><br>				<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;c1;k++)&#123;<span class="hljs-comment">//（见公式）； </span><br>				sum=sum+m[i][k]*n[k][j];<br>			&#125;<br>			<span class="hljs-built_in">cout</span>&lt;&lt;sum;<br>			<span class="hljs-keyword">if</span>(j!=c2<span class="hljs-number">-1</span>)<br>			  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>;<br>		&#125;<br>		<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>	&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error: "</span>&lt;&lt;c2&lt;&lt;<span class="hljs-string">" != "</span>&lt;&lt;r2;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-050倒数第N个字符串</title>
    <url>/2020/01/06/L1-050%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz  }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs in">3 7417<br></code></pre></td></tr></table></figure>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs out">pat<br></code></pre></td></tr></table></figure>
<h2 id="首先："><a href="#首先：" class="headerlink" title="首先："></a>首先：</h2><p>我们发现下图的诡异场景第50题看似准确率不算很低，但是吧，做的人少呀。顿时比其他少了一半，给这道题目布满诡异的气氛。</p>
<p><img src="https://i.loli.net/2020/01/07/IBXFH3viYGakNlS.png" alt="6i5tGebuBCwXaoE.png"></p>
<p>开始做题时，发觉这应该是一道类似于进制转换的题目。</p>
<p><strong>但是！</strong>做了题才发现有这么几个坑：</p>
<ol>
<li>英文字母26个谢谢。<del>不是24 。</del></li>
<li>pow()函数中;pow返回值为double。此处强制转换为int了，应该是26的转换为25了 。所以在使用pow函数时要小心了。</li>
<li>第一个数其实是第0个数，第二个是第一个，不是么？</li>
</ol>
<h3 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h3><h3 id="方一：递归："><a href="#方一：递归：" class="headerlink" title="方一：递归："></a>方一：递归：</h3><p>下面的递归应该是比较好理解的进制转换方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,l;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>) f(a - <span class="hljs-number">1</span>,b / <span class="hljs-number">26</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,<span class="hljs-string">'z'</span> - (b % <span class="hljs-number">26</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;l;<br>    f(n,l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果我们想要使得的第二个输入的n为正序，那么我们可以将其与最大做差得到倒序的值（2333）当然，我们调一下代码也是可以的。</p>
<p>将</p>
<p>printf(“%c”,’z’ - (b % 26));</p>
<p>调为</p>
<p>printf(“%c”,’a’ + (b % 26));即可</p>
<h3 id="方二："><a href="#方二：" class="headerlink" title="方二："></a>方二：</h3><p>当然我们也可以使用字符串将每个字符储存，最后输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> l,n,c;<br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">7</span>];<br>    <span class="hljs-built_in">cin</span>&gt;&gt;l&gt;&gt;n;<br>    c = l - <span class="hljs-number">1</span>;<br>    s[l] = <span class="hljs-string">'\0'</span>;<br>    n --;<br>    <span class="hljs-keyword">while</span>(n || c &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        s[c --] = <span class="hljs-string">'z'</span> - n % <span class="hljs-number">26</span>;<br>        n /= <span class="hljs-number">26</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;s;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>L298N驱动电机</title>
    <url>/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/</url>
    <content><![CDATA[<p>简要介绍了L298N的接线方式，驱动原理及相关简要代码</p>
  <a id="more"></a>
<h2 id="引脚介绍"><a href="#引脚介绍" class="headerlink" title="引脚介绍"></a>引脚介绍</h2><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298N.png" alt="L298N"></p>
<h2 id="需要注意事项："><a href="#需要注意事项：" class="headerlink" title="需要注意事项："></a>需要注意事项：</h2><p>L298N的+12V需要电压在 +7VDC to +35VDC.如果使用的电源超过了12V那么请将跳帽拔掉。</p>
<p>同时需要 mcu 和 L298N 供地。</p>
<p>H桥中，四个input对应四个output(Terminal)</p>
<p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/1.png" alt="1"></p>
<p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/2.png" alt="2"></p>
<p>通过对于IN的控制就可以控制out，促使其连接到的电机正转或着反转（并可以控制速度，PWM？）</p>
<h2 id="具体操作逻辑："><a href="#具体操作逻辑：" class="headerlink" title="具体操作逻辑："></a>具体操作逻辑：</h2><h3 id="对于普通的马达电机："><a href="#对于普通的马达电机：" class="headerlink" title="对于普通的马达电机："></a>对于普通的马达电机：</h3><p>那么只需要将其正负连接至out1，out2，通过in1，in2来控制正负就可以驱动了。</p>
<p>对于Arduino 来说更为简单。</p>
<p>其中ena非必需（采用跳帽，也可达到效果）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Motor Connections</span><br><span class="hljs-comment">//Change this if you wish to use another diagram</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnA 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnB 5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In1 9</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In2 8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In3 7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In4 6</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span><br></span>&#123;<br>  <span class="hljs-comment">// All motor control pins are outputs</span><br>  <span class="hljs-built_in">pinMode</span>(EnA, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(EnB, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In1, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In2, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In3, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In4, <span class="hljs-literal">OUTPUT</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goStraight</span><span class="hljs-params">()</span>   <span class="hljs-comment">//run both motors in the same direction</span><br></span>&#123;<br>  <span class="hljs-comment">// turn on motor A</span><br>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-comment">// set speed to 150 out 255</span><br>  <span class="hljs-built_in">analogWrite</span>(EnA, <span class="hljs-number">200</span>);<br>  <span class="hljs-comment">// turn on motor B</span><br>  <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-comment">// set speed to 150 out 255</span><br>  <span class="hljs-built_in">analogWrite</span>(EnB, <span class="hljs-number">200</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br>  <span class="hljs-comment">// now turn off motors</span><br>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);  <br>  <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span><br></span>&#123;<br>  goStraight();<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="驱动Step-moto-28BYJ-48"><a href="#驱动Step-moto-28BYJ-48" class="headerlink" title="驱动Step moto 28BYJ-48"></a>驱动Step moto 28BYJ-48</h3><p>该继步马达一共拥有五根线，则如果需要采用L298N来驱动，一个L298N那么只能驱动一个继步电机。</p>
<p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n1.png" alt="1"></p>
<p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n2.png" alt="2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Example sketch to control a stepper motor with L298N motor driver, Arduino UNO and Stepper.h library. More info: &lt;https://www.makerguides.com&gt; */</span><br><br><span class="hljs-comment">// Include the Stepper library:</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Stepper.h&gt;</span></span><br><br><span class="hljs-comment">// Define number of steps per revolution:</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> stepsPerRevolution = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// Initialize the stepper library on pins 8 through 11:</span><br><span class="hljs-built_in">Stepper</span> myStepper = <span class="hljs-built_in">Stepper</span>(stepsPerRevolution, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Set the motor speed (RPMs):</span><br>  myStepper.<span class="hljs-built_in">setSpeed</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Step one revolution in one direction:</span><br>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">500</span>);<br><br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br><br>  <span class="hljs-comment">// Step on revolution in the other direction:</span><br>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">-500</span>);<br><br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考连接：</p>
<p><a href="https://www.makerguides.com/l298n-stepper-motor-arduino-tutorial/" target="_blank" rel="noopener">Stepper Motor with L298N and Arduino Tutorial (4 Examples)</a></p>
<p><a href="https://www.teachmemicro.com/use-l298n-motor-driver/" target="_blank" rel="noopener">How to Use L298N Motor Driver | Microcontroller Tutorials</a></p>
<p><a href="https://rjdlee.com/arduino-wemos-with-l298n-controller-and-28byj-48-stepper-motor/" target="_blank" rel="noopener">Arduino WeMos with L298N Controller and 28BYJ-48 Stepper Motor</a></p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
  </entry>
  <entry>
    <title>P1023税收与补贴问题</title>
    <url>/2020/02/29/P1023%E7%A8%8E%E6%94%B6%E4%B8%8E%E8%A1%A5%E8%B4%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）</p>
<p>对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。</p>
<p>总利润=单位商品利润   × × 销量</p>
<p>单位商品利润=单位商品价格 - 单位商品成本 （- 税金  or  + 补贴）</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行−1-1−1，−1-1−1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。</p>
<p>如在政府预期价上不能得到最大总利润，则输出“NO SOLUTION”。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">31</span><br><span class="hljs-number">28</span> <span class="hljs-number">130</span><br><span class="hljs-number">30</span> <span class="hljs-number">120</span><br><span class="hljs-number">31</span> <span class="hljs-number">110</span><br><span class="hljs-number">-1</span>  <span class="hljs-number">-1</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #1</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>所有数字均小于100000</p>
<h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h3 id="tips：说实话，这个题目看了很久。。。"><a href="#tips：说实话，这个题目看了很久。。。" class="headerlink" title="tips：说实话，这个题目看了很久。。。"></a>tips：说实话，这个题目看了很久。。。</h3><p>最后，发现所求的是什么了。是要求政府给定一个预期的价格，然后你去尝试不同的补贴或者税收，得到他们的利润，并<strong>看看在每种税收或补贴下总利润最高的价格是不是政府预期价</strong> 。（可以好好思考一下这句，那么我们就计算出不同补贴或税收下，利润最大的价格，再比较）</p>
<p>（最后，好像没有不符合条件的，所以不用管。。。）</p>
<p>那么：</p>
<ol>
<li><p>我们可以先将购买者的价格和所对应的销量全部存起来，但这又有两个问题：</p>
<p>1）在题目给出的价格和销量之间，销量是随价格线性变化的，我们可通过计算得出期间的对应价格与销量，并都储存起来。（具体实施方法见代码）即 价格-销量表。 </p>
<p>2）再输入的最后给定了之后的销量减少值，我们就可以从中得到其后，一直到销量小于0的对应关系，并储存起来。</p>
</li>
<li><p>最后再根据不同的补贴（税收）（用一个循环从1开始跑到10000）依次计算其最大利润，并比较在该最大利润的价格是否与政府的价格相同。</p>
</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码来源：https://www.luogu.com.cn/user/174034</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>][<span class="hljs-number">3</span>];<span class="hljs-comment">//用于存放价格和销量的数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,k,expect,down,<span class="hljs-built_in">max</span>,temp,cha,xl,num,s,price,p;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;expect;<span class="hljs-comment">//读入预期价</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a[i][<span class="hljs-number">1</span>]&gt;&gt;a[i][<span class="hljs-number">2</span>]&amp;&amp;a[i][<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>&amp;&amp;a[i] [<span class="hljs-number">2</span>]!=<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果输入的两个数不是-1，-1</span><br>    &#123;<br>        i++;<span class="hljs-comment">//循环变量i++</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">2</span>&amp;&amp;a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-a[i<span class="hljs-number">-2</span>][<span class="hljs-number">1</span>]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果两个价格之间差大于一</span><br>        &#123;<br>            i--;<span class="hljs-comment">//回到上一个读入的销量</span><br>            cha=(a[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-a[i][<span class="hljs-number">2</span>])/(a[i][<span class="hljs-number">1</span>]-a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//求出每次销量减少多少：销量差/价格差</span><br>            temp=a[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//记录下价格</span><br>            <span class="hljs-keyword">for</span>(j=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;j&lt;=temp;j++)<span class="hljs-comment">//按价格递增顺序依次写入</span><br>            &#123;<br>                a[i][<span class="hljs-number">1</span>]=j;<span class="hljs-comment">//写入价格</span><br>                a[i][<span class="hljs-number">2</span>]=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-cha;<span class="hljs-comment">//按销量差写入销量</span><br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;down;<span class="hljs-comment">//输入超过最大价格之后每次销量降低多少</span><br>    i--;<span class="hljs-comment">//因为上面的while循环最后有i++所以用i--抵消……</span><br>    xl=a[i][<span class="hljs-number">2</span>];<span class="hljs-comment">//记录目前的销量</span><br>    <span class="hljs-keyword">while</span>(xl&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(xl-down&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如销量小于零则退出</span><br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//否则</span><br>        &#123;<br>            xl-=down;<span class="hljs-comment">//销量每次减掉down</span><br>            i++;<span class="hljs-comment">//循环变量++</span><br>            a[i][<span class="hljs-number">1</span>]=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-comment">//每次价格+1</span><br>            a[i][<span class="hljs-number">2</span>]=xl;<span class="hljs-comment">//销量就是xl</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10000</span>;j++)<span class="hljs-comment">//该遍历了，因为收税相当于补贴*-1所以记录一下符号即可</span><br>    &#123;<br>        <span class="hljs-built_in">max</span>=<span class="hljs-number">-99999</span>;<span class="hljs-comment">//用于存储最大的总利润</span><br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=i;k++)<span class="hljs-comment">//每次扫一遍每一种价格</span><br>        &#123;<br>            num=(a[k][<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+j)*a[k][<span class="hljs-number">2</span>];<span class="hljs-comment">//套公式算出总利润</span><br>            <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-built_in">max</span>)<span class="hljs-comment">//如果总利润比目前最大的大</span><br>            &#123;<br>                <span class="hljs-built_in">max</span>=num;<span class="hljs-comment">//更新max</span><br>                price=a[k][<span class="hljs-number">1</span>];<span class="hljs-comment">//记录下价格</span><br>                p=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录下符号</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(price==expect)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;j*p;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//如果价格就是政府预期价则打印出来，因为本身就是从小到大遍历所以不用求绝对值最小的</span><br>        <span class="hljs-built_in">max</span>=<span class="hljs-number">-99999</span>;<span class="hljs-comment">//后面是收税，原理同上</span><br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=i;k++)<br>        &#123;<br>            num=(a[k][<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-j)*a[k][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-built_in">max</span>)<br>            &#123;<br>               <span class="hljs-built_in">max</span>=num;<br>                price=a[k][<span class="hljs-number">1</span>];  <br>                p=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(price==expect)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;j*p;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList链表</title>
    <url>/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>今天说说链表：说到链表就不得不提及数组，两者相爱相杀，但又都是极为重要的基本数据结构类型。</p>
<p>相对于链表，我们一般情况下更熟悉数组。</p>
<p>（<del>听说加上英文，会显得高端不少</del>）：</p>
<h2 id="先讲一个小故事（虽然讲的很烂2333）"><a href="#先讲一个小故事（虽然讲的很烂2333）" class="headerlink" title="先讲一个小故事（虽然讲的很烂2333）"></a>先讲一个小故事（虽然讲的很烂2333）</h2><p>从前，一群小朋友外出游玩，到酒店申请房间啊，他们呢，申请的是数组方式的房间（哈哈）那么他们的房间号就是相连的。他们很容易的相互串门，带队者也可以轻松的找到他们每个人的所在（带队者只用记住第一个小朋友的位置和学号就好）。但问题是，他们这样申请房间的话，有的小朋友如果申请更换房间，会比较麻烦，更有甚者，不小心生病了，需要退房，那么负责人就要重新给每个人好分配房间，大多数小朋友都需要更换自己的房间，就会很麻烦。这时候，酒店管理者想到，如果我们让学号相邻的小朋友的记住他（她）下一个学号的小朋友的房间号（就像一号记住二号的房间号，二号记住三号的房间号），那么负责人还是只用记住第一个小朋友的房间号就可以按照顺序依次找到每个小朋友。（<del>当然要是其中一个小朋友忘记后面小朋友的位置的话。。。我们就失去了一堆小朋友</del>）。酒店管理者发现这样的话，不仅可以使得他们的房间利用率得到大大的提升，并且可以方便住宿人员的调动。</p>
<p>好的，相信读完这个尴尬的小故事，我们大概对链表有了一个感性的认识，他是为了解决一些数组的不足而出现的。下面就是严谨的分析链表的优缺点。</p>
<p>作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。</p>
<p>初学链表，一般从单向链表开始：（本文也暂时只有单向链表）</p>
<h2 id="Advantages-优势"><a href="#Advantages-优势" class="headerlink" title="Advantages 优势"></a><strong>Advantages 优势</strong></h2><p><strong>1)</strong> Dynamic size（动态大小）</p>
<p><strong>2)</strong> Ease of insertion/deletion（方便插入和删除）</p>
<h2 id="Drawbacks-缺点"><a href="#Drawbacks-缺点" class="headerlink" title="Drawbacks 缺点"></a><strong>Drawbacks 缺点</strong></h2><p><strong>1)</strong> Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists efficiently with its default implementation. </p>
<p>不允许随机访问。 我们必须从第一个节点开始顺序访问元素。 因此，我们无法使用其默认实现对链接列表进行有效的二分查找。</p>
<p><strong>2)</strong> Extra memory space for a pointer is required with each element of the list.</p>
<p>需要额外的空间去存放链表中下一个元素的位置。</p>
<p><strong>3)</strong> Not cache friendly. Since array elements are<br>contiguous locations, there is locality of reference which is not there<br>in case of linked lists.</p>
<p>不缓存友好。 由于数组元素是连续的位置，因此存在引用位置，而在链接列表的情况下则不存在。</p>
<p>（就是说不能写成a[6])</p>
<h2 id="Representation-表达（内容）"><a href="#Representation-表达（内容）" class="headerlink" title="Representation  表达（内容）"></a><strong>Representation  表达（内容）</strong></h2><p>首先，我们将一个链表中的每个元素称为一个节点（Node),特殊的第一个被叫做头节点，最后一个被叫做尾节点。（图中，abcd是四个节点，但注意a不是头节点哈哈，Head是头节点，他指向的a节点）一般来说，头节点Head不存放内容，尾节点没有下一个元素的位置。（以简单的单链表为例）</p>
<p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/Linkedlist.png" alt="linkedList/Linkedlist.png"></p>
<p>A linked list is represented by a pointer to the first node of the<br>linked list. The first node is called the head. If the linked list is<br>empty, then the value of the head is NULL.</p>
<p>链接列表由指向链接列表的第一个节点的指针表示。 第一个节点称为头。 如果链表为空，则head的值为NULL。（<del>好绕口</del>）<br>Each node in a list consists of at least two parts:</p>
<p>每一个节点至少包括两部分：<br>1) data 数据<br>2) Pointer (Or Reference) to the next node 指向下一个结点的指针（指向/引用）<br>In C, we can represent a node using structures. Below is an example of a linked list node with integer data.</p>
<p>在c语言中，我们使用结构体来表示，如下面的代码:</p>
<pre><code>struct Node {
int data;
struct Node* next;
};
</code></pre><p>In Java or C#, LinkedList can be represented as a class and a Node as a<br>separate class. The LinkedList class contains a reference of Node class<br>type.</p>
<p>而在java，c#中LinkedList可以表示为一个类，而Node可以表示为单独的类。 LinkedList类包含Node类类型的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> &#123;</span> <br>	Node head; <span class="hljs-comment">// head of the list </span><br><br>	<span class="hljs-comment">/* Linked list Node*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span> <br>		<span class="hljs-keyword">int</span> data; <br>		Node next; <br><br>		<span class="hljs-comment">// Constructor to create a new node </span><br>		<span class="hljs-comment">// Next is by default initialized </span><br>		<span class="hljs-comment">// as null </span><br>		Node(<span class="hljs-keyword">int</span> d) &#123; data = d; &#125; <br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="写一下链表？"><a href="#写一下链表？" class="headerlink" title="写一下链表？"></a>写一下链表？</h2><h3 id="我们从c开始尝试：-现在只写到了增）"><a href="#我们从c开始尝试：-现在只写到了增）" class="headerlink" title="我们从c开始尝试：(现在只写到了增）"></a>我们从c开始尝试：(现在只写到了增）</h3><p>好的，在此之前，我们似乎好像可能看起来学会了如何使用，但是看懂了和会写出来中间还是有一定的差距的。</p>
<p>链表还有一下基础的知识需要去掌握：</p>
<p><a href="https://www.runoob.com/cprogramming/c-function-malloc.html" target="_blank" rel="noopener">malloc</a> ：用于申请一定的内存.</p>
<p>那么这句(struct Node*)malloc(sizeof(struct Node))是什么鬼呢？（<del>这也太长了吧</del>）</p>
<p>不急，我们仔细看看，他是申请了一个内存，多大呢？（struct Node）类型的所需要的储存空间；（就像房间的类型一样，偏要双人床的那种）</p>
<p>那么前面的那个（struct Node*）是？哦，他是说这一块申请来的内存要强制转化成struct Node类型的，就是说专门给节点使用的。<del>（自己辛辛苦苦申请来的，才不给别人用呢）。</del></p>
<p>对了，这句话是会返回一个地址的，就是指向自己申请内存的位置。</p>
<p><strong>注意：节点呀！只有Head和普通节点。我们说的头指针，尾指针一类的，都是仅仅声明，作用就像房卡一样，是可以换的，里面存放的是链表中节点的地址。</strong></p>
<p>好的，下面我们要耐住性子，认真的学习咯（后文的故事如果听不太懂，放心你不是一个人，多看看不是故事的内容会更好）；（下面是一个标准化的介绍）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program to introduce </span><br><span class="hljs-comment">// a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br><br><span class="hljs-comment">//这个结构体就是我们要用到的节点了，</span><br><span class="hljs-comment">//既然c语言里的基本类型没有，我们就自己造一个。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br>	<span class="hljs-keyword">int</span> data; <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br><br><span class="hljs-comment">// Program to create a simple linkedlist with 3 nodes </span><br><span class="hljs-comment">//编程去建立一个有三个节点的链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br>	<span class="hljs-comment">//声明3个节点，注意了哈，这里是声明！！！</span><br>	<span class="hljs-comment">//并没用得到那三个节点，就像我们拿到了三个空门牌，但是房间还没造出来呢</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br><br>	<span class="hljs-comment">// allocate 3 nodes in the heap</span><br>	<span class="hljs-comment">//从堆中申请三个节点的内存（这会儿才得到房间了，并把房间号写在了门牌上） </span><br>	head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>	second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>	third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br><br>	<span class="hljs-comment">/* Three blocks have been allocated dynamically. <br>	We have pointers to these three blocks as head, <br>	second and third	 <br>	下面是灵魂的绘图（佩服佩服）来表示我们所申请的三个节点的储存状态，<br>	他们是不相连的哦<br>	head		        second	   	 third <br>		|		         	 |		    	   | <br>		|	          	 |	     		   |<br>	+---+-----+	 +----+----+	 +----+----+ <br>	| # | # |	    | # | # |	    | # | # | <br>	+---+-----+	 +----+----+	 +----+----+ <br>	#代表了随机值，一个是数据，一个是指针，<br>	和我们的stuct node结构相同哦，<br>	但是他们现在还是随机值，因为我们没有给他们赋值。<br>	<br>	# represents any random value. <br>	Data is random because we haven’t assigned <br>	anything yet */</span><br><br>	head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>	head-&gt;next = second; <br>	<span class="hljs-comment">// Link first node with the second node </span><br>	<span class="hljs-comment">// 我们给第一个节点赋值了，并且告诉了他下一个节点的位置</span><br><br>	<span class="hljs-comment">/* data has been assigned to the data part of the first <br>	block (block pointed by the head). And next <br>	pointer of first block points to second. <br>	So they both are linked. <br>	//那个代码由于复制可能会造成错位，木得办法，撮合着看把哈哈。<br>		head		 second		 third <br>			|			 |			 | <br>			|			 |			 | <br>	+---+---+	 +----+----+	 +-----+----+ <br>	| 1 | o-----&gt;| # | # |	 | # | # | <br>	+---+---+	 +----+----+	 +-----+----+	 <br>	*/</span><br><br>	<span class="hljs-comment">// assign data to second node </span><br>	second-&gt;data = <span class="hljs-number">2</span>; <br><br>	<span class="hljs-comment">// Link second node with the third node </span><br>	second-&gt;next = third; <br><br>	<span class="hljs-comment">//同上，给第二个赋值，并且告诉他下一个在哪里</span><br>	<span class="hljs-comment">/* data has been assigned to the data part of the second <br>	block (block pointed by second). And next <br>	pointer of the second block points to the third <br>	block. So all three blocks are linked. <br>	<br>	head		 second		 third <br>		|			 |			 | <br>		|			 |			 | <br>	+---+---+	 +---+---+	 +----+----+ <br>	| 1 | o-----&gt;| 2 | o-----&gt; | # | # | <br>	+---+---+	 +---+---+	 +----+----+	 */</span><br><br>	third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>	third-&gt;next = <span class="hljs-literal">NULL</span>; <br>	<br>	<span class="hljs-comment">//给第三个（也是最后一个）赋值，并告诉他，你后面没人了。</span><br>	<span class="hljs-comment">/* data has been assigned to data part of third <br>	block (block pointed by third). And next pointer <br>	of the third block is made NULL to indicate <br>	that the linked list is terminated here. <br><br>	We have the linked list ready. <br><br>		head	 <br>			| <br>			| <br>		+---+---+	 +---+---+	 +----+------+ <br>		| 1 | o-----&gt;| 2 | o-----&gt; | 3 | NULL | <br>		+---+---+	 +---+---+	 +----+------+</span><br></code></pre></td></tr></table></figure>
<p>​        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">	Note that only head is sufficient to represent <br>	the whole <span class="hljs-built_in">list</span>. We can traverse the complete <br>	<span class="hljs-built_in">list</span> by following next pointers. */<br>	<br>	<span class="hljs-comment">//接下来一定要试试效果么！</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">n</span> = <span class="hljs-title">head</span>;</span><br>	<span class="hljs-comment">//新建立一个指针，让他去循环着跑</span><br>	<span class="hljs-comment">//并且哈，它指向了第一个有数据的节点</span><br>	<span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <span class="hljs-comment">//输出完后，他就有指向了下一个</span><br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这就完了？这就完了。</p>
<p>下面是一个简洁的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program for traversal of a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br>  <br><span class="hljs-comment">// This function prints contents of linked list starting from </span><br><span class="hljs-comment">// the given node </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(struct Node* n)</span> <br></span>&#123; <br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <br>    &#125; <br>&#125; <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br>  <br>    <span class="hljs-comment">// allocate 3 nodes in the heap </span><br>    head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>  <br>    head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>    head-&gt;next = second; <span class="hljs-comment">// Link first node with second </span><br>  <br>    second-&gt;data = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign data to second node </span><br>    second-&gt;next = third; <br>  <br>    third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>    third-&gt;next = <span class="hljs-literal">NULL</span>; <br>  <br>    printList(head); <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，当我自己上手之后，生活还是狠狠地把我按在地上摩擦。。。</p>
<p>不妨我们模块化的写一下一个链表吧（写了很久来理解链表的优秀）</p>
<p>我先分开讲解每个模块的作用和意义，之后放在一起来观看，效果<del>（可能）</del>更佳。</p>
<p>1 必不可少的这个结构体呀！</p>
<p>你看，这个stuct Node *多长呀，如果我们使用的是typedef的话我们就可以将l作为一个数据类型的名字，然后把l当作int这样的来使用就好了（我们还是可以使用struct Node的）。</p>
<p>其次，看第二行，这个调用就很有意思了，声明了一个l数据类型的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    l* next;<span class="hljs-comment">//等效 struct Node *next</span><br>&#125;l;<br></code></pre></td></tr></table></figure>
<p>2 我们要创建一个链表了。</p>
<p>我们在main函数里面声明了一个Head的指针，并且申请了一个内存空间，并把其地址放进了head。这个时候把他传过来。</p>
<p>或者说，我们要了一个房卡，并要了一个房间，这个房卡就是head，房卡对应的就是该房间。</p>
<p>第一步：</p>
<p>在creat函数里面：我们先是malloc 了一个l类型的空间，这个房间的地址赋值给了新声明的n指针上。【或者说我们向酒店索要了一间l类型的房间（房卡当然比房间要好拿到一些呀），同时把这个房间的门牌号输入到了门卡上。】</p>
<p>第二步：我们把指针n的内容（也就是新声明的节点的地址）赋值给head指针指向的next的位置【哈哈，有点懵吧，就是说，我们现在手里一共有两张房卡对吧，一张是head（head房卡可是能打开head房间的哦），另一张是n（n可是上面有房间号码的），然后我们打开head的房间，在里面的next区域放上n房卡的内容（就是刚刚申请的房间号/地址）（用这个例子<del>可能</del>好理解哈，指针总是很奇妙的）</p>
<p>第三步：将n赋值,并指向空【然后我们利用n房卡打开刚刚申请的房间哈，然后在内容区域放上内容，在下一个的区域放上空，说明后面没有房间了】</p>
<p>这就好了。想象一下我们拿着head房卡就可以了，先是到head的next区域找到下一个房间的位置，然后进去，就能看见第一个房间的内容区域还能看到下一个房间在哪里了，当然在此处我们没有下一个房间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<span class="hljs-comment">//这里做一下判断，如果内存不足，那么报错</span><br>		head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>3那我们一定要再来一个房间呀</p>
<p>第一步：传入一个头节点，和一个值【拿上head门卡和要往新房间里放的东西】</p>
<p>第二步：声明一个新的节点p，并使其和head指向相同。【再要一张门卡，复制一下head门卡的内容】这样做可以保证head不被破环。</p>
<p>第三步：开始找最后一个房间了，如果指向的房间中的next区域还有值，就说明后面还有房间，我们就把这个门卡p指向本来房间里的下一个房间位置，就是我们将p门卡本来打开时的是这个房间，我们使他打开的是下一个房间，（当然，他无法再打开这个房间了）然后继续搜索。直到发现只是最后一个房间。</p>
<p>第四步：我们新索要一个房间，原来最后一个空房间的next区域要存放上这个房间的位置了。然后我们把我们的东西也就是一个值放在新的房间，这个新房间就成了最后一个房间了，我们就需要把他的next变为NUll空，记住哦，这些步骤一步也不能缺少，否则就会酿成大错。。。（<del>无限卡壳</del>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>		p-&gt;next =t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>4赶紧巡查一遍房间吧：</p>
<p>我们只用拿着head门卡就好，每次巡查的时候记得再要一个门卡自己的门卡保存着第一个房间的位置，可不能乱改。然后搜查完成一间房间之后，房卡n就成了下一个房间的房卡，继续搜查。哈哈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;l;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<br>	head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    l *Head;<br>    Head = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <br>    creat(Head);<br>    add(Head,<span class="hljs-number">15</span>);<br>    disp(Head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>只是写出一个链表就少了很多趣味，增改删查才是硬道理！</strong></p>
<p>当然了，在开始阶段，我们还是只以单链表为例：</p>
<h2 id="链表的增："><a href="#链表的增：" class="headerlink" title="链表的增："></a>链表的增：</h2><p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/_2020031917124912SS.png" alt="linkedList/_2020031917124912SS.png"></p>
<p><strong>一、 在链表的末尾增加：</strong>（再重复的系统的讲一下哈）</p>
<p>这个方法我们在上面已经认识到了，具体的思路就是我们通过头节点找到最后一个节点，然后在她后面添加一个节点，链接上去就可以了。（我们手持一个head房卡，沿着房间不断地走下去，找到最后的房间，在新开一间房间，然后我们在原来的最后一个房间的next的空间里放上新开房间的位置就好了）</p>
<p>这里假设我们已经有了一个链表了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<span class="hljs-comment">//设置临时的指针，用来指向不同的节点，实现在不影响head的情况下遍历等操作</span><br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>二、在链表的头部增加：</strong></p>
<p>这个的做法似乎比上一个还要简单呢，毕竟我们不用去一一寻找到最后一个了。</p>
<p>既然我们需要添加一个值，那么新建一个节点（房间）是必不可少的了。然后将值放入，让其指向本来的第一个节点，在让head指向它就好。（不怕麻烦的话，也可以重新添加一个指针变量，作为中间值，来进行操作）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    t-&gt;next = Head-&gt;next;<br>    Head -&gt;next = t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>三、在链表的中间插入：</strong></p>
<p>这个可以说是前两者的综合版本了。我们要先找到这个节点，然后对他进行插入。</p>
<p>这里就以给定一个值，作为目标值，在其后面添加一个节点吧。查找的方法是先检查一下它后面是否还有节点，如果有就判断他的值是否符合，如果不符合就使指针指向下一个节点。这样出来的结果只会有两种，一种是没有找到，也有可能是这个值就在最后一个节点里面。</p>
<p>这里做了两个版本的给定值寻找插入方法，一种是在其之前，另一种是在其后。（两者之间只需要一点点的代码改动就可以了，在不同的地方已经用//注释）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertBefore</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* pre  = Head;<span class="hljs-comment">//*</span><br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<span class="hljs-comment">//*</span><br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    pre-&gt;next = t;<span class="hljs-comment">//*</span><br>    t-&gt;next = p; <span class="hljs-comment">//*</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>     t-&gt;next = p-&gt;next;<span class="hljs-comment">//*</span><br>     p-&gt;next = t;<span class="hljs-comment">//*</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对链表的删"><a href="#对链表的删" class="headerlink" title="对链表的删"></a>对链表的删</h2><p>？？？如果前面的掌握了的话，那么对链表的某个节点进行删除自然不是问题。就直接放代码了（思路和上面的<strong>insertBefore</strong>相同哦）（<del>代码其实也是参考上面的</del>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target)</span></span>&#123;<span class="hljs-comment">//这里传入头节点和目标值就可以了</span><br>    l* pre  = Head;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>		pre-&gt;next = p-&gt;next;<span class="hljs-comment">//是的，将insertAfter代码的最后几行更改为这一行就好了。</span><br>		<span class="hljs-comment">//（相当于将这个节点跳过去了）</span><br>	  <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//既然删除了这个节点，那么就把他释放掉，节约内存。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对链表的改："><a href="#对链表的改：" class="headerlink" title="对链表的改："></a>对链表的改：</h2><p>？？？如果前面的掌握了的话，那么对链表的某个值进行更改自然不是问题。就直接放代码了（思路和上面的<strong>insertAfter</strong>相同哦）（<del>代码其实也是参考上面的</del>）<del>（人类的本质是复读机）</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    p-&gt;val = val;<span class="hljs-comment">//其实就是把insertAfter()最后的几行代码改为这个（2333）</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对链表的查："><a href="#对链表的查：" class="headerlink" title="对链表的查："></a>对链表的查：</h2><p>我们不是一直在查找么？？？（<del>避免复读，</del>就不再赘述）</p>
<p>看到这里，首先是一份敬佩，敬佩您能够静下心来一步一步的去尝试，去探索，去思考。确实文章篇幅很长，需要一定的耐心去思考，并且链表理解起来确实不是很困难，但是如果是刚开始，去上手操作，自然还是漏洞百出，bug重重。但是只要我们多尝试，多敲代码，缕清关系，明确指针自身的所在。那么，我们的各个方面都会有一定的成长。</p>
<p>谢谢阅读，本文中仍有许多的不足之处，还望交流指正。</p>
<p>对于后期，大家还可以去了解其他的链表形式，来加强对链表的使用。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>YoloV5 学习与训练</title>
    <url>/2022/02/14/YoloV5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>简要学习 YoloV5，通过在云端训练和本地推理，初步入门 ML 的图形识别场景。实现对特定物体的检测和框选。</p>
  <a id="more"></a>
<p>在进行物体识别的图形应用场景下，看到 Yolo 的普遍应用，便希望自己能够用到 [[YoloV5]] 框架，同时在整个机器学习，人工智能，学习的环境下，图像类的机器学习是最为热门和具有实用性质的内容。而区别于物体分类，物体检测相对更为复杂，但是也更具有实用性和拓展性，能够在众多的场景和众多设备下进行应用与部署。因此特地进行 Yolo 的学习，希望能够尽快掌握自定义数据集的物体检测的能力。<br>积累了关于 物体识别 的相关技术栈经验。</p>
<p>课程主要跟随 <a href="https://www.bilibili.com/video/BV1tf4y1t7ru" target="_blank" rel="noopener">Bilibili 的网课</a> 进行学习。</p>
<h2 id="安装-YoloV5-5-0-时的问题"><a href="#安装-YoloV5-5-0-时的问题" class="headerlink" title="安装 YoloV5 5.0 时的问题"></a>安装 YoloV5 5.0 时的问题</h2><p>直接下载 <a href="https://github.com/ultralytics/yolov5/tree/v5.0" target="_blank" rel="noopener">tag 5.0 版本</a> 的源代码进行学习即可。<br>如果因为网络环境打不开，可以通过 Gitee 的 <a href="https://gitee.com/monkeycc/yolov5/tree/v5.0" target="_blank" rel="noopener">5.0 链接</a> 进行下载</p>
<p>下载后，通过 Pycharm 打开（非要用其他的也 OK），继而在 Conda 或其他 Python 选择好的环境下，根据 requerments.txt 进行 pip install ~即可。</p>
<h3 id="pycocotools-安装失败"><a href="#pycocotools-安装失败" class="headerlink" title="pycocotools 安装失败"></a>pycocotools 安装失败</h3><p>而对于 特殊的 pycocotools ，很难在 windows 上进行安装，目前采用的简单的方法是：</p>
<blockquote>
<p>GitHub 上有 windows 版 pycocotools 了。<br>pip install pycocotools-windows<br>win10+anaconda 环境亲测有效</p>
</blockquote>
<p>在打开 detect.py 进行运行（相当于 Hello world ）时，可能会出现一些报错提醒你有些插件没有安装，继续 pip install 即可</p>
<p>对于 其他问题，多半通过复制最后一行代码，百度即可找到方案</p>
<h3 id="出现-Can’t-get-attribute-SPPF-on-module-models-common"><a href="#出现-Can’t-get-attribute-SPPF-on-module-models-common" class="headerlink" title="出现 Can’t get attribute SPPF on module models.common"></a>出现 Can’t get attribute SPPF on module models.common</h3><p>运行 yolov5 下面 Tags5 的代码,出现了这个报错：<br>AttributeError: Cant get attribute SPPF on module models.common from e: \pyWorkSpace\yolov5-5.0\models\common.py</p>
<p>解决方案是：去 Tags6 里面的 model/common.py 里面去找到这个 SPPF 的类,把它拷过来到你这个 Tags5 的 model/common.py 里面,这样你的代码就也有这个类了,还要引入一个 warnings 包就行了！</p>
<p>有的同学找不到 SPPF 这个类，那我现在直接粘贴在这里，你们只需要复制到你们的 common.py 里面即可，记得把 import warnings 放在上面去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> warnings<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPPF</span><span class="hljs-params">(nn.Module)</span>:</span><br>    <span class="hljs-comment"># Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, c1, c2, k=<span class="hljs-number">5</span>)</span>:</span>  <span class="hljs-comment"># equivalent to SPP(k=(5, 9, 13))</span><br>        super().__init__()<br>        c_ = c1 // <span class="hljs-number">2</span>  <span class="hljs-comment"># hidden channels</span><br>        self.cv1 = Conv(c1, c_, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        self.cv2 = Conv(c_ * <span class="hljs-number">4</span>, c2, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        self.m = nn.MaxPool2d(kernel_size=k, stride=<span class="hljs-number">1</span>, padding=k // <span class="hljs-number">2</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x)</span>:</span><br>        x = self.cv1(x)<br>        <span class="hljs-keyword">with</span> warnings.catch_warnings():<br>            warnings.simplefilter(<span class="hljs-string">'ignore'</span>)  <span class="hljs-comment"># suppress torch 1.9.0 max_pool2d() warning</span><br>            y1 = self.m(x)<br>            y2 = self.m(y1)<br>            <span class="hljs-keyword">return</span> self.cv2(torch.cat([x, y1, y2, self.m(y2)], <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>
<h2 id="在运行-detect-或-train-时，提示-缺少-pycocotools"><a href="#在运行-detect-或-train-时，提示-缺少-pycocotools" class="headerlink" title="在运行 detect 或 train 时，提示 缺少 pycocotools"></a>在运行 detect 或 train 时，提示 缺少 pycocotools</h2><p>这是因为在运行的时候，程序会去检测 requerments 是否完全达标，在 requerments 里面将 pycocotools 屏蔽 ‘#’ 即可，因为我们已经安装了 pycocotools-windows ，而其其意义不大。</p>
<h2 id="运行-YoloV5"><a href="#运行-YoloV5" class="headerlink" title="运行 YoloV5"></a>运行 YoloV5</h2><p>通过 在 Terminal 运行<br><code>python detect.py</code><br>或者 Pycharm 在 detect 文件下的运行</p>
<p>当然，我们在这个下面进行运行视频，也是可以的，但其实也是一帧一帧进行处理的。</p>
<p>之后，在 [[Colab]] 上进行 YoloV5 的学习不仅能够快速方便地配置环境，而且能够充分利用云服务器的 GPU 进行训练。<br>Colab 的服务器上 GPU，免费的一半是 K80，12G ，粗略计算 比本人笔记本的 Cpu 推理，机器学习的速度快 30 倍。<br>之后通过 Google Driver 进行保存相关的模型数据，自己是将其作为了一个大的压缩包，给放到云盘上了，方便下次直接恢复运行的环境。</p>
<p>当然之后又通过 <a href="https://aistudio.baidu.com/aistudio/projectdetail/2495241?channelType=0&amp;channel=0" target="_blank" rel="noopener">螺丝螺母</a> 分类的项目通过 Yolov5 进行了重新训练，主要耗费时间的就是 数据集格式的转换，通过自己的低水平 Python 代码和高水平的 GitHub AutoPiolt 的协作，写了好几个小时，才将其转换过来，好在跑起来之后 的效果不错，97% 的准确率。</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>atabc173c C - H and V</title>
    <url>/2020/07/23/atabc173c/</url>
    <content><![CDATA[<p>此题目主要包括了全排列，二进制的相关知识</p>
  <a id="more"></a>
<p><a href="https://atcoder.jp/contests/abc173/tasks/abc173_c" target="_blank" rel="noopener">C - H and V</a>(单击题目可进入下图链接)</p>
<p><img src="/2020/07/23/atabc173c/Screenshot_2020-07-23 C - H and V.png" alt="2020-07-23 C - H and V"></p>
<p>题意：第一次看的时候，看的有点呆。</p>
<p>给定一个矩阵，每个点都被标记为白色或者黑色，然后使你开始刷漆（红漆），一次可以涂一行或者一列，任意涂刷n次（可以是0）求有多少种方案可以使得最终黑色的砖块的数量为所给的数量。</p>
<p>当时思考：</p>
<p>opps，不会吧，难道是要暴力？这个怎么暴力？这不可能暴力吧，这么复杂呢。第一行可刷可不刷，第一列可刷可不刷。那么岂不是有很多的情况么，怎么处理呢。当场傻掉。</p>
<p>题解：</p>
<p>暴力~~~（逃不过）</p>
<p>但是采用了和二进制映射map的操作，也就是说 对于每一行我们有两个状态，涂刷或者不涂刷，那么一共有 h 行，w列。行的变化之间是互不关联的，所以说一共有 $2^h$ 种可能，同理 列也有 $2^w$ 种可能的情况，他们都是独立的，所以该涂刷方案一共有 $2^h * 2^w = 2^{(h+w)}$ 种可能的涂刷方案2333.</p>
<p>注意到数据的范围： 1≤H,W≤6 所以 如果采暴力的方法我们也不过是 $2^{12} = 4096$ 次操作，并不会从boom，是一个相对计算机而言很小的一个数据大小。</p>
<p>那么如何去储存一个 4096（最大） 种情况呢（其中每一种情况要表示：一共要涂刷的行或者列），我们采用了二进制状态映射的方法（<a href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/">回想之前全排列的二进制方法</a>） 同样这次我们对于 矩阵的行 而言，一共有h行，那么一共有 $2^h$ 种行的不同状态（即不同的涂刷方式）我们就采取二进制的方法记录，这种对于单个单位（如 此处的行）只有两种状态的数据的存储。例如：0b001 可以表示第一行第二行不刷红色，第三行刷红。</p>
<p>我们采用 0 表示不涂刷，或者表示涂刷都是可以的，无伤大雅（毕竟有一个不刷的状态就会有刷的情况与之对应，我们将全部情况都列出来了 了 了）。所以 十进制下的 $0-(h-1)$ 就可以将  $2^h$ 种状态全部表示出来了。</p>
<p>如果我们采用的是其他（比如，采用了 用一个矩阵来保存一种可能性的结果的话，那么就需要4000多个矩阵来表示，但想想一个矩阵我们采用一个二维数组emm 过于复杂咯，更何况每个矩阵依旧是需要依次遍历循环 判断黑色个数）</p>
<p>同理，我们也可以将列的表示如上方式，这样我们就实现了：<strong>采用一个十进制的数字（其实需要的是它所对应的二进制），来表示一行或者一列的涂刷情况了</strong>。</p>
<p>接着，我们就要判断出该行列状态下的黑砖的数量是不是和题目要求的一致，一致就cnt++。</p>
<h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> H, W, K;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;H, &amp;W, &amp;K);<br>	<span class="hljs-keyword">char</span> c[H][W];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; W; ++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c[i][j]);<br>	&#125;<br>	<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; H); ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; W); ++j) &#123;<br>			<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>			<span class="hljs-comment">// above is the every situation that we may face</span><br><br>			<span class="hljs-comment">// for each block c[k][l]</span><br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; H; ++k) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; W; ++l) &#123;<br>					<span class="hljs-comment">//i , j = 0b0101 </span><br>					<span class="hljs-keyword">if</span> (!(i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) &amp;&amp; !(j &amp; (<span class="hljs-number">1</span> &lt;&lt; l)) &amp;&amp; c[k][l] == <span class="hljs-string">'#'</span>) ++cnt;<span class="hljs-comment">//1 red, 0 not red</span><br>					<br>					<span class="hljs-comment">//if ((i &amp; (1 &lt;&lt; k)) &amp;&amp; (j &amp; (1 &lt;&lt; l)) &amp;&amp; c[k][l] == '#') ++cnt;//0 red, 1 not red</span><br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (cnt == K) ++ans;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ans);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>atcoder 二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P1149火柴棒等式</title>
    <url>/2020/01/29/P1149%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0−9的拼法如图所示： </p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/49.png" alt="img"> </p>
<p>注意：</p>
<ol>
<li>加号与等号各自需要两根火柴棍</li>
<li>如果A≠B，则A+B=C与B+A=C视为不同的等式(A,B,C&gt;=0)</li>
<li>n根火柴棍必须全部用上</li>
</ol>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个整数n(n&lt;=24)</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，能拼成的不同等式的数目。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">14</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #1</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>输入 #2</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #2</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【输入输出样例1解释】</p>
<p>2个等式为：</p>
<p> 0+1=10和1+0=1。 </p>
<p>【输入输出样例2解释】</p>
<p>9个等式为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0</span>+<span class="hljs-number">4</span>=<span class="hljs-number">4</span><br><span class="hljs-number">0</span>+<span class="hljs-number">11</span>=<span class="hljs-number">11</span><br><span class="hljs-number">1</span>+<span class="hljs-number">10</span>=<span class="hljs-number">11</span><br><span class="hljs-number">2</span>+<span class="hljs-number">2</span>=<span class="hljs-number">4</span><br><span class="hljs-number">2</span>+<span class="hljs-number">7</span>=<span class="hljs-number">9</span><br><span class="hljs-number">4</span>+<span class="hljs-number">0</span>=<span class="hljs-number">4</span><br><span class="hljs-number">7</span>+<span class="hljs-number">2</span>=<span class="hljs-number">9</span><br><span class="hljs-number">10</span>+<span class="hljs-number">1</span>=<span class="hljs-number">11</span><br><span class="hljs-number">11</span>+<span class="hljs-number">0</span>=<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>
<p><strong>思路</strong>：简单的参考了如下的答案并作出了一定的解释：其主要是将各个数字的所需个数计算出来，然后一一尝试是否符合即可。</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a><strong>代码如下</strong>:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">int</span> a[<span class="hljs-number">2001</span>]=&#123;<span class="hljs-number">6</span>&#125;,b,c[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>&#125;,s=<span class="hljs-number">0</span>,i,j;<br>      <span class="hljs-comment">//a[2001]表示的是每个数字(eg.“1998”)所需的火柴棒个数； </span><br>      <span class="hljs-comment">//而c是默认的0-9的所需火柴棒个数；以此为基础来计算a[2001];</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b);<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2000</span>;i++)<br>        &#123;<br>                j=i;<br>                <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">1</span>)<span class="hljs-comment">//求每个数所用的火柴棒</span><br>                &#123;<br>                    a[i]+=c[j%<span class="hljs-number">10</span>];<br>                    j/=<span class="hljs-number">10</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1000</span>;i++)<br>        &#123;<br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1000</span>;j++)<br>                <span class="hljs-keyword">if</span>(a[i]+a[j]+a[i+j]+<span class="hljs-number">4</span>==b)s++;<span class="hljs-comment">//还有加号与等号（4）;  </span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,s);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu1237计算器</title>
    <url>/2020/06/07/hdu1237%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1237" target="_blank" rel="noopener">简单计算器</a></h1>  <a id="more"></a>
<p>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 36334  Accepted Submission(s): 13065</p>
<p>Problem Description</p>
<p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。</p>
<p>Input</p>
<p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p>
<p>Output</p>
<p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span>+ <span class="hljs-number">2</span> * <span class="hljs-number">5</span> - <span class="hljs-number">7</span> / <span class="hljs-number">11</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3.00</span><br><span class="hljs-number">13.36</span><br></code></pre></td></tr></table></figure>
<p>Source</p>
<p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%D5%E3%B4%F3%BC%C6%CB%E3%BB%FA%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C9%CF%BB%FA%BF%BC%CA%D4-2006%C4%EA&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 浙大计算机研究生复试上机考试-2006年 </a> </p>
<p>解题思路：</p>
<p>主要是采取了两个栈来保存操作符和运算数字。</p>
<p>另外：亮点在于P(c) &lt; P(op.top())这里的优先级比较：</p>
<p>我们可以发现通过表格或者其他的形式可以看出在运算优先级的问题上，我们只有采取这样的策略才是最好的。</p>
<p>当前的优先级高那么压入栈，当前优先级和栈顶（上次的）的优先级相同，或小于上次的话，自然时先算上次的，同时这样的模拟也是最符合我们自己的真实的运算过程的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Ans</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) <span class="hljs-keyword">return</span> x + y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> x - y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'*'</span>)<span class="hljs-keyword">return</span> x*y;<br>    <span class="hljs-keyword">return</span> x / y;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))<br>    &#123;<br>        <span class="hljs-keyword">char</span> c = getchar();<br>        <span class="hljs-keyword">if</span> (c==<span class="hljs-string">'\n'</span>&amp;&amp;n == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; op;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">double</span>&gt;num;<br>        num.push(n);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<span class="hljs-comment">//开始一行的运算，之前已经获取了一个n，并压入num；</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c %d"</span>, &amp;c, &amp;n);<br>            <span class="hljs-keyword">char</span> k = getchar();<br>            <span class="hljs-keyword">while</span> (!op.empty()&amp;&amp;P(c)&lt;=P(op.top()))<span class="hljs-comment">//第一次会跳过</span><br>            <span class="hljs-comment">//当操作符的栈不为空……且现在的操作符优先级小于或等于栈顶的的操作符的优先级时</span><br>            <span class="hljs-comment">//那么先将之前的进行计算</span><br>            &#123;<br>                <span class="hljs-keyword">char</span> t = op.top();<br>                op.pop();<br>                <span class="hljs-keyword">double</span> y = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> x = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>                num.push(ans);<br>            &#125;<br>            op.push(c);<br>            num.push(n);<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//这导致了上面还有压入的数字和操作符未被操作，便有了下面的判断op栈</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (!op.empty())<br>        &#123;<br>            <span class="hljs-keyword">char</span> t = op.top();<br>            op.pop();<br>            <span class="hljs-keyword">double</span> y = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> x = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>            num.push(ans);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>, num.top());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>hdu 栈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu1240Asteroids</title>
    <url>/2020/07/18/hdu1240Asteroids/</url>
    <content><![CDATA[<p>Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。</p>
  <a id="more"></a>
<p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 7201  Accepted Submission(s): 4454<br>**</strong></p>
<p>Problem Description</p>
<p>You’re in space.<br>You want to get home.<br>There are asteroids.<br>You don’t want to hit them.</p>
<p>Input</p>
<p>Input to this problem will consist of a (non-empty) series of up to 100 data  sets. Each data set will be formatted according to the following  description, and there will be no blank lines separating data sets.</p>
<p>A single data set has 5 components:</p>
<p>Start line - A single line, “START N”, where 1 &lt;= N &lt;= 10.</p>
<p>Slice list - A series of N slices. Each slice is an N x N matrix representing a horizontal slice through the asteroid field. Each position in the  matrix will be one of two values:</p>
<p>‘O’ - (the letter “oh”) Empty space</p>
<p>‘X’ - (upper-case) Asteroid present</p>
<p>Starting Position - A single line, “A B C”, denoting the <A,B,C>  coordinates of your craft’s starting position. The coordinate values  will be integers separated by individual spaces.</A,B,C></p>
<p>Target Position - A single line, “D E F”, denoting the <D,E,F> coordinates of your  target’s position. The coordinate values will be integers separated by  individual spaces.</D,E,F></p>
<p>End line - A single line, “END”</p>
<p>The  origin of the coordinate system is <0,0,0>. Therefore, each  component of each coordinate vector will be an integer between 0 and  N-1, inclusive.</0,0,0></p>
<p>The first coordinate in a set indicates the column. Left column = 0.</p>
<p>The second coordinate in a set indicates the row. Top row = 0.</p>
<p>The third coordinate in a set indicates the slice. First slice = 0.</p>
<p>Both the Starting Position and the Target Position will be in empty space.</p>
<p>Output</p>
<p>For each data set, there will be exactly one output set, and there will be no blank lines separating output sets.</p>
<p>A single output set consists of a single line. If a route exists, the  line will be in the format “X Y”, where X is the same as N from the  corresponding input data set and Y is the least number of moves  necessary to get your ship from the starting position to the target  position. If there is no route from the starting position to the target  position, the line will be “NO ROUTE” instead.</p>
<p>A move can only be in one of the six basic directions: up, down, left, right, forward,  back. Phrased more precisely, a move will either increment or decrement a single component of your current position vector by 1.</p>
<p>Sample Input</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">START <span class="hljs-number">1</span><br>O<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br>END<br>START <span class="hljs-number">3</span><br>XXX<br>XXX<br>XXX<br>OOO<br>OOO<br>OOO<br>XXX<br>XXX<br>XXX<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>END<br>START <span class="hljs-number">5</span><br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>END<br></code></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-literal">NO</span> <span class="hljs-string">ROUTE</span><br></code></pre></td></tr></table></figure>
<p>Source</p>
<p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=South+Central+USA+2001&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> South Central USA 2001 </a> </p>
<p>poj2225 亦为此题</p>
<h2 id="题意及要求"><a href="#题意及要求" class="headerlink" title="题意及要求"></a>题意及要求</h2><p>先来说说真实的题意吧：</p>
<p>题目给出一个三维的图，使得从一个三维的点，从起点到终点最短距离以及能否走到。多次输出题目。</p>
<p>看似是一道很简单的[[bfs]]题目，其实他就是一道很简单的bfs题目。</p>
<p>不信你看，本题目其中的bfs的内容就是这样正常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>          <span class="hljs-comment">//  cout&lt;&lt;"x,y,z is  "&lt;&lt;next.x&lt;&lt;" "&lt;&lt;next.y&lt;&lt;" "&lt;&lt;next.z&lt;&lt;"  val is "&lt;&lt;val[next.x][next.y][next.z]&lt;&lt;" CHECK is "&lt;&lt;CHECK(next.x,next.y,next.z)&lt;&lt;endl;</span><br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>
<p><strong>但是</strong></p>
<p>问题来了，这道题还是对我造成了很大的困扰的，因为在数据的输入和存储这一块吃了大亏。</p>
<p>第一次看完题目，感觉像是给出是一个坐标点，然后所给的数据分成了多层，层与层是可以互通的，就想着把他当作二维的来做。写的时候还感到奇怪，为什么有六种动作呢，不就是只有四种（前后左右）么？还沾沾自喜，感觉自己找到了捷径。。。。。。</p>
<p>后来吧，总是wa，看了别人的讨论才发现原来题看错了，理解错误（英语还需增强啊，<del>太尬了</del>~~~）</p>
<p>这个时候的心情再回首回去当时，就感觉当时的自己仿佛是低维空间的生物在理解着三维世界的神奇（并且是失败的那种），科幻的感觉啊啊。</p>
<p>接着在写正确的三维的版本的时候，仍是接连不断的错误喷涌而来，通过长久的层层的debug（数小时）发现是在输入和储存方面出现了错误，题目给定的是一个接着一个二维图数据，所以需要自己去转化，但是，当时自己只想到了第一层，把高度使用行号/n来判断，他的高度，但是忘记给行号更改了，导致自己出现了错误，许多点没有标记上。（属于坐标错误吧，矩阵储存失败。。。）</p>
<p>导致了本应很顺利的题目，搞了很久，另外，题目给定的顺序是 列 行，而不是行列，所有还需要自己翻一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(x,y,z) (x&gt;=0&amp;&amp;x<span class="hljs-meta-string">&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;z&gt;=0&amp;&amp;z&lt;n&amp;&amp;!(vis[x][y][z])&amp;&amp;val[x][y][z])</span></span><br><span class="hljs-comment">//val bug</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,z,cnt;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> move[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;<br>&#125;;<br>    <span class="hljs-keyword">bool</span> vis[n][n][n];  <br>    <span class="hljs-keyword">bool</span> val[n][n][n];<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    CLR(val,<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">int</span> A,B,C,D,E,F;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n*n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'O'</span>)val[i%n][j][i/n]=<span class="hljs-number">1</span>;<br>        &#125;<br>        getchar();<br>    &#125;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d %d %d %d\n"</span>, &amp;B,&amp;A,&amp;C,&amp;E,&amp;D,&amp;F);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"END\n"</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>    node t;<br>    t.x = A;t.y= B;t.z =C;t.cnt=<span class="hljs-number">0</span>;<br>    q.push(t);<br>    vis[A][B][C]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"START %d\n"</span>,&amp;n))&#123;<br>        bfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>javaconstructors构造函数</title>
    <url>/2020/02/11/javaconstructors%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>Constructors are used to assign values to the class variables at the time of object creation, either explicitly done by the programmer or by Java itself (default constructor).</p>
</blockquote>
<p>在创建对象时，可以使用构造函数将值分配给类变量，这些值可以由程序员显式完成，也可以由Java本身（默认构造函数）完成。</p>
<p><a href="https://www.geeksforgeeks.org/constructors-in-java/" target="_blank" rel="noopener">Constructors in Java - GeeksforGeeks</a></p>
<p><strong>Rules for writing Constructor:</strong></p>
<ul>
<li><p>Constructor(s) of a class must has same name as the class name in which it resides.</p>
<p>构造函数的名字和类名必须一致。</p>
</li>
<li><p>A constructor in Java can not be abstract, final, static and Synchronized.</p>
<p>java中的构造函数不能是抽象的，最终的，静态的和同步的。</p>
</li>
<li><p>Access modifiers can be used in constructor declaration to control its access i.e which other class can call the constructor.</p>
<p>可以在构造函数声明中使用访问修饰符来控制其访问，即哪个其他类可以调用构造函数。</p>
</li>
</ul>
<h3 id="构造函数的类型："><a href="#构造函数的类型：" class="headerlink" title="构造函数的类型："></a>构造函数的类型：</h3><ol>
<li><p><strong>无参构造函数</strong>：</p>
<p>没有参数的构造函数被认为时默认构造函数。若我们没有在类中定义构造函数，那么编译器会自己定义一个无参数的构造函数。Default constructor provides the default values to the object like 0, null, etc. depending on the type.（默认的构造函数提供默认的值给对象0，null，等，更具他们的类型不同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java Program to illustrate calling a // no-argument constructor import [java.io](http://java.io).*;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Geek</span> </span>&#123; <span class="hljs-keyword">int</span> num; String name;<br><br> <span class="hljs-comment">// this would be invoked while an object </span><br> <span class="hljs-comment">// of that class is created. </span><br> Geek() <br> &#123; <br> 	System.out.println(<span class="hljs-string">"Constructor called"</span>); <br> &#125; <br><br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GFG</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// this would invoke default constructor. Geek geek1 = new Geek();</span><br><br> 	<span class="hljs-comment">// Default constructor provides the default </span><br> 	<span class="hljs-comment">// values to the object like 0, null </span><br> 	System.out.println(geek1.name); <br> 	System.out.println(geek1.num); <br> &#125; <br><br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>0utput :</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">called</span><br><span class="hljs-title">null</span><br>0</span><br></code></pre></td></tr></table></figure>
<p><strong>2. 有参构造函数：</strong></p>
<p>If we want to initialize fields of the class with your own values, then use a parameterized constructor.如果我们想使用我们自己的值去给类中的变量赋值的话，那么使用参数化的构造函数（有参构造函数）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java Program to illustrate calling of </span><br><span class="hljs-comment">// parameterized constructor. </span><br><span class="hljs-keyword">import</span> java.io.*; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Geek</span> <br></span>&#123; <br>	<span class="hljs-comment">// data members of the class. </span><br>	String name; <br>	<span class="hljs-keyword">int</span> id; <br><br>	<span class="hljs-comment">// constructor would initialize data members </span><br>	<span class="hljs-comment">// with the values of passed arguments while </span><br>	<span class="hljs-comment">// object of that class created. </span><br>	Geek(String name, <span class="hljs-keyword">int</span> id) <br>	&#123; <br>		<span class="hljs-keyword">this</span>.name = name; <br>		<span class="hljs-keyword">this</span>.id = id; <br>	&#125; <br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GFG</span> <br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123; <br>		<span class="hljs-comment">// this would invoke the parameterized constructor. </span><br>		Geek geek1 = <span class="hljs-keyword">new</span> Geek(<span class="hljs-string">"adam"</span>, <span class="hljs-number">1</span>); <br>		System.out.println(<span class="hljs-string">"GeekName :"</span> + geek1.name + <br>						<span class="hljs-string">" and GeekId :"</span> + geek1.id); <br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">GeekName</span> <span class="hljs-selector-pseudo">:adam</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">GeekId</span> <span class="hljs-selector-pseudo">:1</span><br></code></pre></td></tr></table></figure>
<p>也就是说<strong>每一个类里面都有一个构造函数用来给变量赋值</strong>。如果你自己不去写这个构造函数，那么编译器会写一个。这样就可以给你创建的所有变量默认赋值了。（如果构造函数有参数那么，就是你给定的值；如果没有参数，那么就是0或者时null)。对了，构造函数中也可以写其他的语句，可以夹带私货。</p>
<h2 id="使用构造参数时的一些其他问题："><a href="#使用构造参数时的一些其他问题：" class="headerlink" title="使用构造参数时的一些其他问题："></a>使用构造参数时的一些其他问题：</h2><ul>
<li><p><strong>Does constructor return any value?</strong> （有返回值么？没有，但可以写return）</p>
<p>There are no “return value” statements in constructor, but constructor returns current class instance. We can write ‘return’ inside a constructor.</p>
</li>
<li><p><strong>Constructor Overloading.</strong>（我们同样将其视作函数【本来就是】，当然也可以像函数一样，通过参数的类型，数目和顺序的不同来区分不同的同名构造函数）</p>
<p>Like methods, we can overload constructors for creating objects in different ways. Compiler differentiates constructors on the basis of numbers of parameters, types of the parameters and order of the parameters.</p>
</li>
</ul>
<blockquote>
<p><strong>How constructors are different from methods in Java?构造函数和函数的区别</strong></p>
</blockquote>
<ul>
<li>Constructor(s) must have the same name as the class within which it defined while it is not necessary for the method in java.构造函数的名字只能和类名相同，而且也不是必要的。</li>
<li>Constructor(s) do not return any type while method(s) have the return type or <strong>void</strong> if does not return any value.构造函数没有返回值</li>
<li>Constructor is called only once at the time of Object creation while method(s) can be called any numbers of time.构造函数只有在对象被创建的时候调用一次，而函数可以无限次被调用。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>java中各种类的跳转例题分析</title>
    <url>/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在学习java的继承的过程中遇到这样的一个分析类题目，比较有意思，在这里做出简要分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请写出以下程序运行结果：</span><br><br><span class="hljs-keyword">package</span> test;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.show(<span class="hljs-keyword">new</span> Car()&#123;<br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">"test run"</span>);           <br>         &#125;<br>      &#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Car c)</span></span>&#123;<br>      c.run();<br>      c.show();<br>&#125;&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">"car run"</span>);     <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(getClass().getName());<br>&#125;&#125;<br></code></pre></td></tr></table></figure>
<p> 那么，我们可以通过断点的分析：</p>
<ol>
<li><p>首先。我们从main函数进入，发现他创建了Test类的一个对象t；</p>
<p>我们在test类中并没有寻找到Test类的构造函数，所以应该是系统默认的构造器，不进行任何的行为；</p>
</li>
<li><p>之后，我们注意一下这一步，首先是t.show（）方法，在Test的类中有这么一个方法，不过我们看到show方法是需要传入一个car类的对象，所以他new了一个car对象，离奇的是car对象后面接着一对大括号。</p>
</li>
<li><p>注意到：这里有一个匿名类，用来一次性使用的创建car对象。这样抽象类car才能被以匿名类中的内容实例化。这样，我们就完成了对car类的实例化，得到了一个car类的对象。</p>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401173415543.png" alt="image-20200401173415543"></p>
</li>
<li><p>接着，我们以那个新new的对象作为参数，调用了Test类中的show方法。</p>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174104233.png" alt="image-20200401174104233"></p>
<p>而show方法的第一条语句是c.show();注意到我们是通过匿名类创建的对象，而我们是通过匿名类中的重新写的run（）方法，所以他又跳回了第六行，输出“test run”；</p>
</li>
</ol>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174405627.png" alt="image-20200401174405627"></p>
<ol>
<li><p>好的，接下来我们又回到了show方法中，继续调用c.show(),这时，我们回头看匿名类，它里面竟然没有show的方法。。。所以他就只能调用car类的show（）方法。</p>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174506855.png" alt="image-20200401174506855"></p>
</li>
</ol>
<ol>
<li><p>注意到了右侧返回的getName()是”test.Test$1”，好吧，test是包名，Test是类名，可以理解！</p>
<p>但是$1就使得不少同学迷惑了。</p>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174856777.png" alt="image-20200401174856777"> </p>
</li>
<li><p>好的，我们这次打开文件管理系统，找到我们编译的文件所在，发现.java编译后多出了Test$1.class的文件，这个.class是怎么来的呢？对了是匿名类！这里的Test$1这个类名是编译器给它的名字（匿名类没有名字，但是java编译器要给他起个名，才好分辨）而命名的格式就是第一个Test类下面的匿名类的话就叫$1,第二个就是$2。</p>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401175322331.png" alt="image-20200401175322331"></p>
</li>
</ol>
<p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401180024806.png" alt="image-20200401175322331"></p>
<p>这样就可以了，程序就结束了！主要涉及了匿名成员类。大家有兴趣（最好可以了解一下）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>java中对象的创建，初始化与引用</title>
    <url>/2020/03/11/java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在java的学习过程中，对于对象/基本数据类型是如何创建于初始化和引用的，在这一过程中发生了什么，为什么？下面就是有一定的讲解：</p>
<h2 id="java对象与引用："><a href="#java对象与引用：" class="headerlink" title="java对象与引用："></a>java对象与引用：</h2><p>A a1 = new A();</p>
<p>它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。</p>
<p><strong>在声明时：=符号并不表示赋值，而是引用，是一个传递地址的过程。</strong></p>
<p>再如：</p>
<p>A a2;</p>
<p>它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null;</p>
<p>再如：</p>
<p>a2 = a1;</p>
<p>它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址），使得a2和a1指向了同一对象。</p>
<p>综上所述，可以简单的记为，在初始化时，“=”语句左边的是引用，右边new出来的是对象。</p>
<p>在后面的左右都是引用的“=”语句时，左右的引用同时指向了右边引用所指向的对象。</p>
<h2 id="JAVA中对象创建和初始化过程"><a href="#JAVA中对象创建和初始化过程" class="headerlink" title="JAVA中对象创建和初始化过程"></a>JAVA中对象创建和初始化过程</h2><p>分析一下JAVA中对象创建和初始化过程中涉及的相关概念问题，java中<strong>栈</strong>(stack)与<strong>堆</strong>(heap)，<strong>对象</strong>、<strong>引用</strong>、<strong>句柄</strong>的概念。</p>
<h3 id="1-Java中的数据类型"><a href="#1-Java中的数据类型" class="headerlink" title="1.Java中的数据类型"></a>1.Java中的数据类型</h3><p>Java中有3个数据类型：<strong>基本数据类型</strong>(在Java中，boolean、byte、short、int、long、char、float、double这八种是基本数据类型)、<strong>引用类型</strong>和<strong>null类型</strong>。其中，<strong>引用类型包括类类型(含数组)、接口类型。（和struck有点类似哈）</strong></p>
<p>下列语句声明了一些变量：</p>
<p>int k ;</p>
<p>A a; //a是A数据类型的对象变量名（仅作声明）。</p>
<p>B b1,b2,…,b10000;// 假定B是抽象类或接口。</p>
<p>String s;</p>
<p>注意：从数据类型与变量的角度看，基本数据类型变量k、类类型变量a和s、抽象类或接口类型变量b(1万个)，它们都是变量(标识符)。</p>
<h2 id="2-关于句柄-handle"><a href="#2-关于句柄-handle" class="headerlink" title="2.关于句柄(handle)"></a>2.关于句柄(handle)</h2><p>为了区别<strong>引用类型</strong>的变量标识符和<strong>基本数据类型</strong>变量标识符，我们特别的<strong>使用Handle来称呼引用类型的变量标识符</strong>。上面例子中b1至b10000、a、s都是Handle。Handle直观的看就是手柄、把手，我们采用计算机界常用的中文翻译“句柄”。</p>
<h3 id="2-1【Windows编程中的】句柄的含义"><a href="#2-1【Windows编程中的】句柄的含义" class="headerlink" title="2.1【Windows编程中的】句柄的含义"></a>2.1【Windows编程中的】句柄的含义</h3><p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。</p>
<p>从上面的定义中的我们可以看到，句柄是一个标识符，是拿来标识对象或者项目的，它就象我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个16位的无符号整数。应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</p>
<p>如果想更透彻一点地认识句柄，我可以告诉大家，<strong>句柄是一种指向指针的指针。我们知道，所谓指针是一种内存地址</strong>。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢?</p>
<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>
<p><strong>句柄地址(稳定)→记载着对象在内存中的地址────→对象在内存中的地址(不稳定)→实际对象</strong></p>
<h3 id="2-2Java中句柄的意义"><a href="#2-2Java中句柄的意义" class="headerlink" title="2.2Java中句柄的意义"></a>2.2Java中句柄的意义</h3><p>对句柄以前的【Windows编程中的】含义有了深刻的认识，我们可以说Handle是一个我们学习Java时非常需要的术语。它的意义在于区别“对象本身”和对象变量(或者严格点：对象所属的数据类型的变量标识符)。</p>
<h3 id="2-3回到1中的变量声明："><a href="#2-3回到1中的变量声明：" class="headerlink" title="2.3回到1中的变量声明："></a>2.3回到1中的变量声明：</h3><p>现在，你应该对下面的注释一目了然。</p>
<p>int k, j ;//k里面存放的是一个整型数。</p>
<p>A a; //a里面存放地址。</p>
<p>B b1,b2,…,b10000;// b1，…，b10000里面存放地址。</p>
<p>String s; //s里面存放地址。</p>
<h2 id="3-关于引用-reference"><a href="#3-关于引用-reference" class="headerlink" title="3.关于引用(reference)"></a>3.关于引用(reference)</h2><p>什么是“引用”? “the identifier you manipulate is actually a ‘reference’ to an object”。(Thinking in Java 2e )</p>
<p>翻译是：你操纵的标识符实际上是一个对象的“引用”。或者精确些，翻译成：你操作的标识符实际上是指向一个对象的“引用”。显然，原文中reference是一个有方向感的东西。（说为“指向”也是蛮好）</p>
<p>回到Java中来，引用可以想象成对象的身份证号码、对象的ID或者对象的手机号码。当然，更多的说法是，引用是对象在内存中住的房间号码。直观的说，对象的引用是创建对象时的返回值!引用是new表达式的返回值。</p>
<p>new A(); 这里真正创建了一个对象，但我们没有用句柄去持有(hold、拿着、保存)该引用。从微观上看，new表达式完成了对象初始化的任务(三步曲，下文详细分析)，整体上看则返回一个引用。</p>
<p>再次回到1中的变量声明，再看看下面的注释。</p>
<p>A a; //声明句柄a，但未初始化，所以里面的值为null。</p>
<p>B b1,b2,…,b10000;// 声明句柄b1，…，b10000，但未初始化，所以里面的值为null。</p>
<p>String s; //声明句柄s，但未初始化，所以里面的值为null。</p>
<h2 id="4-句柄与引用的关系"><a href="#4-句柄与引用的关系" class="headerlink" title="4.句柄与引用的关系"></a>4.句柄与引用的关系</h2><p>A a;//声明句柄a，值为null</p>
<p>a=new A();//句柄的初始化(句柄 = 引用;即把引用赋值给句柄)</p>
<p>引用：new A()的值。引用可以简单的看作对象占据内存空间的地址;通过对象的引用，就可以方便的与其他对象区别开来，引用就是对象独特的身份标识。</p>
<p>完成句柄的初始化后，就可以用句柄遥控对象了。</p>
<p>当然，这只是从一方面解释对象的创建和初始化，理解了句柄和引用的关系后，下面分析对象初始化的整个过程。先做以下准备工作，说说栈与堆。</p>
<h2 id="5-java中栈-stack-与堆-heap"><a href="#5-java中栈-stack-与堆-heap" class="headerlink" title="5.java中栈(stack)与堆(heap)"></a>5.java中栈(stack)与堆(heap)</h2><p>在java中内存分为“栈”和“堆”这两种(Stack and Heap).基本数据类型存储在“栈”中，对象引用类型实际存储在“堆”中，在栈中只是保留了引用内存的地址值。</p>
<p>顺便说说“==”与“equals()方法”，以帮助理解两者(Stack and Heap)的概念。</p>
<p>在Java中利用”==”比较变量时候，系统使用变量在stack(栈)中所存的值来作为对比的依据，基本数据类型在stack中所存的值就是其?容值，而引用类型在stack中所存放的值是本身所指向Heap中对象的地址值。<strong>Java.lang包中的Object类有public boolean equals (Object obj)方法。它比较两个对象是否相等。仅当被比较的两个引用指向同一对象时(句柄相等)，对象的equals()方法返回true（是对象的比较哦)</strong>。(至于String类的equals()方法，它重写(override)equals()方法，不在本文讨论之列。)</p>
<h2 id="6-对象的创建和初始化过程"><a href="#6-对象的创建和初始化过程" class="headerlink" title="6.对象的创建和初始化过程"></a>6.对象的创建和初始化过程</h2><p>在java中对象就是类的实例。在一般情况下，当把一个类实例化时，此类的所有成员，包括变量和方法，都被复制到属于此数据类型的一个新的实例中去。分析以下两段代码。</p>
<h3 id="6-1-Vehicle-veh1-new-Vehicle"><a href="#6-1-Vehicle-veh1-new-Vehicle" class="headerlink" title="6.1 Vehicle veh1 = new Vehicle();"></a>6.1 Vehicle veh1 = new Vehicle();</h3><p>上面的语句做了如下的事情：</p>
<p>①右边的“new Vehicle”，是以Vehicle类为模板，在堆空间里创建一个Vehicle类对象(也简称为Vehicle对象)。</p>
<p>②末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果没创建，Java会补上一个默认的构造函数。(一般根据类型为null，0）</p>
<p>③左边的“Vehicle veh1”创建了一个Vehicle类引用变量。</p>
<p>④“=”操作符使对象引用指向刚创建的那个Vehicle对象。(回想一下句柄与引用)</p>
<p>将上面的语句分为两个步骤：</p>
<p>Vehicle veh1;</p>
<p>veh1 = new Vehicle();</p>
<p>这样写，就比较清楚了，有两个实体：</p>
<p>一是对象引用变量，一是对象本身。</p>
<p>在堆空间里创建的实体，与在栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是似乎很难准确的“抓”住它。我们仔细研究一下第二句，找找刚创建的对象叫什么名字?有人说，它叫“Vehicle”。不对，“Vehicle”是类(对象的创建模板)的名字。一个Vehicle类可以据此创建出无数个对象，这些对象不可能全叫“Vehicle”。对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。</p>
<h3 id="6-2-Vehicle-veh2"><a href="#6-2-Vehicle-veh2" class="headerlink" title="6.2 Vehicle veh2;"></a>6.2 Vehicle veh2;</h3><p>veh2 = veh1;</p>
<p>由于veh1和veh2只是对对象的引用，第二行所做的不过是把veh1的引用(地址)赋值给veh2，使得veh1和veh2同时指向唯一的一个Vehicle对象。</p>
<h3 id="6-3-veh2-new-Vehicle"><a href="#6-3-veh2-new-Vehicle" class="headerlink" title="6.3 veh2 = new Vehicle();"></a>6.3 veh2 = new Vehicle();</h3><p>则引用变量veh2改指向第二个对象。</p>
<p>从以上叙述再推演下去，我们可以获得以下结论：①一个对象引用可以指向0个（null）或1个对象;②一个对象可以有N个引用指向它。</p>
<p><a href="http://blog.sina.com.cn/s/blog_7ed8eb7d0101k057.html" target="_blank" rel="noopener">原文链接，稍作修改</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java主类，类与源文件名的简要分析</title>
    <url>/2020/02/19/java%E4%B8%BB%E7%B1%BB%EF%BC%8C%E7%B1%BB%E4%B8%8Epublic%E7%9A%84%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>有时候，我们会遇到关于主类，类和public修饰的类的辨析。刚开始，很难辨别。那么，接下来，简要地分析一下其区别：</p>
<p><strong>1.如果文件中只有一个类，文件名必须与类名一致，有没有public修饰都可以；</strong></p>
<p><strong>2.一个Java文件中最多只能有一个public类；</strong></p>
<p><strong>3.如果文件中不止一个类，而且有public类，文件名必须与public类名一致；</strong></p>
<p><strong>4.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。</strong>(相同的是主类)</p>
<p>首先：</p>
<p> <strong>类是Java程序的最小程序单位</strong> 。</p>
<ul>
<li>Java程序是一种纯粹的<strong>面向对象</strong>的程序设计语言，因此Java程序必须以<strong>类的形式</strong>存在，类是Java程序的<strong>最小程序单位</strong>。</li>
<li>Java程序不允许可执行性语句、方法等成分独立存在，<strong>所有的程序部分都必须放在类定义里</strong>。<del>（不能像c，c++一样瞎写了）</del></li>
</ul>
<h2 id="主类："><a href="#主类：" class="headerlink" title="主类："></a>主类：</h2><h5 id="什么是主类？"><a href="#什么是主类？" class="headerlink" title="什么是主类？"></a>什么是主类？</h5><p>一说，类名与文件名相同，且含有main的类。</p>
<p>一说： 是带有（总程序的）<strong>执行入口</strong>main方法的类。 （虚拟机第一个进入的类）</p>
<p>那么：我们不妨思考一下：</p>
<p>Q: 一个类是不是可以有多个main方法呢？</p>
<p>A: 由于java语言的多态性，我们完全可以在一个类中含有多个main方法，但记住，main是入口，而这些main方法中只有一个才会是入口。</p>
<blockquote>
<p>main 方法写法固定：必须被 public static void 修饰，且其形参必须是字符串数组类型（String[] args）。<br>对于一个大型 Java 程序，往往只需要一个入口（即只一个类包含 main 方法），其他类用于被 main 方法直接或间接调用。</p>
</blockquote>
<h3 id="Java-源文件的命名规则"><a href="#Java-源文件的命名规则" class="headerlink" title="Java 源文件的命名规则"></a><strong>Java 源文件的命名规则</strong></h3><blockquote>
<ul>
<li>通常情况下，Java 程序源文件的主文件名可以任意。</li>
<li>但如果其中定义了一个 public 类，则该源<strong>文件的主文件名必须与该 public 类的类名相同</strong>。</li>
<li>一个Java 源文件可包含多个类定义，但最多<strong>只能包含一个public类定义</strong>。</li>
</ul>
</blockquote>
<p><strong>为什么只能包含一个public类？</strong></p>
<blockquote>
<p> 因为 public 类可以被项目中其他包下的类访问到。只需要在使用前 import  其对应的 class 文件。将类名与文件名一一对应就可以<strong>方便虚拟机在相应的路径（包名）中找到相应的类的信息</strong>。如果不这么做的话，就很难去找，而且开销也会很大。 </p>
</blockquote>
<p><del>1、Java编译器在编译的时候，如果整个Java文件（编译单元）都没有public类（对外的公开接口类），类加载器就无需直接去加载该编译单元产生的所有的字节码文件（.class文件），那么也就是无需去寻找编译后字节码文件存放位置。而类名和文件名一致是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。所以在没有public类的Java文件中，文件名和类名都没什么联系。</del></p>
<p>2、如果编译单元中包含了public类，那么该类对应的字节码文件需要被类加载器加载的，这时候就需要让类加载器知道该字节码文件的位置，所以就要确保该类与Java文件名称一致。同时，如果有两个public类在同一个文件中，而一个文件只能有一个名称，<strong>故两个public类的名称就不能同时和文件名一样，这就造成至少其中有一个public类在编译的时候编译不通过。</strong></p>
<p>关于Java源文件命名，通常有以下建议：</p>
<pre><code>一个 Java 源文件只定义一个类，不同的类使用不同的源文件定义。
让 Java 源文件的主文件名与该源文件中定义的 pulblic 类同名。
</code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>java字符串string</title>
    <url>/2020/02/17/java%E5%AD%97%E7%AC%A6%E4%B8%B2string/</url>
    <content><![CDATA[<h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><p>首先：初始化样例 ：String str = “Geeks”;</p>
<p><strong>Creating a String</strong></p>
<p>There are two ways to create string in Java:（两种方式）</p>
<ul>
<li><p><strong><em>String literal\</em></strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">String s</span> = “GeeksforGeeks”;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Using *new* keyword</strong></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span> (“GeeksforGeeks”);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字符串背后的一些事情："><a href="#字符串背后的一些事情：" class="headerlink" title="字符串背后的一些事情："></a>字符串背后的一些事情：</h2><p>String 字符串是由字符数组（char array)所支持。</p>
<p>Strings in Java are Objects that are backed internally by a char array.</p>
<p>而我们知道，字符数组的大小是固定的，所以：当String发生大小变化时就会产生一个新的String。</p>
<p>那么他是怎样变化的呢？</p>
<p>Whenever a String Object is created, two objects will be created- one in the Heap Area and one in the String constant pool and the String object reference always points to heap area object.</p>
<p>当一个字符串产生的时候，就会创建两个String对象，一个在堆区域，另一个在字符串常态池中<strong>，而且字符串引用总指向堆区域的对象。</strong></p>
<p>例如：（看是该字符串引用总是指向堆区域的对象，而且是首字母，像指针一样，不过java避开了指针的概念。）</p>
<p><img src="/2020/02/17/java%E5%AD%97%E7%AC%A6%E4%B8%B2string/Untitled.png" alt></p>
<h2 id="接口和类在字符串中："><a href="#接口和类在字符串中：" class="headerlink" title="接口和类在字符串中："></a>接口和类在字符串中：</h2><ul>
<li><p><a href="https://www.geeksforgeeks.org/tag/java-charbuffer/" target="_blank" rel="noopener">CharBuffer</a>: This class implements the CharSequence interface. This class is used to allow character buffers to be used in place of CharSequences. An example of such usage is the regular-expression package java.util.regex.</p>
<p>不懂CharBuffer：此类实现CharSequence接口。 此类用于允许使用字符缓冲区代替CharSequences。 正则表达式包java.util.regex是这种用法的一个示例。</p>
</li>
<li><p><a href="https://www.geeksforgeeks.org/string-class-in-java/" target="_blank" rel="noopener">String</a>: String is a sequence of characters. In java, objects of String are immutable which means a constant and cannot be changed once created.（String的对象是不可改变的）</p>
</li>
<li><p><a href="http://www.geeksforgeeks.org/stringbuffer-class-in-java/" target="_blank" rel="noopener">StringBuffer</a>: <strong>StringBuffer</strong> is a peer class of <strong>String</strong> that provides much of the functionality of strings. String represents fixed-length, immutable character sequences while StringBuffer represents growable and writable character sequences.（又出来个String buffer，批判了String的固定长度和不可变后，称自己是可增长的，可变化的。它还是String的同级字符串类。。。）</p>
<p><strong>Syntax:</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">StringBuffer</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">"GeeksforGeeks"</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.geeksforgeeks.org/stringbuilder-class-in-java-with-examples/" target="_blank" rel="noopener">StringBuilder</a>: The <strong>StringBuilder</strong> in Java represents a mutable sequence of characters. Since the String Class in Java creates and immutable sequence of characters, the StringBuilder class provides an alternate to String Class, as it creates a mutable sequence of characters.（又来一个StringBuilder 说自己也是可变的字符串</p>
<p><strong>Syntax:</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">StringBuilder <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-built_in">str</span>.<span class="hljs-built_in">append</span>(<span class="hljs-string">"GFG"</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.geeksforgeeks.org/stringtokenizer-class-java-example-set-1-constructors/" target="_blank" rel="noopener">StringTokenizer</a>: StringTokenizer class in Java is used to break a string into tokens. <strong>Example:</strong></p>
<p><img src="/2020/02/17/java%E5%AD%97%E7%AC%A6%E4%B8%B2string/Untitled1.png" alt></p>
<p>A StringTokenizer object internally maintains a current position within the string to be tokenized. Some operations advance this current position past the characters processed. A token is returned by taking a substring of the string that was used to create the StringTokenizer object.(用于处理过的字符串，不太懂）</p>
</li>
<li><p><a href="https://www.geeksforgeeks.org/java-util-stringjoiner-java8/" target="_blank" rel="noopener">StringJoiner</a>: StringJoiner is a class in <em><a href="https://www.geeksforgeeks.org/tag/java-util-package/" target="_blank" rel="noopener">java.util</a></em> package which is used to construct a sequence of characters(strings) separated by a delimiter and optionally starting with a supplied prefix and ending with a supplied suffix. Though this can also be with the help of StringBuilder class to append delimiter after each string, StringJoiner provides an easy way to do that without much code to write.（也是处理分隔符的，和上面的是一对儿）</p>
<p><strong>Syntax:</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">public</span> <span class="hljs-function"><span class="hljs-title">StringJoiner</span>(<span class="hljs-variable">CharSequence</span> <span class="hljs-variable">delimiter</span>)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="more："><a href="#more：" class="headerlink" title="more："></a>more：</h2><p>此外，在我们要去取值的时候，比如String第二个字符的值的时候，应该用:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">String str</span> = <span class="hljs-string">"hello word"</span>;<br><span class="hljs-attribute">char mychar</span> =  str.charAt(1);<br></code></pre></td></tr></table></figure>
<p>如果想要比较字符串的值是否相同的话：</p>
<p>if（s.contentEquals(“-1”)）来比较。否则就是比较储存位置（因为String在java中是对象，不是基本类型）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>java方法methods</title>
    <url>/2020/02/17/java%E6%96%B9%E6%B3%95methods/</url>
    <content><![CDATA[<p>java中还是称之为“方法”好了。</p>
  <a id="more"></a>
<p>In general, method declarations has six components :</p>
<p>包括这六部分：</p>
<ul>
<li><strong>Modifier</strong>-（标识符）: Defines <strong>access type</strong> of the method i.e. from where it can be accessed in your application. In Java, there 4 type of the access specifiers.<ul>
<li>public: accessible in all class in your application.</li>
<li>protected: accessible within the class in which it is defined and in its <strong>subclass(es)</strong></li>
<li>private: accessible only within the class in which it is defined.</li>
<li>default (declared/defined without using any modifier) : accessible<br>within same class and package within which its class is defined.</li>
</ul>
</li>
<li><strong>The return type</strong>（返回值） : The data type of the value returned by the method or void if does not return a value.</li>
<li><strong>Method Name</strong> （方法名）: the rules for field names apply to method names as well, but the convention is a little different.</li>
<li><strong>Parameter list</strong>  （参数列表）: Comma separated list of the input parameters are defined, preceded with their data type, within the<br>enclosed parenthesis. If there are no parameters, you must use empty<br>parentheses ().</li>
<li><strong>Exception list</strong>  （异常列表）: The exceptions you expect by the method can throw, you can specify these exception(s).可以列出方法可能的异常会被引发，在此列表中可以指定这些异常。</li>
<li><strong>Method body</strong>  : it is enclosed between braces. The code you need to be executed to perform your intended operations.</li>
</ul>
<p><img src="/2020/02/17/java%E6%96%B9%E6%B3%95methods/Untitled.png" alt="Untitled"></p>
<p><strong>How to name a Method?</strong></p>
<p> A method name is typically a single word that should be a <strong>verb</strong>in lowercase or multi-word, that begins with a <strong>verb</strong> in lowercase followed by <strong>adjective, noun…..</strong> After the first word, first letter of each word should be capitalized. For example, findSum, computeMax, setX and get.</p>
<p>方法的命名通常为动词（小写）后可跟一个名词（后面的单词首字母大写）。computeMax。</p>
<pre><code>//自己写的
import java.util.Scanner;
class Addition{
    int sum;
    public int addTwoInt(int a,int b) {
        sum = a + b;
        return sum;
    }
}

public class Main {
    public  static void main(String args[]){
        Addition add = new Addition();
        int s = add.addTwoInt(1,2);
        System.out.print(s);
    }

}

// 标准版本
//Program to illustrate methodsin java 
import java.io.*; 

class Addition { 

    int sum = 0; 

    public int addTwoInt(int a, int b){ 

        // adding two integer value. 
        sum = a + b; 

        //returning summation of two values. 
        return sum; 
    } 

} 

class GFG { 
    public static void main (String[] args) { 

        // creating an instance of Addition class 
        Addition add = new Addition(); 

        // calling addTwoInt() method to add two integer using instance created 
        // in above step. 
        int s = add.addTwoInt(1,2); 
        System.out.println(&quot;Sum of two integer values :&quot;+ s); 

    } 
}
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>methods</tag>
      </tags>
  </entry>
  <entry>
    <title>java日期处理</title>
    <url>/2020/03/01/java%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p> Java处理日期、日历和时间的方式一直被人所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。</p>
<p>新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。</p>
<p>(因为更安全，不可变了，所以就需要每一个日期搞一个变量（实例？）</p>
<p><a href="https://mp.weixin.qq.com/s/AGkp_0l_hvMye8QVOBlxwQ" target="_blank" rel="noopener">18 个 Java8 日期处理的实践，太有用了！</a></p>
<p>Instant    时间戳<br>Duration    持续时间，时间差<br>LocalDate    只包含日期，比如：2018-02-05<br>LocalTime    只包含时间，比如：23:12:10<br>LocalDateTime    包含日期和时间，比如：2018-02-05 23:14:21<br>Period    时间段<br>ZoneOffset    时区偏移量，比如：+8:00<br>ZonedDateTime    带时区的时间<br>Clock    时钟，比如获取目前美国纽约的时间<br>java.time.format.DateTimeFormatter    时间格式化</p>
<h2 id="示例1-Java-8中获取今天的日期"><a href="#示例1-Java-8中获取今天的日期" class="headerlink" title="示例1:Java 8中获取今天的日期"></a>示例1:Java 8中获取今天的日期</h2><p>Java 8 中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123; <br>        LocalDate today = LocalDate.now();<br>        System.out.println(<span class="hljs-string">"today is:"</span>+today);<br>  <br>    &#125;<br>&#125;<br><span class="hljs-comment">//output:</span><br><span class="hljs-comment">//today is:2020-02-29</span><br></code></pre></td></tr></table></figure>
<p>而如果需要将年月日信息分开：那么我们可以利用上面的today继续操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123; <br>        LocalDate today = LocalDate.now();<br>        System.out.println(<span class="hljs-string">"today is:"</span>+today);<br>        <span class="hljs-keyword">int</span> year = today.getYear();<br>        <span class="hljs-keyword">int</span> month = today.getMonthValue();<br>        <span class="hljs-keyword">int</span> day = today.getDayOfMonth();<br>        System.out.println(<span class="hljs-string">""</span>+year+month+day);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：其中还有getMonth()，返回的是一个枚举month里的值（是“FEBRUARY”这种）</p>
<p>而getMonthValue（）则返回一个值（2）所以我们还能发现许多这样的用法，比如day_of_year()等</p>
<h2 id="示例2：自定义日期："><a href="#示例2：自定义日期：" class="headerlink" title="示例2：自定义日期："></a>示例2：自定义日期：</h2><p>我们通过静态工厂方法now()非常容易地创建了当天的日期，我们还可以调用另一个有用的工厂方法<strong>LocalDate.of()</strong>创建任意日期， 该方法需要<strong>传入年、月、日做参数，返回对应的LocalDate实例。</strong>这个方法的好处是没再犯老API的设计错误（而且我们也可以使用localDate的方法了），比如年度起始于1900，月份是从0开 始等等（这些问题就不提了哎，文末可能会吐槽一下，并演示一下有多么讨厌）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123; <br>        LocalDate fakeDate = LocalDate.of(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">28</span>);<br>        System.out.println(<span class="hljs-string">"yesterday is:"</span>+fakeDate);<br>        <br>   &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//yesterday is:2020-02-28</span><br></code></pre></td></tr></table></figure>
<h2 id="示例三：判断两个日期是否相同使用-equals"><a href="#示例三：判断两个日期是否相同使用-equals" class="headerlink" title="示例三：判断两个日期是否相同使用.equals()"></a>示例三：判断两个日期是否相同使用.equals()</h2><h2 id="示例四：检查像生日这种周期性事件：MonthDay："><a href="#示例四：检查像生日这种周期性事件：MonthDay：" class="headerlink" title="示例四：检查像生日这种周期性事件：MonthDay："></a>示例四：检查像生日这种周期性事件：MonthDay：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;   LocalDate date1 = LocalDate.now();<br>        LocalDate date = LocalDate.of(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">28</span>);<br>        MonthDay birthday = MonthDay.of(date.getMonthValue(),date.getDayOfMonth());<br>        MonthDay nowMonthDay = MonthDay.now();<br>        <span class="hljs-keyword">if</span>(nowMonthDay.equals(birthday))<br>        System.out.println(<span class="hljs-string">"yes"</span>);<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">"nonono"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//nonono</span><br></code></pre></td></tr></table></figure>
<p>注意在这里getMonthValue（）和getMonth（）都是可以使用的。</p>
<h1 id="说完日期，说说时间："><a href="#说完日期，说说时间：" class="headerlink" title="说完日期，说说时间："></a>说完日期，说说时间：</h1><h2 id="示例五：获取当前时间"><a href="#示例五：获取当前时间" class="headerlink" title="示例五：获取当前时间"></a>示例五：获取当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        LocalTime now = LocalTime.now();<br>        System.out.println(now);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-number">19</span>:<span class="hljs-number">27</span>:<span class="hljs-number">01.708</span><br></code></pre></td></tr></table></figure>
<p>这个时间的精度。。可以了</p>
<h2 id="示例六：计算一段时间前-后的时间-plus-val-ChronoUnit-WEEKS"><a href="#示例六：计算一段时间前-后的时间-plus-val-ChronoUnit-WEEKS" class="headerlink" title="示例六：计算一段时间前/后的时间.plus(val,ChronoUnit.WEEKS)"></a>示例六：计算一段时间前/后的时间.plus(val,ChronoUnit.WEEKS)</h2><p>/.minus(val,ChronoUnit.WEEKS))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.temporal.ChronoUnit;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        LocalDate now = LocalDate.now();<br>        LocalDate after = now.plus(<span class="hljs-number">1</span>,ChronoUnit.WEEKS);<br><br>        System.out.println(after);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里是日期，那么就要用localDate了</p>
<h2 id="示例七-Java-8的Clock时钟类"><a href="#示例七-Java-8的Clock时钟类" class="headerlink" title="示例七:Java 8的Clock时钟类"></a>示例七:Java 8的Clock时钟类</h2><p>Java 8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis()和TimeZone.getDefault()的地方都可用Clock替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        Clock clock = Clock.systemUTC();<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + clock.instant());<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + clock.millis());<br>        <span class="hljs-comment">// Returns time based on system clock zone</span><br>        Clock defaultClock = Clock.systemDefaultZone();<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + defaultClock.millis());<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//Clock : 2020-03-01T03:06:27.520Z</span><br><span class="hljs-comment">//Clock : 1583031987647</span><br><span class="hljs-comment">//Clock : 1583031987687</span><br></code></pre></td></tr></table></figure>
<h2 id="示例八-如何用Java判断日期是早于还是晚于另一个日期"><a href="#示例八-如何用Java判断日期是早于还是晚于另一个日期" class="headerlink" title="示例八:如何用Java判断日期是早于还是晚于另一个日期"></a>示例八:如何用Java判断日期是早于还是晚于另一个日期</h2><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java 8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。调用isBefore()方法时，如果给定日期小于当前日期则返回true。当然也可判断是否日期相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        LocalDate today = LocalDate.now();<br>        LocalDate fakeDate = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(fakeDate.isBefore(today))<br>        &#123;<br>            System.out.print(<span class="hljs-string">"yes"</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">"nono"</span>);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//yes</span><br></code></pre></td></tr></table></figure>
<h2 id="示例九-Java-8中处理时区"><a href="#示例九-Java-8中处理时区" class="headerlink" title="示例九:Java 8中处理时区"></a>示例九:Java 8中处理时区</h2><p>Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java 8以前都是 GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p>
<p><strong>其他：同样也可以检查闰年，独立的年月计算两个日期之间天数（between）</strong></p>
<h2 id="示例十：Java-8中如何使用预定义的格式化工具去解析或格式化日期"><a href="#示例十：Java-8中如何使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="示例十：Java 8中如何使用预定义的格式化工具去解析或格式化日期"></a>示例十：Java 8中如何使用预定义的格式化工具去解析或格式化日期</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        String dayAfterTommorrow = <span class="hljs-string">"20200302"</span>;<br>        LocalDate formatted = LocalDate.parse(dayAfterTommorrow,DateTimeFormatter.BASIC_ISO_DATE);<br>        System.out.println(dayAfterTommorrow+<span class="hljs-string">"  格式化后的日期为:  "</span>+formatted);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//20200302  格式化后的日期为:  2020-03-02</span><br></code></pre></td></tr></table></figure>
<h2 id="示例十一：字符串互转日期类型"><a href="#示例十一：字符串互转日期类型" class="headerlink" title="示例十一：字符串互转日期类型"></a>示例十一：字符串互转日期类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        LocalDateTime date = LocalDateTime.now();<br><br>        DateTimeFormatter format1 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy/MM/dd hh:mm:ss"</span>);<br>    <span class="hljs-comment">//日期转字符串</span><br>        String str = date.format(format1);<br><br>        System.out.println(<span class="hljs-string">"日期转换为字符串:"</span>+str);<br><br>        DateTimeFormatter format2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy/MM/dd HH:mm:ss"</span>);<br>    <span class="hljs-comment">//字符串转日期</span><br>        LocalDate date2 = LocalDate.parse(str,format2);<br>        System.out.println(<span class="hljs-string">"日期类型:"</span>+date2);<br><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//日期转换为字符串:2020/03/01 11:44:03</span><br><span class="hljs-comment">//日期类型:2020-03-01</span><br></code></pre></td></tr></table></figure>
<p>如果我们将str的内容更换一下，只要format的内容一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        String str = <span class="hljs-string">"20190112120101"</span>;<br><br>        DateTimeFormatter format2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyyMMddHHmmss"</span>);<br>    <span class="hljs-comment">//字符串转日期</span><br>        LocalDate date2 = LocalDate.parse(str,format2);<br>        System.out.println(<span class="hljs-string">"日期类型:"</span>+date2);<br><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//日期类型:2019-01-12</span><br></code></pre></td></tr></table></figure>
<p>在这其中我们还是有很多可以去挖掘的。。。</p>
<p>对了，最后吐槽一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br>	</span>&#123;<br>        <br>        <span class="hljs-keyword">long</span> t = System.currentTimeMillis();<br><br>        System.out.println(t);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这玩意返回的必须是long类型但是把现在也用不到。返回的时间是距离1970年一月一日零点零分的毫秒数。。 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象特性的阐述</title>
    <url>/2020/02/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E7%9A%84%E9%98%90%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>Object-oriented programming: As the name suggests, Object-Oriented Programming or OOPs refers to languages that uses objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism etc in programming. <strong>The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.（OOP的主要目的是将数据和对其进行操作的功能绑定在一起，以便除该功能外，代码的其他任何部分都无法访问此数据。）</strong></p>
</blockquote>
<p><a href="https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/" target="_blank" rel="noopener">Object Oriented Programming (OOPs) Concept in Java - GeeksforGeeks</a></p>
<ol>
<li>在这其中，指出oops（面向对象的编程）主要目的是将<strong>数据和函数</strong>结合在一起，bind说明两者是绑定。</li>
<li>当然inheritance, hiding, polymorphism etc（继承，隐藏，多态等）等内容。。。</li>
</ol>
<p>下面学习一波面向对象的语言的特性：</p>
<h2 id="面对对象的三大特征："><a href="#面对对象的三大特征：" class="headerlink" title="面对对象的三大特征："></a><strong>面对对象的三大特征：</strong></h2><h3 id="1-polymorphism多态："><a href="#1-polymorphism多态：" class="headerlink" title="1. polymorphism多态："></a>1. polymorphism多态：</h3><p><a href="https://www.geeksforgeeks.org/polymorphism-in-java/" target="_blank" rel="noopener">Polymorphism in Java - GeeksforGeeks</a></p>
<p>. In other words, polymorphism allows you to define one interface and have multiple implementations</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/overloading-in-java/" target="_blank" rel="noopener">Overloading in Java</a></li>
</ul>
<p>即一个函数名字有着许多不同的含义（根据传入值类型，数量的不同而改变），以实现更多。</p>
<p><strong>也就是说可以创建多个同名的函数</strong></p>
<p>在现实生活中：我们对于一个名字会有许多的不同的理解，这取决于环境的不同。同样的在面向对象的特性（多态）吧，便实现了这一真实世界中的现象，赋值给了编程。</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/overriding-in-java/" target="_blank" rel="noopener">Overriding in Java</a></li>
</ul>
<p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<h3 id="2-Inheritance-继承"><a href="#2-Inheritance-继承" class="headerlink" title="2. Inheritance:继承"></a>2. Inheritance:继承</h3><p>继承就是一个函数可以使用其他函数的内容（field和methods即函数和变量）。</p>
<p>分为三类：</p>
<ul>
<li><strong>Super Class:</strong> The class whose features are inherited is known as superclass(or a base class or a parent class).超类：被其他类继承</li>
<li><strong>Sub Class:</strong> The class that inherits the other class is known as subclass(or a derived class, extended class, or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.子类：继承其他类</li>
<li><strong>Reusability:</strong> Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.体现了其可以重复利用代码，不必多次重复去编写重复的内容。</li>
</ul>
<p>关键词是 <strong>extends</strong></p>
<h3 id="3-Encapsulation-封装"><a href="#3-Encapsulation-封装" class="headerlink" title="3. Encapsulation:封装"></a>3. Encapsulation:封装</h3><p>封装：就是将该类所操作的数据和类，封装在一起。这是一种保护机制，可以使得其他的代码无法获取到被封装起数据，以此保护了数据。</p>
<h3 id="除了三大基本特征以外：其实共七大（有重复）特征"><a href="#除了三大基本特征以外：其实共七大（有重复）特征" class="headerlink" title="除了三大基本特征以外：其实共七大（有重复）特征"></a>除了三大基本特征以外：其实共七大（有重复）特征</h3><ul>
<li><a href="https://www.geeksforgeeks.org/polymorphism-in-java/" target="_blank" rel="noopener">Polymorphism</a> 多态</li>
<li><a href="https://www.geeksforgeeks.org/inheritance-in-java/" target="_blank" rel="noopener">Inheritance</a> 继承</li>
<li><a href="https://www.geeksforgeeks.org/encapsulation-in-java/" target="_blank" rel="noopener">Encapsulation</a> 封装</li>
<li><a href="https://www.geeksforgeeks.org/abstraction-in-java-2/" target="_blank" rel="noopener">Abstraction</a> 抽象：</li>
</ul>
<p>将数据简化，只提供需要的数据给用户</p>
<p>抽象是通过接口和抽象类来实现的。我们可以使用接口实现100%的抽象。</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/classes-objects-java/" target="_blank" rel="noopener">Class</a> 类（类是用户定义的蓝图或原型，从中可以创建对象）</li>
<li><a href="https://www.geeksforgeeks.org/classes-objects-java/" target="_blank" rel="noopener">Object</a>  对象：<strong>State ，Behavior， Identity</strong></li>
<li><a href="https://www.geeksforgeeks.org/methods-in-java/" target="_blank" rel="noopener">Method</a> ：函数如下图（但在java中，只能存在于类下面，不可以独立像c，cpp，python一样出现）</li>
</ul>
<p><img src="/2020/02/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E7%9A%84%E9%98%90%E8%BF%B0/1.png" alt="1"></p>
<ul>
<li><a href="https://www.geeksforgeeks.org/message-passing-in-java/" target="_blank" rel="noopener">Message Passing</a> 信息传递。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面向对象的编程</tag>
      </tags>
  </entry>
  <entry>
    <title>mmWave环境配置与硬件搭配</title>
    <url>/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/</url>
    <content><![CDATA[<p>本文主要介绍了 joybien 公司的b201 VSD毫米波雷达和树莓派配合中，出现的一些安装问题以及如何安装：<br>  <a id="more"></a></p>
<p>官方文档 Github 地址：</p>
<p><a href="https://github.com/bigheadG/mmWave/tree/master/VSD" target="_blank" rel="noopener">mmWave/VSD at master · bigheadG/mmWave</a></p>
<p>在购买后，应收到如下图所示的组件：</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled.png" alt="Untitled"></p>
<p>左侧是毫米波雷达收发信号采集元器件，也是核心部件；</p>
<p>中间是转接板，负责数据处理与转发。包括蓝牙和 Wifi 模块</p>
<p>右边是固定转接板的螺丝等可以将其更稳定的放置。</p>
<h3 id="组装硬件"><a href="#组装硬件" class="headerlink" title="组装硬件"></a>组装硬件</h3><p>将转接板插入树莓派，将其覆盖在树莓派上面（不要让他出去了）</p>
<p>然后将排针插进去，这个理论上不会插反，因为有防呆设计。其中收发模块对准USB供电处。</p>
<p>注意：</p>
<p>其中有一个排针并不是断在里面了，而是防呆措施，这样是我们不会插反。</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 1.png" alt="[Untitled]"></p>
<p>将他们拼装好了之后，我们一般选择的是串口，树莓派的模式，一般如下图（J9中的左两个是原始数据的输出，右侧两个是关键数据输出）。</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 2.png" alt="[Untitled]"></p>
<p>该硬件的供电通过树莓派的USB口就可以供电。</p>
<h2 id="配置树莓派软件环境"><a href="#配置树莓派软件环境" class="headerlink" title="配置树莓派软件环境"></a>配置树莓派软件环境</h2><p>为了使用USB转TTL 由于采用的是树莓派4B，而其支持的是树莓派2/3 ，所以我们需要进行一些设置上的更改。</p>
<ol>
<li>修改  /boot/config.txt</li>
</ol>
<p>在最下方新增以下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">dtoverlay=pi3-miniuart-bt<br>core-freq=<span class="hljs-number">250</span><br>enable_uart=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 3.png" alt="[Untitled]"></p>
<ol>
<li><p>更改  \boot\cmdline.txt </p>
<p> 将 quiet splash 删掉，有的里面没有quiet，就不用删了。</p>
<p> <img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 4.png" alt="[Untitled]"></p>
<p> <img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 5.png" alt="[Untitled]"></p>
<p> 上图这个就不用删了。</p>
</li>
</ol>
<h3 id="打开树莓派-UART串口功能"><a href="#打开树莓派-UART串口功能" class="headerlink" title="打开树莓派 UART串口功能"></a>打开树莓派 UART串口功能</h3><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 6.png" alt="[Untitled]"></p>
<p>同时，需要到 raspi-config 去开启：</p>
<p>在Interface → Serial → 先no → 然后yes</p>
<p>否则就会出现毫米波雷达调整到Raw模式后，使得树莓派断网。</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 7.png" alt="[Untitled]"></p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 8.png" alt="[Untitled]"></p>
<h2 id="运行官方样例来测试能否正常运行"><a href="#运行官方样例来测试能否正常运行" class="headerlink" title="运行官方样例来测试能否正常运行"></a>运行官方样例来测试能否正常运行</h2><p>建议使用 Python3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">#安装使用此命令<br>sudo pip3 install mmWave<br><br>#升级使用下面的命令<br>sudo pip3 install mmWave -U<br></code></pre></td></tr></table></figure>
<p>通过 git 或者手动下载下面的官方库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">git clone https:<span class="hljs-comment">//github.com/bigheadG/mmWave.git</span><br></code></pre></td></tr></table></figure>
<p><a href="https://github.com/bigheadG/mmWave" target="_blank" rel="noopener">GitHub - bigheadG/mmWave: mmWave SDK examples based on Batman Kit mmWave Sensor module</a></p>
<p>接着到下图的地方打开样例，后缀 KV 的是Key Value 模式</p>
<p>运行的时候会出现port没有定义，我们树莓派的话，就是用ttyAMA0串口即可，样例中一般都有注释。</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 9.png" alt="[Untitled]"></p>
<p>当然，由于缺乏 Python3 的一些包，会出现一些问题，会一一进行安装。</p>
<p>比如运行 pyqtgraph_vsd_ex3.py 是出现了没有相关组件。</p>
<p>就需要我们去安装了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">pip3 install pyqtgraph==<span class="hljs-number">0.11</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 10.png" alt="[Untitled]"></p>
<p>当然安装完成之后，还会出现pyqt5缺失的问题。</p>
<p>pyqt5的安装需要比较特殊：</p>
<p>安装过程中出现 continue？等的提示输入 y 或者 yes 即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">sudo apt-<span class="hljs-built_in">get</span> install python3-pyqt5<br></code></pre></td></tr></table></figure>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 11.png" alt="[Untitled]"></p>
<p>当然，还有问题出现：</p>
<p>(1)———-libf77blas.so.3————————————————————-<br>  from scipy.linalg import _fblas<br>  ImportError: libf77blas.so.3: cannot open shared object file: No such file or directory</p>
<p>  problem solved这样解决就可以了:<br>  First of all, for libf77blas.so.3, you have to install ATLAS, something like sudo apt-get install libatlas-base-dev</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><code class="hljs cs">sudo apt-<span class="hljs-keyword">get</span> install libatlas-<span class="hljs-keyword">base</span>-dev<br></code></pre></td></tr></table></figure>
<p>当然，还有模块没有安装完成。</p>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 12.png" alt="[Untitled]"></p>
<p>可能出现的问题：</p>
<ul>
<li><p>插上并启动毫米波雷达板子之后出现树莓派断网</p>
<p>  解决方案：跳帽没有配置好</p>
</li>
<li><p>出现 Permission Denied ‘/dev/ttyAMA0’</p>
</li>
</ul>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 13.png" alt="[Untitled]"></p>
<pre><code>  解决方法：赋予其权限。即可
</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">sudo chmod <span class="hljs-number">666</span> /dev/ttyAMA0<br></code></pre></td></tr></table></figure>
<ul>
<li>port 有问题就进去 更改port就好。</li>
</ul>
<p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 14.png" alt="[Untitled]"></p>
<ul>
<li>如果直接安装 pyqtgraph 可能会出现qt版本号不对的情况。重新安装 pyqtgraph 的0.11.1版本。</li>
</ul>
<p>当然，比如运行 pyqtgraph_vsd_ex3.py 时，我们要首先将key模式转换为raw模式，也就是将转换板上的跳帽，调整至左侧，并通过重启毫米波雷达来 进行有效切换（可以按毫米波雷达上的Reset键，也可以拔掉转接板电源，再通电）</p>
<p>参考：</p>
<p><a href="https://www.slideshare.net/raspberrypi-tw/mmwave-sensor-evaluation-solution-kit" target="_blank" rel="noopener">mmWave Sensor Evaluation Solution Kit 簡介</a></p>
<p><a href="https://github.com/bigheadG/mmWave" target="_blank" rel="noopener">GitHub - bigheadG/mmWave: mmWave SDK examples based on Batman Kit mmWave Sensor module</a></p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>mmwave</tag>
      </tags>
  </entry>
  <entry>
    <title>new_EE</title>
    <url>/2021/06/03/new-EE/</url>
    <content><![CDATA[<h2 id="新坑IOT方向"><a href="#新坑IOT方向" class="headerlink" title="新坑IOT方向"></a>新坑IOT方向</h2><p>陆陆续续的进行了一些相关方向的内容，今后会多分享一些项目的总结和技术分享。</p>
<p>加油！</p>
<p>!&lt;—more—&gt;</p>
]]></content>
      <categories>
        <category>EE</category>
      </categories>
  </entry>
  <entry>
    <title>p1086花生采摘</title>
    <url>/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。</p>
<p>鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图111）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”</p>
<p><img src="/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/1182.png" alt></p>
<p>我们假定多多在每个单位时间内，可以做下列四件事情中的一件：</p>
<ol>
<li>从路边跳到最靠近路边（即第一行）的某棵花生植株；</li>
<li>从一棵植株跳到前后左右与之相邻的另一棵植株</li>
<li>采摘一棵植株下的花生：</li>
<li>从最靠近路边（即第一行）的某棵花生植株跳回路边</li>
</ol>
<p>现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。</p>
<p>例如在图2所示的花生田里，只有位于(2,5),(3,7),(4,2),(5,4)的植株下长有花生，个数分别为13,7,15,9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括三个整数，M,N和K，用空格隔开；表示花生田的大小为MN（1≤M,N≤20），多多采花生的限定时间为K（0≤K≤1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i+1行的第j个整数Pij（0≤Pij≤500）表示花生田里植株（i,j）下花生的数目，0表示该植株下没有花生。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即在限定时间内，多多最多可以采到花生的个数。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong> </p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #1</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">37</span><br></code></pre></td></tr></table></figure>
<p><strong>输入 #2</strong> </p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #2</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>刚开始急匆匆地一看题目（然后就陷入了一阵思考：“如何在有限的时间内拿到最多的花生呢？”哎，每个花生的个数还不一样，也就是先后顺序什么的都要去更改哎，动态规划？<del>（可是其实我不会动态规划哈哈）</del>那么怎么办呢，哎呦，然后发现了一个问题，这是一道普及题目那么不会那么难的吧？！</p>
<p>又重新审题后，发现我原来看错题目了！在那段极长的唠叨中，<strong>它规定的摘取顺序是按照从大到小的顺序区去采摘，</strong>而不是向我之前所想的那样，这样一来就大大简化了自己的步骤。</p>
<p>之后一开始打算使用一个二维数组来储存但是发现不太对，想起来结构体于是；</p>
<p>有了思路，使用一个结构体来储存自己的x，y，和花生的个数；然后排序，从大到小但是要记住判断下一次是不是采摘完还能回去哈哈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hua</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> num;<br>&#125;h;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(h a,h b)</span></span>&#123;    <br>        <span class="hljs-keyword">return</span>  a.num &gt; b.num; <br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m,n,k,cnt=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>,real=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;k;<br>    h a[m*n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        a[cnt].x = i;<br>        a[cnt].y = j;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[cnt++].num; <br>		<span class="hljs-keyword">if</span>(a[cnt<span class="hljs-number">-1</span>].num!=<span class="hljs-number">0</span>)real++;  <br>        &#125;  <br>    &#125;<br>    sort(a,a+m*n,cmp);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    k--;<span class="hljs-comment">//跳入</span><br>    <span class="hljs-keyword">int</span> least = a[i].x*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cost = a[i].x+<span class="hljs-number">1</span>;<br>   	<span class="hljs-comment">// cout&lt;&lt;real&lt;&lt;endl;</span><br>    <span class="hljs-comment">//cout&lt;&lt;"应该是：3，1"&lt;&lt;a[0].x&lt;&lt;"  "&lt;&lt;a[0].y&lt;&lt;endl;</span><br>    <span class="hljs-keyword">while</span>(k&gt;=least&amp;&amp;(i&lt;=real))&#123;<span class="hljs-comment">//省去了讨论最后一步跳出</span><br>        k-=cost;<span class="hljs-comment">//到达a[i]点所需要的步数，并加上挖出所需要的一步</span><br>       <span class="hljs-comment">// cout&lt;&lt;"least:"&lt;&lt;least&lt;&lt;"  cost:"&lt;&lt;cost;</span><br>       <span class="hljs-comment">// cout&lt;&lt;"   k:"&lt;&lt;k&lt;&lt;endl;</span><br>        ans+=a[i].num;<br>        least = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+a[i+<span class="hljs-number">1</span>].x+<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//假设能拿到下一个,且挖掘，并保证能够返回到第一行。</span><br>        cost = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+<span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好的，这个故事告诉我们。。。审视好题目。。。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>poj3414Pots</title>
    <url>/2020/07/16/poj3414Pots/</url>
    <content><![CDATA[<p>这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。</p>
<p>此题目：细心，冷静，多思考。</p>
<p>当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。</p>
  <a id="more"></a>
<hr>
<h4 id="Pots"><a href="#Pots" class="headerlink" title="Pots"></a>Pots</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 31113</td>
<td></td>
<td><strong>Accepted:</strong> 12915</td>
<td></td>
<td>Special Judge</td>
</tr>
</tbody>
</table>
</div>
<p>Description</p>
<p>You are given two pots, having the volume of <strong>A</strong> and <strong>B</strong> liters respectively. The following operations can be performed:</p>
<ol>
<li>FILL(i)    fill the pot <strong>i</strong> (1 ≤ <strong>i</strong> ≤ 2) from the tap;</li>
<li>DROP(i)   empty the pot <strong>i</strong> to the drain;</li>
<li>POUR(i,j)  pour from pot <strong>i</strong> to pot <strong>j</strong>; after this operation either the pot <strong>j</strong> is full (and there may be some water left in the pot <strong>i</strong>), or the pot <strong>i</strong> is empty (and all its contents have been moved to the pot <strong>j</strong>).</li>
</ol>
<p>Write a program to find the shortest possible sequence of these operations that will yield exactly <strong>C</strong> liters of water in one of the pots.</p>
<p>Input</p>
<p>On the first and only line are the numbers <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).</p>
<p>Output</p>
<p>The first line of the output must contain the length of the sequence of operations <strong>K</strong>. The following <strong>K</strong> lines must each describe one operation. If there are several sequences  of minimal length, output any one of them. If the desired result can’t  be achieved, the first and only line of the file must contain the word ‘<strong>impossible</strong>’.</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2002" target="_blank" rel="noopener">Northeastern Europe 2002</a>, Western Subregion</p>
<hr>
<p>题目的中文大约是：给定两个容积为a，b的水壶，初始状态为空；再给一个水量c。每次操作可以如下进行：</p>
<ol>
<li>将壶1或者壶2填满；</li>
<li>将壶1或者壶2全部倒掉；</li>
<li>将一个壶中的水导入另一个壶中（能倒入多少就倒入多少，当然其中一个壶不能是空的，另一个不能是满的）</li>
</ol>
<p>输入abc，需要你输出当其中一个水壶的水量达到c时所用的次数与倾倒步骤打印出来；当然如果永远达不到c的话，输出impossible即可。</p>
<p>tips：多组输入，c符合规范。</p>
<p>emm，不妨以此题目为例，梳理一下[[bfs]]的做法好了。</p>
<p>首先我们要判断这道题目是[[bfs]]，从题目中可以清楚看出，求最短路径，每次的操作是固定的那么基本上就可以用bfs去解决。先看一般，再看特殊的地方需要什么东西来解决（比如题目所求的cnt，步骤）</p>
<ol>
<li><p><strong>确定一个状态包括了什么</strong>：比如，有的题目仅仅需要该点的位置，有的题目还需要其他的东西；只能具体问题具体分析了。在此题目中，我们可以看到一个状态就是我们的a，b两个水壶的储水量。</p>
<p>那么我们将其设定为一个struct node即可包括 两个int 代表两个水壶的储水量。</p>
<p>特别是考虑到本题目需要cnt和倒水的步骤，那么我们在每个状态里的的步骤都是不一样的，就用string 储存吧，然后每一个步骤添加的时候记得加上换行符号”\n”;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>寻找vis范围</strong>，确定了总的范围我们才可以利用vis来判断我们是否踩过这个点，这也是最有效的方法来避免死循环,也是迫使队列结束的好方法。有题目给出的“These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).”所以我们知道a有100种可能，b也是。（小提示，如果你发现有题目似乎用不到vis那么大概也许<strong>可能</strong>他不一定需要使用bfs来解题）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br></code></pre></td></tr></table></figure>
<p>对了，记住此题目是多行输入，意味着如果你的vis不及时初始化就会fc</p>
<p>在这里初始化 vis 可以使用memset，常见用法是这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br>CLR(vis,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>找到起点和终点的状态。终点顾名思义其中有一个水壶的储水量是c的时候就代表了end，而开始我们发现他给定的是两个空的水壶，所以我们给定一个node 初始化全0,记得标记vis是1，然后将其推到队列里作为起始点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">  <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>   <br>   node t;<br>   t.cnt=<span class="hljs-number">0</span>;<br>   t.x=<span class="hljs-number">0</span>;<br>   t.y=<span class="hljs-number">0</span>;<br>   t.s=<span class="hljs-string">""</span>;<br>vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure>
<p>但，不难发现，第一步的走法其实只有给两个壶其中之一填满。所以我们也可以是将其设为两个初始点，添加到队列其中去，但是记得更改相关的数值，参考下code。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">node t;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = a;<br>   t.y = <span class="hljs-number">0</span>;<br>   t.s = <span class="hljs-string">"FILL(1)\n"</span>;<br>   q.push(t);<br>   <br>   vis[a][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = <span class="hljs-number">0</span>;<br>   t.y = b;<br>   t.s = <span class="hljs-string">"FILL(2)\n"</span>;<br>   vis[<span class="hljs-number">0</span>][b] = <span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure>
<p>当然，两者的区别并不是很大，选择前者更容易理解一些，也更加符合一般的bfs的要求。</p>
</li>
<li><p>下面就要进入queue队列的循环中去咯~</p>
<p>进入循环当然先把front给从队列中打捞出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br></code></pre></td></tr></table></figure>
<p>这里的t 是借用了上面的t实际上,我们往往是重新node next  的做法往往更普遍一些。</p>
<p>有了 此次开头的中心点，我们就要赶紧确定什么时候能结束了，万一我们直接就出去了呢哈哈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>这里有一丝丝的玄机，因为这里采用了break，所以我们在最后bfs返回的是cnt的值，所以我们要将cnt给赋值了，才能return 回去。虽然我们在这里就输出了cnt，但返回的cnt是用来判断我们是否是impossible，如果我们一直没有找到使得题目成立条件，而队列走走完了，那我们就一直没有给cnt赋过值，所以我们自然是返回的是0 那么，就可在main函数中做出特判。</p>
</li>
<li><p>接下来就是几种动作的出现，其实就是6种</p>
<p> FILL(1),FILL(2),DROP(1),DROP(2),POUR(1,2),POUR(2,1) </p>
<p>我们在对其分别进行情况的判定，然后一一进行就可以了。当然这个过程是艰苦的，如果在一些相似的地方没有思考清楚而是cv的话，容易由于没有看清而出现许多问题。所以奥里给，这一部分需要认真一些。</p>
<p>对了，我们在前面看到我们既然进行到了这一步，一定是出不去了所以front.cnt++；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// </span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>最后return cnt;就可以结束这个bfs了。小心，因为代码过长，一处很小的错误可能就会gg。</p>
<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>对，你没有看错，两套代码，中英双文嘿嘿，两种代码其实在一些小的方面有所不同，参考第一个即可，第二个是他人代码（出处已不可寻）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">0</span>;<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br><br>    node t;<br>    t.cnt=<span class="hljs-number">0</span>;<br>    t.x=<span class="hljs-number">0</span>;<br>    t.y=<span class="hljs-number">0</span>;<br>    t.s=<span class="hljs-string">""</span>;<br>    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br>        <span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// &lt;?</span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(bfs()==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"impossible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//personal code.</span><br><br><span class="hljs-comment">/*<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;map&gt;<br>#include&lt;set&gt;<br>#include&lt;queue&gt;<br>#include&lt;string&gt;<br>#include&lt;iostream&gt;<br>using namespace std;<br>#define CLR(arr,val) memset(arr,val,sizeof(arr))<br><br>int n , m , x;<br>bool vis[200][200];<br>//图上所有点的取值区域可用 a，b的不同的水量状态表示！<br>struct nodes&#123;<br>	int x, y;<br>	string step;<br>	int cnt;<br>&#125;;<br> <br>int bfs() &#123;<br>	int cnt = 0;<br>	CLR(vis, 0);//init<br>	queue&lt;nodes&gt; q;<br>	nodes nd1;<br><br>	nd1.x = 0;//(init)<br>	nd1.y = 0;<br>	nd1.cnt = 0;<br>    nd1.step = "";<br>	q.push(nd1);<br>	vis[0][0]=1;<br>	<br>	while(!q.empty()) &#123;<br>		nodes nd = q.front();<br>		q.pop();<br>		if (nd.x == x || nd.y == x) &#123;// end<br>			cnt = nd.cnt;<br>			cout&lt;&lt;cnt&lt;&lt;"\n";// it looks like nothing at all. However this cnt is connect to the return value!<br>                            //there is one possible thing is that we could at the last step that we find the right idea!<br>			cout&lt;&lt;nd.step;<br>			break;<br>		&#125;<br>		++nd.cnt;// every time the nd will be renew one as front;<br>		nodes nd2;//as next<br>		nd2.cnt = nd.cnt; <br>		if (nd.x &lt; n &amp;&amp; !vis[n][nd.y]) &#123;//if fronter is not full&amp;&amp; not visit the status when it is full<br>			nd2.x = n;<br>			nd2.y = nd.y;<br>			nd2.step = nd.step + "FILL(1)\n";<br>			q.push(nd2);<br>			vis[nd2.x][nd2.y] = 1;<br>		&#125;<br>		if (nd.y &lt; m &amp;&amp; !vis[nd.x][m]) &#123;<br>			nd2.x = nd.x;<br>			nd2.y = m;<br>			nd2.step = nd.step + "FILL(2)\n";<br>			q.push(nd2);<br>			vis[nd2.x][nd2.y] = 1;<br>		&#125;<br>		<br>		if (nd.x &gt; 0 &amp;&amp; nd.y != m) &#123;//when a is not a empty one &amp;&amp; b is not full<br>			if (nd.x &gt;= (m - nd.y) &amp;&amp; nd.x != 0) &#123;//if a couldn't pour it's all to b<br>				nd2.x = (nd.x - (m - nd.y));// a will pour as more as it could <br>				nd2.y = m;				<br>			&#125; <br>            else &#123;//a could pour all to b<br>				nd2.y = (nd.x + nd.y);<br>				nd2.x = 0;<br>			&#125;<br><br>			if (!vis[nd2.x][nd2.y]) &#123;<br>				nd2.step = nd.step + "POUR(1,2)\n";<br>				q.push(nd2);<br>				vis[nd2.x][nd2.y] = 1;<br>			&#125;<br>			<br>		&#125;<br>		<br>		if (nd.y &gt; 0 &amp;&amp; nd.x != n) &#123;//pour b to a<br>			if (nd.y &gt;= (n - nd.x) &amp;&amp; nd.y != 0) &#123;<br>				nd2.y = (nd.y - (n - nd.x));<br>				nd2.x = n;<br>			&#125; else &#123;<br>				<br>				nd2.x = (nd.y + nd.x);<br>				nd2.y = 0;<br>			&#125;<br>			if (!vis[nd2.x][nd2.y]) &#123;<br>				nd2.step = nd.step + "POUR(2,1)\n";<br>				q.push(nd2);<br>				vis[nd2.x][nd2.y] = 1;	<br>			&#125;<br>		&#125;<br>		<br>		if (nd.x &gt; 0 &amp;&amp; !vis[0][nd.y]) &#123;//a is not empty<br>			nd2.x = 0;<br>			nd2.y = nd.y;<br>			nd2.step = nd.step + "DROP(1)\n";<br>			q.push(nd2);<br>			vis[nd2.x][nd2.y] = 1;<br>		&#125;<br>		if (nd.y &gt; 0 &amp;&amp; !vis[nd.x][0]) &#123;<br>			nd2.x = nd.x;<br>			nd2.y = 0;<br>			nd2.step = nd.step + "DROP(2)\n";<br>			q.push(nd2);<br>			vis[nd2.x][nd2.y] = 1;<br>		&#125;<br>		<br>	&#125;<br>	return cnt;<br>&#125;<br> <br>int main()<br>&#123;<br>	while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;x) &#123;<br>		if (bfs() == 0) &#123;<br>			cout&lt;&lt;"impossible"&lt;&lt;endl;<br>		&#125; <br>	&#125;<br>&#125;<br>*/</span><br></code></pre></td></tr></table></figure>
<p>当然，这道题目还见到有用其他方法去配合bfs进行解题的，</p>
<p><a href="https://blog.csdn.net/qq_34374664/article/details/53170539" target="_blank" rel="noopener">其他方法之一</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>poj bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>pta六度空间</title>
    <url>/2020/06/04/pta%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>“<a href="http://pta.patest.cn/pta/test/15/exam/4/question/715" target="_blank" rel="noopener">六度空间</a>”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。</p>
  <a id="more"></a>
<p><img src="https://images.ptausercontent.com/35" alt="t"></p>
<p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>
<p><strong>输入格式说明：</strong></p>
<p>输入第1行给出两个正整数，分别表示社交网络图的结点数N （1&lt;N&lt;=104，表示人数）、边数M（&lt;=33*N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p>
<p><strong>输出格式说明：</strong></p>
<p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h5><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>: <span class="hljs-number">70.00</span>%<br><span class="hljs-number">2</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">3</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">4</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">5</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">6</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">7</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">8</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">9</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">10</span>: <span class="hljs-number">70.00</span>%<br></code></pre></td></tr></table></figure>
<h3 id="一点理解："><a href="#一点理解：" class="headerlink" title="一点理解："></a>一点理解：</h3><p>时隔一个多月，再次做到此题目，发现并不会写了（<del>并不是</del>),甚至原来的题解，也不会写了，回想起来，自己还写过题解，特此更新。。。发现原来写的题解具有一定的局限性，并不是十分好理解，所以特此更新呢。</p>
<p>以下为原题解：</p>
<p>乍一看题目所求有些懵，其实所求的是每个节点相邻的6层之内的节点个数与总结点的比例；</p>
<p>那么我们只需要求出每个节点的相邻六层的节点的个数（bfs）</p>
<p>在bfs中我们还需要注意一下，我们在统计个数的时候还有记得数层数，够了层数就不再去数数了。</p>
<p>所以引申出来层数的判断，那么如何确定到那一层了呢？</p>
<p>采用的就是tail和last的不断更新（详见代码）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10005</span>;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[maxn];<br><span class="hljs-keyword">int</span> vertices, edges;<span class="hljs-comment">//所有的顶点数和边数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;i++)&#123;<br>        vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//init vis[]</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> tail;<br>    <span class="hljs-keyword">int</span> last = v;<span class="hljs-comment">//指的是每一圈的最后一个（每一个外圈的的每一个顶点都要入队，当该外圈的最后一个也出队了，那么这一层也循环完了</span><br>    <span class="hljs-keyword">int</span> count =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;<br>    vis[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    q.push(v);<br><br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        <span class="hljs-keyword">int</span> x = q.front();<span class="hljs-comment">//get the first每一圈的每一个顶点</span><br>        q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;g[x].size();j++)&#123;<span class="hljs-comment">//判断条件是与x相连的所有顶点的个数</span><br>            <span class="hljs-keyword">if</span>(!vis[g[x][j]])&#123;<br>                vis[g[x][j]] = <span class="hljs-literal">true</span>;<br>                q.push(g[x][j]);<br>                tail = g[x][j];<span class="hljs-comment">//每次都将替换更新，最后得到的是该节点的最后一个相连顶点</span><br>                count++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span>(x==last)&#123;<br>            <span class="hljs-comment">/*这里指的是我们将该层全部弹出时应所满足的条件<br>            注意第一次的时候是直接成立的<br>            而在第二圈（或更多）的时候，我们将<br>            第一个节点的最后一个遍历的节点作为tail<br>            然后他就成为了last即上一层的最后一个元素<br>            */</span><br>            last = tail;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(level==<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>         &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        g[x].push_back(y);<span class="hljs-comment">//建立两者之间边的关系</span><br>        g[y].push_back(x);<span class="hljs-comment">//认识是相互的，所以相互加关联</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>下面是一个月后经过了几道[[bfs]]题目熏陶后的想法:</p>
<p>首先读题，发现题目要求我们输出比例，显然总结点数已经给出，那么得到每一个节点的6层以内的节点数即可。</p>
<p>接着题目有给定了节点之间的关系，所以我们自己可以通过一个bool类型的rel(relative)的二维数组来确定两者的关系是否连通。（这一步可以在main函数中实现）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <br>    <span class="hljs-built_in">memset</span>(ral,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(ral));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        ral[x][y]=<span class="hljs-number">1</span>;<br>        ral[y][x]=<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来，我们就要把他传入bfs中了，然后使得bfs返回该节点符合关系的节点数目即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br></code></pre></td></tr></table></figure>
<p>在bfs 的函数中，我们很显然，起点就是我们给定的j，j即为起始点，由<strong>他出发寻找到在六层内不同的节点的个数。</strong></p>
<p>从这个任务中我们也可得出一个状态的内容是它自身的节点名称（在此题目中是一个int值）还要有一个cnt来表示层数，方便我们作为层数的限制条件，这在其他的bfs题目中，层数亦十分有用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> cnt;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>哦，我们不能忘我们刚刚给的要求了，不同的节点，相同的节点找他干嘛。。。所以还要有一个vis的一维数组，范围是所有节点数量，表示他们是否被访问过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-keyword">bool</span> ral[maxn][maxn];<br></code></pre></td></tr></table></figure>
<p>那么bfs的结束条件是？队列结束或者达到节点6层。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>    <span class="hljs-built_in">queue</span>&lt;node&gt;q;<br>    vis[v]=<span class="hljs-number">1</span>;<br>    node t;<br>    t.cnt = <span class="hljs-number">1</span>;<br>    t.val = v;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(front.cnt&gt;<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>        t.cnt = front.cnt+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=vertices;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ral[front.val][i]&amp;&amp;!vis[i])&#123;<br>                vis[i]=<span class="hljs-number">1</span>;<br>                count++;<br>                t.val = i; <br>                q.push(t);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>bfs里面的cnt&gt;或是&gt;=我是猜的，可以通过数据检验，稍微改改就凑上了。。省得麻烦考虑了，不过最好还是考虑周全。</p>
<p>在这里val的数据范围是[n] [n]或者说直接定义1001（因为题目给定的数据n&lt;=10^3)。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>pta拯救007</title>
    <url>/2020/06/03/pta%E6%8B%AF%E6%95%91007/</url>
    <content><![CDATA[<h2 id="题目详情："><a href="#题目详情：" class="headerlink" title="题目详情："></a>题目详情：</h2><p>在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）<br>设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。</p>
  <a id="more"></a>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>首先第一行给出两个正整数：鳄鱼数量 N（≤100）和007一次能跳跃的最大距离 D。随后 N 行，每行给出一条鳄鱼的 (x,y) 坐标。注意：不会有两条鳄鱼待在同一个点上。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>如果007有可能逃脱，就在一行中输出”Yes”，否则输出”No”。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><p>14 20<br>25 -15<br>-25 28<br>8 49<br>29 15<br>-35 -2<br>5 28<br>27 -29<br>-8 -28<br>-20 -35<br>-25 -20<br>-13 29<br>-30 15<br>-35 40<br>12 12</p>
<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><p>Yes</p>
<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><p>4 13<br>-12 12<br>12 12<br>-12 -12<br>12 -12</p>
<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><p>No</p>
<h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>这道题目的解题中使用到了dfs和图的相关知识，</p>
<p>p[]是所输入的每个节点的数组（鳄鱼的集合）</p>
<p>vis[]是判断是否该节点被访问：</p>
<p>如果被访问过了，那么只有两种情况：1.找到出口，直接弹出（break）。2.没有出口~</p>
<p>所以如果节点被访问过，就意味着该节点不是出口。</p>
<p>另外注意我们还有对于第一次的中心岛的特殊判断，他的距离与其他的dfs过程不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,d;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>//定义节点（存储<span class="hljs-title">x</span>，<span class="hljs-title">y</span>坐标）<br>&#123;</span> <br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;p[<span class="hljs-number">110</span>];  <br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<br><span class="hljs-keyword">bool</span> flag =<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">first</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断该节点是否可以在第一次可以跳出中心岛（即判断该点是否在第一次跳出的半径内）</span><br>    <span class="hljs-keyword">return</span>(p[i].x*p[i].x+p[i].y*p[i].y &lt;= (d+<span class="hljs-number">7.5</span>)*(d+<span class="hljs-number">7.5</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">success</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断能否在该结点处一次直接跳出（d&gt;0），分别判断x，y是否可以跳出边界(即能否一步上岸)</span><br>    <span class="hljs-keyword">return</span> p[i].x-d&lt;=<span class="hljs-number">-50</span>||p[i].x+d&gt;=<span class="hljs-number">50</span>||p[i].y+d&gt;=<span class="hljs-number">50</span>||p[i].y-d&lt;=<span class="hljs-number">-50</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<span class="hljs-comment">//判断是否可以从一点跳到另一点</span><br>    <span class="hljs-keyword">return</span> (p[i].x*p[i].x+p[i].y*p[i].y)&lt;d*d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//递归，dfs判断是否可以找到出去的路</span><br>    vis[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//表示已经访问该节点</span><br>    <span class="hljs-keyword">if</span>(success(i))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-comment">//遍历寻找节点</span><br>        <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;isJump(i,j))<br>        &#123;<span class="hljs-comment">//如果该点访问过，那么此路就代表不通，应该放弃这个点；同时我们还要找到可以跳跃过去的点。</span><br>        <span class="hljs-keyword">if</span>(dfs(j))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d&gt;=<span class="hljs-number">42.5</span>)flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//应该通过遍历找到符合条件的节点</span><br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;first(i))<span class="hljs-comment">//如果没有访问过这个节点，且在第一次跳出的半径内。</span><br>                <span class="hljs-keyword">if</span>(dfs(i))&#123;<br>                    flag =<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出并不再寻找</span><br>                &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"yes"</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"no"</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>pta统计一行文本的单词个数</title>
    <url>/2019/11/24/pta%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>本题目要求编写程序统计一行字符中单词的个数。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。</p>
  <a id="more"></a>
<h2 id="输入格式-输入给出一行字符。"><a href="#输入格式-输入给出一行字符。" class="headerlink" title="输入格式:输入给出一行字符。"></a>输入格式:输入给出一行字符。</h2><h2 id="输出格式-在一行中输出单词个数。"><a href="#输出格式-在一行中输出单词个数。" class="headerlink" title="输出格式:在一行中输出单词个数。"></a>输出格式:在一行中输出单词个数。</h2><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Let’s go to room 209.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> i,cnt=<span class="hljs-number">0</span>,cntword=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">char</span> a;<br><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;a);<br>	<br>	<span class="hljs-keyword">if</span>(a==<span class="hljs-string">'\n'</span>)&#123;<span class="hljs-comment">//因为只是一行字符，所以遇到回车就结束。</span><br>	<span class="hljs-keyword">break</span>;	<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a!=<span class="hljs-string">' '</span>)&#123;<span class="hljs-comment">//首字母不为‘ ’时</span><br>		cntword++;<br><br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//此循环的意义在于判断该单词的位数。</span><br>	 <span class="hljs-comment">//此循环应放在 首字母不为0时的语句中。否则会使的首字母为空格时，使	之跳过下一个字母（如输入‘ 1’则会输出0） </span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;a);<br>		<span class="hljs-keyword">if</span>(a==<span class="hljs-string">' '</span>||a==<span class="hljs-string">'\n'</span>)&#123;<br>		<span class="hljs-keyword">break</span>;<br>		&#125;<span class="hljs-comment">//判断该单词是否为单字母单词 ，注意该单词在扫描到第一个字母时	已经将其cntword++ </span><br>	<br>	&#125;<span class="hljs-keyword">if</span>(a==<span class="hljs-string">'\n'</span>)&#123;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	&#125;<br>	<br>&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,cntword); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="希望此题可以有助于改变我们思考问题的方式。"><a href="#希望此题可以有助于改变我们思考问题的方式。" class="headerlink" title="希望此题可以有助于改变我们思考问题的方式。"></a>希望此题可以有助于改变我们思考问题的方式。</h4>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>pta输出指定范围内的斐波那契数列</title>
    <url>/2019/11/07/pta%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>这是一道pta的题目，对新人有一定难度（我就是）。</p>
  <a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>本题要求实现一个计算Fibonacci数的简单函数，并利用其实现另一个函数，输出两正整数m和n（0&lt;m≤n≤10000）之间的所有Fibonacci数。所谓Fibonacci数列就是满足任一项数字是前两项的和（最开始两项均定义为1）的数列。<br>函数接口定义：<br>int fib( int n );<br>void PrintFN( int m, int n );<br>其中函数fib须返回第n项Fibonacci数；函数PrintFN要在一行中输出给定范围[m, n]内的所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。如果给定区间内没有Fibonacci数，则输出一行“No Fibonacci number”。</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #include &lt;stdio.h&gt;</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintFN</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n )</span></span>;<br>	<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> m, n, t;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;t);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fib(%d) = %d\n"</span>, t, fib(t));<br>    PrintFN(m, n);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 你的代码将被嵌在这里 */</span><br></code></pre></td></tr></table></figure>
<h2 id="作业代码-后面有很多可以改进的地方）"><a href="#作业代码-后面有很多可以改进的地方）" class="headerlink" title="作业代码(后面有很多可以改进的地方）"></a>作业代码(后面有很多可以改进的地方）</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <br>	<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,a[<span class="hljs-number">10000</span>];<span class="hljs-comment">//n==2;</span><br>	<span class="hljs-keyword">for</span>(;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||i==<span class="hljs-number">1</span>)&#123;<br>		a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <br>		&#125;<span class="hljs-keyword">else</span> a[i]=a[i<span class="hljs-number">-2</span>]+a[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<br>			<span class="hljs-keyword">return</span> a[i];	 <br>	&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintFN</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n )</span></span>&#123;<br>	<span class="hljs-keyword">int</span> i;<br>	<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10000</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(fib(i)&gt;<span class="hljs-number">10000</span>)&#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;	<span class="hljs-keyword">if</span> (fib(i)==m)&#123;<br>			<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>) ;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,fib(i));<br>			cnt++;<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fib(i)&gt;m&amp;&amp;fib(i)&lt;=n)&#123;<br>			cnt++;<br>			<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,fib(i));<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,fib(i));<br>	<br>		&#125;	<br>	&#125;<br>	<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Fibonacci number"</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分步改正并讲解"><a href="#分步改正并讲解" class="headerlink" title="分步改正并讲解"></a>分步改正并讲解</h2><h3 id="int-fib-int-n-；-返回第n项斐波那契数。"><a href="#int-fib-int-n-；-返回第n项斐波那契数。" class="headerlink" title="int fib(int n)；//返回第n项斐波那契数。"></a>int fib(int n)；//返回第n项斐波那契数。</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//返回第n项斐波那契数。 </span><br>	<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,a[<span class="hljs-number">10000</span>];<span class="hljs-comment">//n==2;</span><br>	<span class="hljs-keyword">for</span>(;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||i==<span class="hljs-number">1</span>)&#123;<br>		a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; <br>		&#125;<span class="hljs-keyword">else</span> a[i]=a[i<span class="hljs-number">-2</span>]+a[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<br>			<span class="hljs-keyword">return</span> a[i];<br>		&#125;<span class="hljs-comment">//牺牲空间而下面的牺牲时间（每次都从头算一遍）</span><br>	&#125;<br>&#125;<span class="hljs-comment">/*int fib( int n )&#123;<br>    if(n==1||n==2)<br>	return 1;<br><br>	return fib(n-2)+fib(n-1);<br>&#125;*/</span><span class="hljs-comment">//可用其替换啊啊啊啊！</span><br></code></pre></td></tr></table></figure>
<h3 id="void-PrintFN-int-m-int-n-返回【m，n】之间的斐波那契数列"><a href="#void-PrintFN-int-m-int-n-返回【m，n】之间的斐波那契数列" class="headerlink" title="void PrintFN( int m, int n )//返回【m，n】之间的斐波那契数列"></a>void PrintFN( int m, int n )//返回【m，n】之间的斐波那契数列</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintFN</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n )</span></span>&#123;<span class="hljs-comment">//输出所有斐波那契数列并一直到第m项，打印出来</span><br>	<span class="hljs-keyword">int</span> i;<br>	<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10000</span>;i++)&#123;<br>		<span class="hljs-keyword">if</span>(fib(i)&gt;<span class="hljs-number">10000</span>)&#123;<span class="hljs-comment">//因为会有内存溢出</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;	<span class="hljs-keyword">if</span> (fib(i)==m)&#123;<br><span class="hljs-comment">//下面我写的代码很奇怪吧，因为如果不这么做，当m==1时就会 输出三个1；所以很无奈		</span><br><span class="hljs-comment">/*int first = 1;<br>    if(m==1)&#123;<br>        printf("1 1");<br>        first = 0;<br>        m = 2;<br>    &#125;*/</span><span class="hljs-comment">//这样是一种更好的做法，直接输出1 1；</span><br>			<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>) ;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,fib(i));<br>			cnt++;<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fib(i)&gt;m&amp;&amp;fib(i)&lt;=n)&#123;<br>			cnt++;<br>			<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,fib(i));<br>			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,fib(i));<br>	<br>		&#125;	<br>	&#125;<br>	<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Fibonacci number"</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>感谢众多大神的帮助，这篇文章只是为了帮助更多的入门者更好的走下去。</p>
<p>文中有参考<a href="https://blog.csdn.net/qq_43328781/article/details/85157414" target="_blank" rel="noopener">https://blog.csdn.net/qq_43328781/article/details/85157414</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>一元多次多项式的加减</title>
    <url>/2020/03/26/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F/</url>
    <content><![CDATA[<h1 id="一元多项式的加减法"><a href="#一元多项式的加减法" class="headerlink" title="一元多项式的加减法"></a>一元多项式的加减法</h1><p>tips: 三月份写过这个题解，当时确实解决了当时问题，但是方法是错的，两个月后，又做类似的题目，只是将指数由大到小的排列便错了，那么我就不（敢）再误人子弟，便删去旧的题解，写新的题解。这一次经历了两天来研究指针的问题，可以说，过程比较令人头大，但是对指针的了解也更多了一些。功不唐捐！</p>
<p>在学习链表的过程中，了解到可以使用链表的方式来实现一元多项式的加减（还打算实现乘法和除法，但是技术有限，一时不一会写，哈哈，以后或许会悄悄更新吧）</p>
  <a id="more"></a>
<h2 id="如何获取到两个一元多项式"><a href="#如何获取到两个一元多项式" class="headerlink" title="如何获取到两个一元多项式"></a>如何获取到两个一元多项式</h2><p>我们可以使用到首先明确一共有多少项，输入数据应该如下示例：<br>如果希望输入的多项式是：x+2x^2+3x^3<br>那么输入的数据应该是： 3 1 1 2 2 3 3<br>第一个输入一共多少项，之后我们可以依次输入每项的底数和次方。</p>
<h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><p>自然是使用链表咯！</p>
<h2 id="代码里面见分析！"><a href="#代码里面见分析！" class="headerlink" title="代码里面见分析！"></a>代码里面见分析！</h2><p>精华应该是在于对于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>	<span class="hljs-keyword">int</span> coef;<br>	<span class="hljs-keyword">int</span> index;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;node;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;	<br>	<span class="hljs-keyword">int</span> n;<br>	<span class="hljs-built_in">cin</span>&gt;&gt;n;<br>	<span class="hljs-keyword">int</span> coef;<br>	<span class="hljs-keyword">int</span> index;<br>	node* head1 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>	node* headfirst = head1;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>		<span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br>		<span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>		head1-&gt;next = t;<br>		head1 = head1-&gt;next;			<br>	&#125;<br>	head1-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-built_in">cin</span>&gt;&gt;n;<br>	node* head2 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>	node* headsecond = head2;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>		<span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br>		<span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>		head2-&gt;next = t;<br>		head2 = head2-&gt;next;			<br>	&#125;<br>	head2-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><br><br>	<span class="hljs-comment">//start  </span><br>	Node* tail = headfirst;<br>	Node* p = headfirst-&gt;next;<br>	Node* q = headsecond-&gt;next;<br>	Node* t = headfirst;<span class="hljs-comment">//as the result</span><br>	<span class="hljs-keyword">while</span>(q&amp;&amp;p)&#123;<br>		<span class="hljs-keyword">if</span>(p-&gt;index &gt; q-&gt;index)&#123;<br>			tail = p;<br>			p= p-&gt;next;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(p-&gt;index &lt; q-&gt;index)&#123;<br>			tail-&gt;next = q;<br>			tail = q;<br>			q = q-&gt;next; <br>		&#125;	<br>		<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">if</span>(p-&gt;coef + q-&gt;coef==<span class="hljs-number">0</span>)&#123;<br>				tail-&gt;next = p-&gt;next;<br>				Node* temp = p;	<br>				p = p-&gt;next;<br>				<span class="hljs-built_in">free</span>(temp);<br>				temp = q;<br>				q= q-&gt;next;<br>				<span class="hljs-built_in">free</span>(temp);<br>			&#125; <br>			<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//coef之和不为0，index相等时 </span><br>				p-&gt;coef = p-&gt;coef + q-&gt;coef;<br>				tail -&gt;next = p;<br>				p = p-&gt;next;<br>				Node* temp = q;<br>				q = q-&gt;next;		<br>				<span class="hljs-built_in">free</span>(temp);<br>			&#125;<br>		&#125;	<br>	&#125;<br>    t = t-&gt;next;<br>	<span class="hljs-keyword">while</span>(t)&#123;<br>		<span class="hljs-keyword">if</span>(t!=headfirst-&gt;next&amp;&amp;t-&gt;coef&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"+"</span>;<br>		<span class="hljs-built_in">cout</span>&lt;&lt;t-&gt;coef&lt;&lt;<span class="hljs-string">"x"</span>;<br>		<span class="hljs-keyword">if</span>(t-&gt;index!=<span class="hljs-number">1</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"^"</span>&lt;&lt;t-&gt;index;<br>		t = t-&gt;next;<br>		<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>使用sort函数对结构体排序</title>
    <url>/2020/01/31/%E4%BD%BF%E7%94%A8sort%E5%87%BD%E6%95%B0%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在使用sort函数排序的时候，遇到了一些问题（因为我们不只是排序数组呀）。</p>
<p>比如我们只想利用结构体变量中的其中一个变量来对结构体排序；（比如实际应用中对学生的成绩排序并进行打印）</p>
<p>那么经查阅，（简单的方法）大致为如下：</p>
  <a id="more"></a>
<h6 id="首先：sort函数的组成："><a href="#首先：sort函数的组成：" class="headerlink" title="首先：sort函数的组成："></a>首先：sort函数的组成：</h6><p>1、sort函数可以三个参数也可以两个参数，必须的头文件#include &lt; algorithm&gt;和using namespace std;<br>2、它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)</p>
<p>3、Sort函数有三个参数：（第三个参数可写，可不写）</p>
<p>（1）第一个是要排序的数组的起始地址。</p>
<p>（2）第二个是结束的地址（最后一位要排序的地址）</p>
<p>（3）第三个参数是排序的方法（一般为一个函数），可以是从大到小也可是从小到大，还可以不写第三个参数，此时<strong>默认的排序方法是从小到大排序</strong>。</p>
<h6 id="那么，开始排序："><a href="#那么，开始排序：" class="headerlink" title="那么，开始排序："></a>那么，开始排序：</h6><p>首先：写一下结构体的组成吧。较为简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span>&#123;</span><br>	<span class="hljs-keyword">int</span> x;<br>	<span class="hljs-keyword">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>对于第三个参数，即排序方式，自然是需要设置的。如下几种函数<del>（其实是一种）</del>均可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct ss c, struct ss d)</span><br></span>&#123;<br>	<span class="hljs-keyword">if</span>(c.y &lt; d.y)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct ss c, struct ss d)</span><br></span>&#123;<br>	<span class="hljs-keyword">if</span>(c.y &lt; d.y)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct ss c, struct ss d)</span><br></span>&#123;<br>	<span class="hljs-keyword">if</span>(c.y &lt; d.y)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么不妨测试一下：对第二个数据（y）排序升序（升降序通过第三个参数的符号即可）：</p>
<h6 id="测试数据："><a href="#测试数据：" class="headerlink" title="测试数据："></a>测试数据：</h6><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">130</span><br><span class="hljs-symbol">120 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">150 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">110 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">180 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">50 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">200 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">140 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">120 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h6 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h6><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span>&#123;</span><br>	<span class="hljs-keyword">int</span> x;<br>	<span class="hljs-keyword">int</span> y;<br>&#125;; <br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(struct ss c, struct ss d)</span><br></span>&#123;<br>	<span class="hljs-keyword">if</span>(c.y &lt; d.y)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> i,n,a,b,s,sum=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;<br>	<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span> <span class="hljs-title">apple</span>[<span class="hljs-title">n</span>];</span><br>	<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>	<span class="hljs-built_in">cin</span>&gt;&gt;apple[i].x&gt;&gt;apple[i].y;<br>	sort(apple,apple+n<span class="hljs-number">-1</span>,cmp);<span class="hljs-comment">//对结构体排序 </span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;apple[<span class="hljs-number">0</span>].x&lt;&lt;<span class="hljs-string">"  "</span>&lt;&lt;apple[<span class="hljs-number">0</span>].y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="测试结果：120-0"><a href="#测试结果：120-0" class="headerlink" title="测试结果：120  0"></a>测试结果：120  0</h6>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>stlvector</title>
    <url>/2020/02/27/stlvector/</url>
    <content><![CDATA[<p>Vectors are same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, with their storage being handled automatically by the container. Vector elements are placed in contiguous storage so that they can be accessed and traversed using iterators. In vectors, data is inserted at the end. Inserting at the end takes differential time, as sometimes there may be a need of extending the array. Removing the last element takes only constant time because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.</p>
<p>向量与<strong>动态数组</strong>相同，具有在插入或删除元素时自动调整自身大小的能力，并且容器自动处理其存储。 矢量元素放置在连续的存储中，以便可以使用迭代器对其进行访问和遍历。 在向量中，数据插入到最后（push_back())。 在末尾插入需要花费不同的时间，因为有时可能需要扩展阵列。 删除最后一个元素只需要固定的时间，因为不会发生大小调整。 在开始或中间插入和擦除的时间是线性的。</p>
  <a id="more"></a>
<h3 id="Certain-functions-associated-with-the-vector-are"><a href="#Certain-functions-associated-with-the-vector-are" class="headerlink" title="Certain functions associated with the vector are:"></a>Certain functions associated with the vector are:</h3><h2 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h2><p><strong>Iterators操作</strong></p>
<ol>
<li><a href="https://www.geeksforgeeks.org/vectorbegin-vectorend-c-stl/" target="_blank" rel="noopener">begin()</a> – Returns an iterator pointing to the first element in the vector（返回一个指向开始的迭代器（指针））</li>
<li><a href="https://www.geeksforgeeks.org/vectorbegin-vectorend-c-stl/" target="_blank" rel="noopener">end()</a> – Returns an iterator pointing to the theoretical element that follows the last element in the vector（返回的是最后一个元素的迭代器（指针））</li>
<li><a href="https://www.geeksforgeeks.org/vector-rbegin-and-rend-function-in-c-stl/" target="_blank" rel="noopener">rbegin()</a> – Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element（反转的开始，及最后的位置）</li>
<li><a href="https://www.geeksforgeeks.org/vector-rbegin-and-rend-function-in-c-stl/" target="_blank" rel="noopener">rend()</a> – Returns a reverse iterator pointing to the theoretical element（反转的end，<strong>并不是指向第一个而是第一个之前的理论位置</strong>）<br>preceding the first element in the vector (considered as reverse end)</li>
<li><a href="https://www.geeksforgeeks.org/vector-cbegin-vector-cend-c-stl/" target="_blank" rel="noopener">cbegin()</a> – Returns a constant iterator pointing to the first element in the vector.（返回一个常量的开始指针，无法修改）</li>
<li><a href="https://www.geeksforgeeks.org/vector-cbegin-vector-cend-c-stl/" target="_blank" rel="noopener">cend()</a> – Returns a constant iterator pointing to the theoretical element that follows the last element in the vector.（返回最后一个之后的一个理论位置的常量，无法被修改）</li>
<li><a href="https://www.geeksforgeeks.org/vectorcrend-vectorcrbegin-examples/" target="_blank" rel="noopener">crbegin()</a> – Returns a constant reverse iterator pointing to the last element in<br>the vector (reverse beginning). It moves from last to first element（同理常量，最后一个的位置）</li>
<li><a href="https://www.geeksforgeeks.org/vectorcrend-vectorcrbegin-examples/" target="_blank" rel="noopener">crend()</a> – Returns a constant reverse iterator pointing to the theoretical<br>element preceding the first element in the vector (considered as reverse end)（同理常量，第一个之前的位置）</li>
</ol>
<p>理解：当使用了这些不同的迭代器操作可以减少操作的失误，更加准确，直观地写出更优质的代码。</p>
<h3 id="Capacity容量"><a href="#Capacity容量" class="headerlink" title="Capacity容量"></a><strong>Capacity容量</strong></h3><ol>
<li><a href="https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/" target="_blank" rel="noopener">size()</a> – Returns the number of elements in the vector.元素的个数</li>
<li><a href="https://www.geeksforgeeks.org/vector-max_size-function-in-c-stl/" target="_blank" rel="noopener">max_size()</a> – Returns the maximum number of elements that the vector can hold.返回可容纳的最大地元素数量（通常超级超级大，是内存）</li>
<li><p><a href="https://www.geeksforgeeks.org/vector-capacity-function-in-c-stl/" target="_blank" rel="noopener">capacity()</a> – Returns the size of the storage space currently allocated to the vector expressed as number of elements.</p>
<p> 返回现在所分配的内存大小（但他是用对应的元素个数来作为返回值的）</p>
</li>
<li><p><a href="https://www.geeksforgeeks.org/vector-resize-c-stl/" target="_blank" rel="noopener">resize(n)</a> – Resizes the container so that it contains ‘n’ elements.调整容器的大小，使其能够容纳n个元素，如果原本的容量比他大，那就不更替</p>
</li>
<li><a href="https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/" target="_blank" rel="noopener">empty()</a> – Returns whether the container is empty.返回vector是否为空</li>
<li><a href="https://www.geeksforgeeks.org/vector-shrink_to_fit-function-in-c-stl/" target="_blank" rel="noopener">shrink_to_fit()</a> – Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.减小容器的容量以适应其大小，并销毁超出容量的元素</li>
<li><a href="https://www.geeksforgeeks.org/using-stdvectorreserve-whenever-possible/" target="_blank" rel="noopener">reserve()</a> – Requests that the vector capacity be at least enough to contain n elements.调整容器大小，使其最小包含n个元素</li>
</ol>
<ul>
<li><strong>需要注意的是resize会将多出的空间分配为0，而reserve不会。</strong></li>
<li>而shrink_to_fit仅仅适用于c++11及其以上（devc++，不支持）</li>
<li>empty（）返回的是bool但是在c中1或者0也可以使用；</li>
</ul>
<h3 id="访问元素："><a href="#访问元素：" class="headerlink" title="访问元素："></a><strong>访问元素：</strong></h3><p><strong>Element access:</strong></p>
<ol>
<li><a href="https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/" target="_blank" rel="noopener">reference operator [g]</a> – Returns a reference to the element at position ‘g’ in the vector使用类似于数组的取址符【】</li>
<li><a href="https://www.geeksforgeeks.org/vectorat-vectorswap-c-stl/" target="_blank" rel="noopener">at(g)</a> – Returns a reference to the element at position ‘g’ in the vector（和上面的类似，但会更好，不会越界）</li>
<li><a href="https://www.geeksforgeeks.org/vectorfront-vectorback-c-stl/" target="_blank" rel="noopener">front()</a> – Returns a reference to the first element in the vector最前的元素</li>
<li><a href="https://www.geeksforgeeks.org/vectorfront-vectorback-c-stl/" target="_blank" rel="noopener">back()</a> – Returns a reference to the last element in the vector最后的元素</li>
<li><a href="https://www.geeksforgeeks.org/vector-data-function-in-c-stl/" target="_blank" rel="noopener">data()</a> – Returns a direct pointer to the memory array used internally by the vector to store its owned elements.不接受任何参数，返回该向量的指针。</li>
</ol>
<h3 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h3><p><strong>Modifiers:</strong></p>
<ol>
<li><a href="https://www.geeksforgeeks.org/vector-assign-in-c-stl/" target="_blank" rel="noopener">assign()</a> – It assigns new value to the vector elements by replacing old ones重新分配（未被分配的就被删了，但是被分配的内存不变）</li>
<li><a href="https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/" target="_blank" rel="noopener">push_back()</a> – It push the elements into a vector from the back加一个括号内的元素到vector的最后</li>
<li><a href="https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/" target="_blank" rel="noopener">pop_back()</a> – It is used to pop or remove elements from a vector from the back.</li>
<li><a href="https://www.geeksforgeeks.org/vector-insert-function-in-c-stl/" target="_blank" rel="noopener">insert()</a> – It inserts new elements before the element at the specified position（在指定元素之前插入一个指定的元素<ul>
<li>在指定位置loc前插入值为val的元素,返回指向这个元素的<a href="notion://www.notion.so/iterators.html" target="_blank" rel="noopener">迭代器</a>,.insert(loc,val)</li>
<li>在指定位置loc前插入num个值为val的元素.insert(loc,num,val)</li>
<li>在指定位置loc前插入区间[start, end)的所有元素.insert(loc,locstart,locend)</li>
</ul>
</li>
<li><p><a href="https://www.geeksforgeeks.org/vectorclear-vectorerase-c-stl/" target="_blank" rel="noopener">erase()</a> – It is used to remove elements from a container from the specified position or range.</p>
<p> erase函数要么删作指定位置loc的元素,要么删除区间[start, end)的所有元素.返回值是指向删除的最后一个元素的下一位置的迭代器</p>
</li>
<li><p><a href="https://www.geeksforgeeks.org/vectorat-vectorswap-c-stl/" target="_blank" rel="noopener">swap()</a> – It is used to swap the contents of one vector with another vector of same type. Sizes may differ.(交换两个同类型向量的内容）</p>
</li>
<li><a href="https://www.geeksforgeeks.org/vectorclear-vectorerase-c-stl/" target="_blank" rel="noopener">clear()</a> – It is used to remove all the elements of the vector container函数删除当前vector中的所有元素.</li>
<li><a href="https://www.geeksforgeeks.org/vector-emplace-function-in-c-stl/" target="_blank" rel="noopener">emplace()</a> – It extends the container by inserting new element at position用法是该函数返回一个迭代器，该迭代器指向新插入的元素。（在面向对象时emplace会更好，对于一般的数据，都可，而insert的可用性更强）.emplace(loc,val)</li>
<li><a href="https://www.geeksforgeeks.org/vectoremplace_back-c-stl/" target="_blank" rel="noopener">emplace_back()</a> – It is used to insert a new element into the vector container, the new element is added to the end of the vector插入元素到最后</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>各种排序方式的汇总及学习（只更了冒泡排序）</title>
    <url>/2019/11/09/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%9A%84%E6%B1%87%E6%80%BB%E5%8F%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8F%AA%E5%86%99%E4%BA%86%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<h3 id="首先了解排序："><a href="#首先了解排序：" class="headerlink" title="首先了解排序："></a>首先了解排序：</h3>  <a id="more"></a>
<h6 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a><strong>排序的定义</strong></h6><p>假设含有n个记录的序列为{r1,r2,…,rn}，其相应的关键字分别是{k1,k2,…,kn}，需要确定1,2,…,n的一种排列p1,p2,…,pn，使其相应的关键字满足kp1&lt;=kp2&lt;=…&lt;=kpn 非递减（或非递增）的关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,…,rpn}，这样的操作就称为排序[1]。</p>
<p>简单来说，排序就是使输入的序列变成符合一定规则（关键字）的有序序列（非递减或非递增）。大多数遇到的排序问题都是按数据元素值的大小规则进行排序的问题。所以本文为了方便起见，只讨论数据元素值大小比较的排序问题。</p>
<h6 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a><strong>排序的稳定性</strong></h6><p>假设ki=kj（1&lt;=i&lt;=n，1&lt;=j&lt;=n，i!=j），且在排序前的序列中ri领先于rj（即i&lt;j）。</p>
<ul>
<li>如果排序后ri仍领先于rj，则称所用的排序方法是稳定的；</li>
<li>反之，若可能使得排序后的序列中rj领先于ri，则称所用的排序方法是不稳定的。</li>
</ul>
<p>简单来概括稳定和不稳定[2]：</p>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b前面；</li>
<li><strong>不稳定</strong>：如果a原本在b前面，而a=b，排序之后a可能在b的后面。</li>
</ul>
<h6 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a><strong>时间和空间复杂度</strong></h6><ul>
<li><p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反应当n变化时，操作次数呈现什么规律</p>
</li>
<li><p><strong>空间复杂度</strong>：算法在计算机内执行时所需要的存储空间的容量，它也是数据规模n的函数。<br><img src="https://img-blog.csdnimg.cn/20191109144007487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTcyNDA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）："><a href="#1-冒泡排序（Bubble-Sort）：" class="headerlink" title="1. 冒泡排序（Bubble Sort）："></a>1. 冒泡排序<strong>（Bubble Sort）</strong>：</h2><h4 id="1-1-一般的冒泡排序："><a href="#1-1-一般的冒泡排序：" class="headerlink" title="1.1 一般的冒泡排序："></a>1.1 一般的冒泡排序：</h4><p><strong>基本思想</strong></p>
<p>比较相邻的两个元素，将值大的元素交换到右边（降序则相反）</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在<strong>最后的元素应该会是最大的数</strong>；</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个；</p>
</li>
<li><p>重复步骤1~3，直到排序完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,i,j;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>	<span class="hljs-keyword">int</span> a[n]; <br>	<span class="hljs-comment">//input</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-comment">//bubble sort </span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-comment">//从第一个到倒数第二个</span><br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>;j++)&#123;<span class="hljs-comment">//从第一个倒数第二个</span><br>			<span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>				<span class="hljs-keyword">int</span> t=a[j];<br>				a[j]=a[j+<span class="hljs-number">1</span>];<br>				a[j+<span class="hljs-number">1</span>]=t;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//output</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>比如有n个元素，那么第一次比较迭代，需要比较n-1次（因为是相邻成对比较，最后一个元素没有与下一个相邻比较的对象，所以是n-1次），此次迭代完成后确定了最后一个元素为最大值；第二次比较迭代，需要比较n-2次，因为第一次迭代已经确定好了最后一个元素，所以不再需要比较；…；第 i次比较迭代，需要比较n-i次，此时确定后面i个元素是有序的较大元素；…；第n-1次比较迭代，需要比较n-(n-1)次，此时完成冒泡排序操作。</p>
<p>原始的冒泡排序是<strong>稳定排序</strong>。由于该排序算法的每一轮要遍历所有元素，轮转的次数和元素数量相当，所以时间复杂度是 o(n^2) = (n-1)*(n-1)</p>
<p><img src="https://img-blog.csdnimg.cn/20191109144459488.gif" alt="在这里插入图片描述"></p>
<p>代码使用双循环来进行排序。外部循环控制所有的回合，内部循环代表每一轮的冒泡处理，先进行元素比较，再进行元素交换。</p>
<h4 id="1-2优化版冒泡排序："><a href="#1-2优化版冒泡排序：" class="headerlink" title="1.2优化版冒泡排序："></a>1.2优化版冒泡排序：</h4><p>优化结果：<strong>解决了在已经调整好顺序后继续循环的问题。</strong></p>
<p>优化方向：如果我们能<strong>判断出数列已经有序（最后几个数字），并且做出标记（但仅仅标记了数列是有序的）</strong>，剩下的几轮排序就可以不必执行，提早结束工作。</p>
<p> 代码思路：代码做了小小的改动，利用布尔变量isSorted作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，说明数列已然有序，直接跳出大循环。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,i,j;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>	<span class="hljs-keyword">int</span> a[n]; <br>	<span class="hljs-comment">//input</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-comment">//bubble sort </span><br>	<span class="hljs-keyword">int</span> issort=<span class="hljs-number">0</span>;<span class="hljs-comment">//此处有变动</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>;j++)&#123;<br>			<span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>				<span class="hljs-keyword">int</span> t=a[j];<br>				a[j]=a[j+<span class="hljs-number">1</span>];<br>				a[j+<span class="hljs-number">1</span>]=t;<br>				issort=<span class="hljs-number">1</span>; <span class="hljs-comment">//此处有变动</span><br>			&#125;<br>		&#125;<span class="hljs-keyword">if</span>(issort==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//此处是最后一处变动了，，此处解决的是大循环的结束条件。</span><br>	&#125;<br>	<span class="hljs-comment">//output</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-3再次优化版冒泡排序："><a href="#1-3再次优化版冒泡排序：" class="headerlink" title="1.3再次优化版冒泡排序："></a>1.3再次优化版冒泡排序：</h4><p>这个问题的关键点在哪里呢？关键在于对数列<strong>有序区</strong>的界定。</p>
<p><strong>按照现有一般的逻辑</strong>，有序区的长度和排序的轮数是相等的。比如第一轮排序过后的有序区长度是1（为最后一个），第二轮排序过后的有序区长度是2 ….</p>
<p>实际上，数列真正的有序区可能会大于这个长度，比如如果后面5个元素实际都已经属于有序区。因此后面的许多次元素比较（这里是指在大循环）是没有意义的。</p>
<p>如何避免这种情况呢？我们可以在每一轮排序的最后，<strong>记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了</strong>。<br><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,i,j;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>	<span class="hljs-keyword">int</span> a[n]; <br>	<span class="hljs-comment">//input</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-comment">//bubble sort </span><br>	<span class="hljs-keyword">int</span> issort=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">int</span> tem=n<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">int</span> border=n<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;border;j++)&#123; <span class="hljs-comment">//此次更改的是小循环的结束条件。</span><br>			<span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>				<span class="hljs-keyword">int</span> t=a[j];<br>				a[j]=a[j+<span class="hljs-number">1</span>];<br>				a[j+<span class="hljs-number">1</span>]=t;<br>				issort=<span class="hljs-number">1</span>; <br>				tem=j;<span class="hljs-comment">//此时tem记录的是小循环里的最后一次交换	</span><br>					<span class="hljs-comment">//极有可能与大循环冲突。 	</span><br>			&#125;<br>		&#125;<br>		border=tem;<br>		<span class="hljs-keyword">if</span>(issort==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-comment">//output</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p><strong>总结：此次优化是将大循环，小循环的结束条件进行修正。</strong></p>
<p>本文来自一些微信公众号与csdn和自己的总结与修改（抱歉，我找不到文章链接了），在此表示感谢，如有侵权，联系立删。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>干饭小助手 Meal_Alter_Bot</title>
    <url>/2022/05/10/%E5%B9%B2%E9%A5%AD%E5%B0%8F%E5%8A%A9%E6%89%8BMeal_Alter_Bot/</url>
    <content><![CDATA[<p>A bot to forward the QQ message to user,then send it to your bot.</p>
<p>Meal_Alter_Bot 项目是基于 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener"></a><a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">https://github.com/Mrs4s/go-cqhttp</a> 项目进行开发的QQ机器人，通过监控聊天信息，获取干饭通知，通过 ESP32 Wi-Fi 通信功能，控制设备进行蜂鸣器提醒。<br>  <a id="more"></a><br>其主要的功能实现来源于 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener"></a><a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">https://github.com/Mrs4s/go-cqhttp</a> 项目所开发的机器人，该程序能够通过模拟登录自己的 QQ 帐号，将其作为机器人，对 QQ 的各种消息和提醒进行监控于处理，还能将其给进一步发送出去，实现了 QQ 不开源，不开放 API 状态下的开放功能。（当然，此项目可能违反 Tencent 相关用户协议，存在封号可能，不建议将大号作为机器人）</p>
<p>在将 QQ 所获取的消息进行监控后，通过 Python 功能便携 Flask 应用，实现对于 QQ 消息的实时监控，并二次筛选处自己所需要的内容，进而通过 MQTT 协议，发送的执行器，进行设备的控制。</p>
<h2 id="所需环境：Python3"><a href="#所需环境：Python3" class="headerlink" title="所需环境：Python3"></a>所需环境：Python3</h2><h2 id="机器人搭建"><a href="#机器人搭建" class="headerlink" title="机器人搭建"></a>机器人搭建</h2><p>指的是将自己的 QQ 作为机器人部署在服务器或个人电脑上</p>
<p>（支持 Win/Linux ）</p>
<p>这里采用的框架和应用是 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">go-cqhttp</a>，是当下为数不多可供使用的 QQ 机器人（Tencent封杀使其越来越封闭）</p>
<h3 id="新建文件夹，并进入对应目录"><a href="#新建文件夹，并进入对应目录" class="headerlink" title="新建文件夹，并进入对应目录"></a>新建文件夹，并进入对应目录</h3><h3 id="下载相应文件："><a href="#下载相应文件：" class="headerlink" title="下载相应文件："></a>下载相应文件：</h3><p>Linux 下通过命令行，下载合适的安装包到自己的机器上</p>
<p><code>wget &lt;https://github.com.cnpmjs.org/Mrs4s/go-cqhttp/releases/download/v1.0.0-beta4/go-cqhttp_linux_amd64.tar.gz</code>&gt;</p>
<p>而 Windows 用户可以直接在浏览器上进行下载，<a href="https://github.com/Mrs4s/go-cqhttp/releases/tag/v1.0.0-rc1" target="_blank" rel="noopener">下载地址</a></p>
<p>注意区分不同版本（Linux 也可以由用户下载好之后，直接上传到服务器上）</p>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>Linux 下命令如下</p>
<p><code>tar -zxvf go-cqhttp_linux_amd64.tar.gz</code></p>
<p>Win 下请按照自己的解压工具进行解压</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>Linux 下命令如下</p>
<p><code>chmod +x go-cqhttp</code></p>
<p>Win 下建议使用管理员权限 打开 go-cqhttp</p>
<h3 id="初始化程序"><a href="#初始化程序" class="headerlink" title="初始化程序"></a>初始化程序</h3><p>当然，现在还不需要去打开运行，我们可以先打开 config.yml 文件，进行配置</p>
<p>如果没有运行过 go-cqhttp 是没有此文件的，可采用本 Github 所提供的文件进行配置。</p>
<p>需要配置的内容不多，本项目只更改了</p>
<ul>
<li>第四五行的QQ帐号（纯数字即可），密码（注意单引号）</li>
<li>倒数第八行的 URL 地址，将端口发送到 127.0.0.1:10001 进行通信</li>
</ul>
<p>用户可以直接第一次运行程序后，自行进行修改上述内容进行应用。</p>
<p>如果不添加QQ帐号和密码到 config.yml 文件中，第一次登录后 会使用扫码登录，但是我使用此选项失败了~</p>
<p>接下来就是第一次运行程序，进行初始化了</p>
<p>Linux 下通过该命令打开</p>
<p><code>./go-cqhttp</code></p>
<p>如果是第一次打开，会让你选择采用什么方式运行，这里选择 http 也就是 1 即可</p>
<p>等待其配置完成</p>
<p>就会自动转发 信息到接口处</p>
<p>此时使用 Ctrl + c 便可以关闭程序。</p>
<h3 id="运行-Python程序"><a href="#运行-Python程序" class="headerlink" title="运行 Python程序"></a>运行 Python程序</h3><p>Python 的环境要求是 Python3</p>
<p>首先，打开 <a href="http://app.py" target="_blank" rel="noopener">app.py</a> ，进行修改</p>
<p>这里需要修改的也就是自己的 MQTT 服务器地址和所需要修改的关键词，过滤的群号，详见文件内注释说明。</p>
<p>在运行之前，我们还需要安装 Python 的相关库，这里用到了 paho.mqtt 和 flask</p>
<p>首先采用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip3 install paho.mqtt<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip3 install flask<br></code></pre></td></tr></table></figure>
<p>配置完成后，可以使用 python3 <a href="http://app.py" target="_blank" rel="noopener">app.py</a> 即可运行，该程序便会将需要的转发的内容发送到MQTT服务器的对应主题上。</p>
<p>在服务器上，我们往往采用 SSH 的方式进行连接，为避免关闭界面后，运行停止，我们可以采用命令nohup ~ &amp;将其挂起,</p>
<p>即使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nohup ./go-cqhttp &amp;<br>nohup python3 app.py &amp;<br></code></pre></td></tr></table></figure>
<p>其对应的终端输入日志将保存在.out文件中</p>
<h3 id="配置-ESP32"><a href="#配置-ESP32" class="headerlink" title="配置 ESP32"></a>配置 ESP32</h3><p>准备一个 ESP32 开发板，正常的型号就可以，这里仅仅采用了 WiFi，运用了 MQTT 的库文件，详细代码参考 本项目中的 ESP32_Meal_Alter_Bot 文件夹中的内容即可。</p>
<p>本 ESP32 项目采用 Vscode +platformio 进行开发</p>
<p>用户可以自行将 ESP32_Meal_Alter_Bot/src 中的主程序复制到 Arduino 程序中进行开发，对于 ESP32 的相关环境配置，网络中已经有很多，不再赘述，请善用百度。</p>
<p>对于 ESP32 的功能和代码修改介绍： 该开发板所控制的外部设备有且仅有一个，就是蜂鸣器，通过及其简单的高低电平使其发声，预警提醒。 在代码中，首先修改前面的 Wi-Fi 帐号密码，其次是 MQTT 服务器的地址，需要与上述一致。 在本代码中，用户可以进一步的通过 ESP32 的代码修改，进行二次过滤关键词，也可以修改不同的 MQTT 主题，进行应用。</p>
<p>将ESP32 代码进行编译烧录后进行上传，在测试成功后，即可正常使用。</p>
<p>因为疫情，被隔离在校，闲暇之余，手边恰好有相关的设备和单片机，于是便开始动手实践，本项目中，比较困难的是QQ机器人的项目查找，之后的数据流转相对简单。<br>然而做好项目的第二天，疫情形式严峻了，就送饭上门了~</p>
<p>诚信而言，本次项目的许多内容都是基于互联网上的成熟模组进行搭建，极大的加速了开发者的开发速度，但次项目还有着许多的潜力可以去挖掘，不仅仅是机器人，更重要的是在每一个环节，我们都可以进行二次修改，如何应对高并发，如何形成集群？等等方向都是此项目的可升华之处，作为一个点灯项目，其到此为止吧。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ESP32</tag>
        <tag>flask</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>大数乘法</title>
    <url>/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p><em>使用java语言的int数组与StringBuffer来实现</em>。</p>
<p>日常中，我们使用java来计算两数乘法时，我们会在遇到一些比较大的数字计算时，便无可奈何(int不够大)，这时一般采用<strong>BigInteger</strong>的方法进行计算，但是该方法也有一定的限制，或者说，我们是可以去尝试去使用String来实现和表示大数乘法的效果。</p>
  <a id="more"></a>
<h2 id="编程思路："><a href="#编程思路：" class="headerlink" title="编程思路："></a>编程思路：</h2><p>首先我们要确定使用字符串后我们如何去实现我们的乘法计算，不妨我们回归竖式计算，进行模拟然后得出结果。</p>
<p>例如：37*46的计算过程，我们也可以这样计算：如下图。</p>
<ol>
<li><p><strong>先不考虑进位的问题</strong>，将两个<strong>数字</strong>相乘的结果当作一个个位数（不去进行进位，最后再依次进位，方便计算机操作，当然，方法多样，并不局限于此）</p>
<p><img src="/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/multiplyExample.png" alt></p>
</li>
<li><p>我们也可以发现上述规律a位数*b位数≤（a+b）位数</p>
<p>所以我们如果需要得到最后的位数的话，可以通过这个规律进行计算。</p>
</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先，我们采用由俭入繁的理念：从简单的开始，再到复杂：</p>
<ol>
<li><p>我们考虑的是两个正整数的大数乘法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>		String a = sc.nextLine();<br>		String b = sc.nextLine();<br>		<span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了，直接得到最后一行</span><br>		<span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br>		System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>				<span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>				s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//进位计算</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>				s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>				s[i]=s[i]%<span class="hljs-number">10</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>		StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>			ans.append(i);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>			ans.deleteCharAt(<span class="hljs-number">0</span>);<br>		&#125;<br>		System.out.println(ans);<br>		sc.close();		<br>	&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>好的计算成功，那么如果有负数存在呢？</p>
<p>我们只需要加上如下的判断符号的代码即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断符号</span><br>		Boolean flag = <span class="hljs-keyword">true</span>; <br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br>			<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>			&#125;<br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>		&#123;<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法(有符号）</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>		<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>		String a = sc.nextLine();<br>		String b = sc.nextLine();<br>		System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br>		<span class="hljs-comment">//判断符号</span><br>		Boolean flag = <span class="hljs-keyword">true</span>; <br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br>			<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>			&#125;<br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>		&#123;<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br>		<span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br>		<span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>				<span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>				s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//进位计算</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>				s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>				s[i]=s[i]%<span class="hljs-number">10</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>		StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>			ans.append(i);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>			ans.deleteCharAt(<span class="hljs-number">0</span>);<br>		&#125;<br>		System.out.println(ans);<br>		sc.close();		<br>	&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最后：bugs："><a href="#最后：bugs：" class="headerlink" title="最后：bugs："></a>最后：bugs：</h2><p>在初步形成之后，还是有一些bug的比如乘数中含有0，那么就会报错。</p>
<p>所以要排除这一情况。（在判断符号前加入一个判断0即可）</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>		<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>		String a = sc.nextLine();<br>		String b = sc.nextLine();<br>		System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br>		<span class="hljs-comment">//判断0</span><br>		<span class="hljs-keyword">if</span>(a.equals(<span class="hljs-string">"0"</span>)||b.equals(<span class="hljs-string">"0"</span>))System.out.println(<span class="hljs-string">"0"</span>);<br>		<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">//判断符号</span><br>		Boolean flag = <span class="hljs-keyword">true</span>; <br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>				flag = <span class="hljs-keyword">true</span>;<br>			&#125;<br>			<br><br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>			&#123;<br>				a = a.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>			&#125;<br>		<span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>		&#123;<br>				b = b.substring(<span class="hljs-number">1</span>);<br>				flag =  <span class="hljs-keyword">false</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br>		<span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br>		<span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>				<span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>				s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//进位计算</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>				s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>				s[i]=s[i]%<span class="hljs-number">10</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>		StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>			ans.append(i);<br>		&#125;<br>		<span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>			ans.deleteCharAt(<span class="hljs-number">0</span>);<br>		&#125;<br>		System.out.println(ans);<br>		sc.close();	<br>		&#125;	<br>	&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>小记：一次普通循迹车大赛</title>
    <url>/2020/01/19/%E5%B0%8F%E8%AE%B0%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E5%BE%AA%E8%BF%B9%E8%BD%A6%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<p>记录点滴大赛。</p>
<p>起初，从一个小白走向机器人大赛，经过不少人的推荐（传说有奖），（瞎）报名了循迹机器人大赛。</p>
<p>循迹机器人（要做的）是：利用红外线感知黑色线路，并沿着其行进，赛道设计的有弯道，且需要考虑速度，因为时间越短越好。</p>
<p>嗯，需要硬件加算法呀。<em>要好好学习一下呀（笑）</em></p>
  <a id="more"></a>
<p>然而，半个月后报名结束，通知由于项目人数过多，主办方不再提供材料，由学生自行购买。。。</p>
<p>根据一份不完全清单在淘宝搜寻一段时间后，得到130的价格。</p>
<p>之后了解到要学习五一单片机，于是开始学习了解（其实以我们的比赛程度和技术，不用了解也是完全可以的2333）。</p>
<p>了解到有朋友已经用电烙铁烧坏一个小车了，而我们还没买材料，什么都不知道，还有点慌呢。</p>
<p>开始买买买！</p>
<p><img src="https://i.loli.net/2020/01/19/Z3ljYCMdxv1AV8D.jpg" alt="img"></p>
<p>与此同时，开始学习51单片机（下载资料。。。）</p>
<p><img src="https://i.loli.net/2020/01/19/lZvtMxAEuoIbQKh.jpg" alt="资料截图.jpg"></p>
<p><img src="https://i.loli.net/2020/01/19/hXLxk8vY2tNI6Rb.png" alt="Screenshot_2019-09-15-13-53-07-164_com.android.systemui.png"></p>
<p><img src="https://i.loli.net/2020/01/19/K1bSe2t348dGIO9.jpg" alt="Screenshot_2019-10-13-23-37-06-063_com.mxtech.videoplayer.pro.png"></p>
<p>对了，我甚至还在b站打开了经典影片（十天放弃单片机）：</p>
<p><img src="https://i.loli.net/2020/01/19/KC8bzsmTJl3QfUA.jpg" alt="郭天祥视频截图.jpg"></p>
<p>如你们所愿（截止发稿日期，我还没有打开看。。。：)）</p>
<p>数日后：部分零件到位：(赶在了双十一之前哦<img src="https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_04.png" alt="img">）</p>
<p><img src="https://i.loli.net/2020/01/19/AEbFSlJD8O1CqUm.jpg" alt="到货截图.jpg"></p>
<p>当然：学校也试图让我们懂一些什么。。。（不过，他好像失败了）</p>
<p><img src="https://i.loli.net/2020/01/19/lS9NwO83GHemqbV.jpg" alt="学校授课.jpg"></p>
<p>第一次去自己尝试拼板子，当然有很多差错，会有许多奇奇妙妙的出现，如发现少了一只紧固件（一个透明的小片，用来固定马达和板子的），结果最后一个马达就很难安装固定好，就（灵机一动）使用纸板来固定，从而引出无数bug。（但是第二天扒拉到了紧固件，就解决了，哎！）</p>
<p><img src="https://i.loli.net/2020/01/19/X3rdLxipOk7qjB2.jpg" alt="IMG_20191029_001928.jpg.JPG"><img src="https://i.loli.net/2020/01/19/cJ5K1mDlAT3znWZ.jpg" alt="IMG_20191029_002812.jpg.JPG"></p>
<p>最后因为小车是双层的（一般可以做单层的就足够了），就在安装好第二层后发现没有在第一层安装东西，于是又拆掉了（打算第二层为一个盖子）（内心很尴尬）。</p>
<p><img src="https://i.loli.net/2020/01/19/Zy9cJMQrzavUIig.jpg" alt="img"></p>
<p>中间有太多别的事情（好吧，是懒），小车在装线阶段，卡住了，一直没有进展，就放了好久（因为比赛日期还有一个月，全力向着deadline前进！）</p>
<p>然后小车单片机无法下载程序。。。</p>
<p>（检测不到单片机）（我一直担心是不是插反了，导致我的单片机烧毁了，最后发现还好不是~~<img src="https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_ios/u1F602.png" alt="img">）</p>
<p>询问学长才发现所购买的单片机的晶振消失了，淘宝商家又补拍给我。。（但是晶振太便宜，于是自己又下单4元（一半是运费）买了20个，庆幸，时间和双十一紧挨着）</p>
<p>小车代码阶段：在硬件拼装完成后，代码从网络上copy，但是出现了许多不适配的问题，紧接着经过不断地爆肝调试，在这个过程中也对代码不断理解。但是依次出现了小车的各种问题，但一步步在变好。</p>
<p><img src="https://i.loli.net/2020/01/19/gfGzL9QP2Vjw8Cp.jpg" alt="代码.jpg"></p>
<p>从只能原地转圈（四个轮子的驱动指令反了）；这个好搞！！！（许多小车因为这个原因，总是自动原地，爱的魔力转圈圈）</p>
<p><img src="https://i.loli.net/2020/01/19/5QJ36hz82GTcoX1.gif" alt="视频.gif"></p>
<p>再到有一个轮子是反转的（原因同上）；</p>
<p>再到只能走直线（红外感应器的代码对应的接口写错了）；</p>
<p>到只能够走弧度较大的弯道，到能够走直角（但此时不会走弧度较大的弯道了，因采用的是增加转向时的延迟，所以这个很难控制）；</p>
<p>最后比赛前夕，发现其他队伍都是参考学长们的代码，我们也就临时copy了一份，发现代码逻辑确实有很大的变化，思路更为清晰，解决了不少我们的一些困惑和更好的理解了小车的运行原理。（后来比赛时才知道，代码这个事情大多参赛组都是祖传代码。。。）</p>
<p>但copy的代码又有了一个新的问题，借来的代码（读书人的事情，对吧）是单驱动的，而我们的循迹小车采用的是双驱动，在面临这个问题时，我陷入了犹豫，是将循迹车的硬件（主要是接线）更改为单驱动，还是我自己多研究代码，将其改为双驱动呢？？？最后，在10min的漫长思考后，我打开了三份代码，打算突破一下自己，开始研究代码，半个小时后，增加了几个电机（驱动）的代码，将循迹的转向，偏移等进行了更改。最后将代码写入了小车，成功了。</p>
<p>但是，我们在自己制作的小车赛道中（就是用电工胶带铺设的黑线），遇到了红外感应器过高，感应很不灵敏，于是我们又通过增设铜柱，使之近乎摩擦地面而前行。好在方案可行。</p>
<p>最终能够实现跌跌撞撞的前行（过于灵敏），转向。此时已经是夜里12点多，8个多小时就要开始比赛了。（虽然还有很多队比我们的情况还要恶劣，但也有大神的）。</p>
<p>完成制作了！！！撒花。（代码就不放了，因为写的太烂了）</p>
<p><img src="https://i.loli.net/2020/01/19/S4TgnUGryxPE1du.jpg" alt="小车雪藏.jpg"></p>
<p>后来：</p>
<p><img src="https://i.loli.net/2020/01/19/rzEysN8TI1WqMhv.jpg" alt="表情包0基础.jpg"></p>
<p>输了。</p>
<p>是的。</p>
<p>自己亲手制作的小车在赛道上向观众们展示了灵车漂移，在一惊一乍中，在经过第一个点后，脱离了赛道。。。第二次机会测试的时候，小车直接冲出赛道（红外传感器有一个失灵了），视黑线于无物。这就是我很尴尬了。。。</p>
<p>当然，有不少小车真的很强，从他们小车的动作中，我看到了小车配件和组装的更多可能，以及小车代码的更多可优化方向。（其实就是我太菜了。。。哈哈！）</p>
<p><img src="https://i.loli.net/2020/01/19/Vo4QeY83bDFz1pL.jpg" alt="表情包太菜了.jpg"></p>
<p>最后，虽然输了比赛，但在比赛前，我们每天都坚持到午夜，经过一星期的努力（有些晚了，应该提前准备的），从无到有，将一堆没有灵魂的零件，通过自己的组装，写入代码，使其能够跌跌撞撞的跑下去，虽然他还是个憨憨，但是这不就像成长中的我们么？我们不也是像那个小车一样，在一次一次的失败，报错中，积累经验得到成长的吗？而且，在这次的准备中，我也积累和收获了不少的知识与感悟，在代码的思索中，更清楚的认识到面向过程的c语言是怎样的，在单片机编程方面应该注意些什么。自然，个人的收获是大于比赛的。</p>
<p><img src="https://i.loli.net/2020/01/19/ioVBnZK3uEmSb7G.jpg" alt="有收获"></p>
<p>那么？回过头来：此类比赛的意义究竟是什么呢？它既不能使社会的财富大大增加，也不能使得相关技术得到突破，甚至说他还有一点点浪费学生的时间和社会的资源，是么？我们是为了证明我们自己优秀而特地来为了获得奖项来证明我们自己的么？不，不是，或者说不完全是。</p>
<p><strong>在这类竞赛的过程中，更重要的是面向过程的，结果并不是出发的前提，我们选择了远方，不仅仅是因为目的地的美好，更是因为沿途的美丽风光不断地吸引着我们；同样，在acm，ccpc等的竞赛中获奖者并非多数，但能够有许多志同道合的朋友在一起，一起为了一个方向而努力，一个目标而前行，这样的奋斗过程才是幸福的吧。他们往往称自己痛并快乐着。是呀，能够在青春最美好的时间段里，去勇敢的追逐梦想，过程本身就是一件令人振奋的事，不是么？恰同学少年，风华正茂；愿诸位不忘初心，方得始终。</strong></p>
<p>感谢阅读，欢迎交流哦！</p>
]]></content>
      <categories>
        <category>record</category>
      </categories>
      <tags>
        <tag>xcu</tag>
      </tags>
  </entry>
  <entry>
    <title>打印沙漏（代码较详细）</title>
    <url>/2020/01/04/%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
    <content><![CDATA[<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
  <a id="more"></a>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">*****<br> ***<br>  *<br> ***<br>*****<br></code></pre></td></tr></table></figure>
<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs in">19 *<br></code></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs out">*****<br> ***<br>  *<br> ***<br>*****<br>2<br></code></pre></td></tr></table></figure>
<h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>哎，一言难尽，本以为是一道水题，却在写的时候发现写了好久，静不下心来。就抄了一下别人的。后来机缘巧合下，有自己重新坐下，冷静思考。经过许多次调试，有了一些结果。简单来说：就是大而化小。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n;<br>	<span class="hljs-built_in">cin</span>&gt;&gt;n;<br>	<span class="hljs-keyword">char</span> ch;<br>	getchar();<span class="hljs-comment">//中间的空格</span><br>	ch=getchar(); <br>	<span class="hljs-keyword">int</span> i,item=<span class="hljs-number">1</span>,sum=<span class="hljs-number">1</span>;<span class="hljs-comment">//sum为所用的符号个数，item表示最大的一行的符号个数。 </span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;sum&lt;=n;i++)<span class="hljs-comment">//这样写，最后sum一定大于n，会超出。 </span><br>	&#123;item+=<span class="hljs-number">2</span>;<br>	sum+=item*<span class="hljs-number">2</span>;<br>	&#125;<br>	sum-=item*<span class="hljs-number">2</span>;<span class="hljs-comment">//得到未超出时的所需符号个数sum，（返回上一次的sum） </span><br>	<span class="hljs-keyword">int</span> ans = n-sum;<span class="hljs-comment">//得到了最后的剩余的符号个数；（最后输出即可） </span><br>	<br>	<span class="hljs-comment">//接下来输出沙漏（首先不考虑输出下半个沙漏，先输出一半） </span><br>	<span class="hljs-keyword">int</span> t=item<span class="hljs-number">-2</span>;<br>	<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">//第一次是0第二行应该时1，依次类推。 </span><br>	<span class="hljs-keyword">for</span>(i=t;i&gt;<span class="hljs-number">0</span>;i-=<span class="hljs-number">2</span>)<br>	&#123;	<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;cnt;k++)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-comment">//输出空格 </span><br>		<span class="hljs-comment">//cnt++如果放在这里（判断中）会出现无限死循环！</span><br>		<span class="hljs-comment">//(第二行判断的时候会陷入死循环）</span><br>		<span class="hljs-comment">//放在最后就好了。 </span><br>		<br>	<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<span class="hljs-comment">//输出符号 </span><br>			<span class="hljs-built_in">cout</span>&lt;&lt;ch;<br>		&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>		cnt++;	<br>	&#125; <br>	<br>	<span class="hljs-comment">//下半个沙漏</span><br>	cnt--;<span class="hljs-comment">//是由于最后cnt又多加了1； </span><br>	 <span class="hljs-keyword">for</span>(i=<span class="hljs-number">3</span>;i&lt;=t;i+=<span class="hljs-number">2</span>)<span class="hljs-comment">//照着上面的反过来即可（但是第一项是1) </span><br>	 &#123;<br>	 	cnt--; <br>	 	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;cnt;k++)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-comment">//输出空格</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<span class="hljs-comment">//输出符号 </span><br>			<span class="hljs-built_in">cout</span>&lt;&lt;ch;<br>		&#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>	 &#125; <br>	 <span class="hljs-built_in">cout</span>&lt;&lt;ans;<span class="hljs-comment">//还有一个剩余个数需要输出。。。 </span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>方阵循环右移于其各种踩bug23333</title>
    <url>/2019/11/12/%E6%96%B9%E9%98%B5%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E4%BA%8E%E5%85%B6%E5%90%84%E7%A7%8D%E8%B8%A9bug23333/</url>
    <content><![CDATA[<p>又是元气满满地踩bug。。</p>
  <a id="more"></a>
<p>开始：思路是依照题意交换即可</p>
<p>然后：发现初始值会因其交换而改变，决定做两个二维数组一个储存一个赋值</p>
<p>接着：遇到溢出现象，猛然发现大bug，程序是从新数组中间的跑出来的，也就是说临界值之前的没有赋值。。。决定以if判断是否为最后一个，那么从头开始赋值。</p>
<p>最后：看似正确（看错了）其实是换位错位，和题目要求的结果都不一样。。。</p>
<p><img src="/2019/11/12/%E6%96%B9%E9%98%B5%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E4%BA%8E%E5%85%B6%E5%90%84%E7%A7%8D%E8%B8%A9bug23333/timg.jpg" alt="a"></p>
<p>陷入沉思！</p>
<p>然后打开百度。。</p>
<p>发现更改为%即可解决多次”进位”（姑且这么称作吧）。于是又修改了几次for循环的条件得以解决所有问题</p>
<p>我太难了。</p>
<p>下面是更改了许多次的代码。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> m,n,i,k,j;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;m,&amp;n);<br>	<span class="hljs-keyword">int</span> a[n][n];<br>	<span class="hljs-keyword">int</span> b[n][n];<br>	<span class="hljs-comment">//intput</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);	<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//nswitch</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-comment">//控制a数组从第一个开始输出。 </span><br>			<span class="hljs-comment">//其中，n-m+j是被赋值的列的位置，当其等于n-1时应为复制到该列最后一个，应切换！ </span><br>		<br>	<br>		b[i][(j+m)%n]=a[i][j];<span class="hljs-comment">//for临界及其之后的 </span><br>			<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//output</span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,b[i][j]);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);	<br>		<span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>得出：做题要多思考其逻辑顺序，不要人云亦云，将题目分解为自己已知，与未知，将其一步一步的以案例分析，从一到一百，通过实际例子，分析其规律于变化情况，进而改变过程。不断修正。</p>
<p>一定要搞清楚所有的过程，不能似是而非，否则一定会出现难以想象的bug。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>查找子串</title>
    <url>/2019/12/12/%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="6-15-查找子串-20分"><a href="#6-15-查找子串-20分" class="headerlink" title="6-15 查找子串 (20分)"></a>6-15 查找子串 (20分)</h2><p>本题要求实现一个字符串查找的简单函数。</p>
  <a id="more"></a>
<h1 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h1><p>char <em>search( char </em>s, char *t );<br>函数search在字符串s中查找子串t，返回子串t在s中的首地址。若未找到，则返回NULL。</p>
<h1 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h1><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXS 30</span><br><br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">char</span> *t)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadString</span><span class="hljs-params">( <span class="hljs-keyword">char</span> s[] )</span></span>; <span class="hljs-comment">/* 裁判提供，细节不表 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">char</span> s[MAXS], t[MAXS], *pos;<br><br>    ReadString(s);<br>    ReadString(t);<br>    pos = search(s, t);<br>    <span class="hljs-keyword">if</span> ( pos != <span class="hljs-literal">NULL</span> )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pos - s);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 你的代码将被嵌在这里 */</span><br></code></pre></td></tr></table></figure>
<h1 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h1><p>The C Programming Language<br>ram </p>
<h1 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h1><p>10</p>
<h1 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h1><p>The C Programming Language<br>bored</p>
<h1 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h1><p>-1</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>利用循环寻找到第一个相符合的字符，然后去判断是否为子字符串。<br>但此题目不可使用string.h较为麻烦，考验我们更多的是原理部分。</p>
<h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">char</span> *t)</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,i,j,m;<br>	<span class="hljs-keyword">int</span> flag = <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">'\0'</span>;i++)<span class="hljs-comment">//等效n = strlen(s)</span><br>	n=i;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;t[i]!=<span class="hljs-string">'\0'</span>;i++)<span class="hljs-comment">//等效m = strlen(t)</span><br>	m=i;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//i控制字符串s</span><br>		<span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>]==s[i])&#123;<span class="hljs-comment">//循环找到第一个相符合的字符</span><br>			flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//1代表找到了</span><br>		&#125;<br>		<span class="hljs-keyword">if</span>(flag = <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果找到第一个匹配的字符</span><br>			<span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<span class="hljs-comment">//j控制字符串t</span><br>				<span class="hljs-keyword">if</span>(t[j]==s[i+j])&#123;<span class="hljs-comment">//从第二个开始判断（第一个已经判断成功）</span><br>					flag =<span class="hljs-number">1</span>;<br>				&#125;<span class="hljs-keyword">else</span> &#123;<br>					flag =<span class="hljs-number">-1</span>;<span class="hljs-comment">//判断不成立时</span><br>				<span class="hljs-keyword">break</span>;	<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(flag ==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &amp;s[i];<span class="hljs-comment">//（在匹配成功的情况下）</span><br>		&#125;<br>	&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>查验身份证</title>
    <url>/2020/01/03/%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>概述STL</title>
    <url>/2020/02/28/%E6%A6%82%E8%BF%B0STL/</url>
    <content><![CDATA[<p>使用stl可以大大提高算法设计的效率和可靠性。</p>
  <a id="more"></a>
<ol>
<li>概述：</li>
</ol>
<p>STL 即Standard Template Library标准模板类库。</p>
<p>是标准c++库的子集</p>
<p>通用，强大</p>
<ol>
<li>构成：</li>
</ol>
<p>container：容器（储存元素）</p>
<p>algorithm：算法（操作元素）</p>
<p>iterator：迭代器（类似指针）</p>
<p>容器container:是一种数据结构</p>
<h2 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h2><p>1）</p>
<p><a href="https://jefine.github.io/2020/02/27/stlvector/">vector向量容器</a></p>
<p>2）</p>
<p>string 类似于上面的函数，有个别的例外。</p>
<p>3）</p>
<p>Dequen双端队列容器</p>
<p>是链表和字符串的调和产物，是多个连续的队列块。</p>
<p>4）list链表容器</p>
<p>是一个双链表类模板，只能使用++ - -来使用迭代器</p>
<h2 id="2-关联容器："><a href="#2-关联容器：" class="headerlink" title="2. 关联容器："></a>2. 关联容器：</h2><p>关联容器中每个元素都有一个关键字（key），通过key来储存和读取原损失，这些关键词可能于元素在容器中的位置无关，所以关联容器中不提供顺序容器中的front(),push_front(),pop_back()等操作，可以实现快速搜索（运用了分类的数据结构）</p>
<p>1）set（集合容器）/multiset（多重集合容器）</p>
<p>区别：</p>
<p>set中元素的关键字是唯一的，而multiset的关键字可以不唯一。<strong>默认情况下会对元素按照升序排列。</strong></p>
<p>而如果需要集合中的元素可以重复那么可以使用multiset。</p>
<p>又由于set没有重复的元素，所以如果添加的元素相同，那么不添加；而multiset可以有重复的元素，所以在删除的时候，会将其全部删除然后返回一个被删去元素个数。</p>
<p>特殊的函数有：</p>
<p>count（k）返回k在set中的次数。</p>
<p>find（k)如存在返回该元素的迭代器，否则返回end（）；</p>
<p>upper/lower_bound（k）返回关键字&gt;k或&gt;=k的第一个元素的迭代器</p>
<p>2）map（映射容器）/multimap（多重映射容器）</p>
<p>映射是实现关键字和值的各系的储存结构，可以用key来访问value</p>
<p>实现关键字和值关系的对应，而map是一一对应；而multimap是</p>
<p>同时map/multimap容器中的key和value是pair类型（不是像set一样两者都是key类型）pair是一个结构体声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pair</span><br>&#123;</span> T first;<span class="hljs-comment">//对应key值</span><br>  T second;<span class="hljs-comment">//对应value值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照key升序排列，以红黑树的形式。map支持【】；而multimap不允许【】（在使用map[key]的时侯如果不存在该key值那么就以其为关键字插入一个元素。</p>
<p>三种方式插入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mym;<br>    mym[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;<br>    mym.insert(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>));<br>    mym.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">'c'</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span>(it = mym.<span class="hljs-built_in">begin</span>();it!=mym.<span class="hljs-built_in">end</span>();++it)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="适配器容器："><a href="#适配器容器：" class="headerlink" title="适配器容器："></a>适配器容器：</h2><p>是基于其他的容器实现的容器，在底层容器实现适配器容器的功能，实际上可以将其作为一个一般的容器去使用。后进后出（只能从顶部出入）</p>
<p>1）stark 栈容器：</p>
<p>后进后出默认的底层容器是deque，（当然也可以指定其他的容器作为stark的底层容器）</p>
<p>只有简单的pop（）出栈；push（）入栈；empty（）；size（）</p>
<p>2）queue队列容器：先进先出。</p>
<p>插入的元素在队尾，pop（）出的元素在队首。</p>
<p>3)priority_queue(优先队列容器）</p>
<p>可随意顺序入队列但是一旦进入就会被排序（按照值的大小排序）</p>
<p>在这个里面使用pop（）来找到队伍最前面的（也是最大值的）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔的思考及解答</title>
    <url>/2020/02/10/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%80%9D%E8%80%83%E5%8F%8A%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<p>其实在汉诺塔问题之前，斐波那契数列的问题是个比较好解决的问题。</p>
<p>但是汉诺塔问题令我思考了一段时间。最后不断探索，有了一些思考。</p>
<p>沉下心，我们需要有一个大的格局。不断分解为小的问题。</p>
<p>递归问题么，不就是找到规律与出口么。</p>
  <a id="more"></a>
<p>汉诺塔（又称河内塔）问题：大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>我们不妨自己先试一试，如何将一个或三个盘子从a移动到c。</p>
<p>好的，那么总结一下<strong>规律</strong>，<strong>假设有n个盘子，我们就是借助一个柱子c，把a上的n-1个盘子放到b上，再把b上的n-1个盘子通过a移动到c上即可</strong>。（下图较复杂，简单看看就好）</p>
<p><img src="/2020/02/10/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%80%9D%E8%80%83%E5%8F%8A%E8%A7%A3%E7%AD%94/Untitled.png" alt="Untitled">好的，那么这一步的代码该怎么写呢？？？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">hanoi(n<span class="hljs-number">-1</span>,a,c,b);<span class="hljs-comment">//我们就是借助一个柱子c，把a上的n-1个盘子放到b上，</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"将%c移动到%c\\n"</span>,a,b);<br>hanoi(n<span class="hljs-number">-1</span>,b,a,c);<span class="hljs-comment">//再把b上的n-1个盘子通过a移动到c上即可。</span><br></code></pre></td></tr></table></figure>
<p>这样是不是就可以理解了。</p>
<p>好的，但是我们要给这个函数一个出口不然，他就会一直跑下去。。。（并且问我怎么知道的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//终止条件。</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"将%c移动到%c\\n"</span>,a,c);<span class="hljs-comment">//最后不就是把a上的最后一个放到c上，就可以了吧。</span><br><span class="hljs-comment">//我们不考虑别的。嘿嘿</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么综合起来就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> cnt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span> a,<span class="hljs-keyword">char</span> b,<span class="hljs-keyword">char</span> c)</span></span>&#123;<br>cnt++;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"将%c移动到%c\\n"</span>,a,c);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>hanoi(n<span class="hljs-number">-1</span>,a,c,b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"将%c移动到%c\\n"</span>,a,b);<br>hanoi(n<span class="hljs-number">-1</span>,b,a,c);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">char</span> a=<span class="hljs-string">'a'</span>,b=<span class="hljs-string">'b'</span>,c=<span class="hljs-string">'c'</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>hanoi(n,a,b,c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,cnt);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注释可以参考上面的哦。</p>
<p>链接：知乎上有一个有意思的答案，不妨一看：</p>
<p><a href="https://www.zhihu.com/question/24385418/answer/257751077" target="_blank" rel="noopener">https://www.zhihu.com/question/24385418/answer/257751077</a></p>
<p>bilibili也有一个不错的视频讲解：</p>
<p><a href="https://www.bilibili.com/video/av9830115?from=search&amp;seid=9898738544530212324" target="_blank" rel="noopener">https://www.bilibili.com/video/av9830115?from=search&amp;seid=9898738544530212324</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>简化的插入排序,详解附带一些基础讲解</title>
    <url>/2019/11/12/%E7%AE%80%E5%8C%96%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E8%AF%A6%E8%A7%A3%E9%99%84%E5%B8%A6%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>本题要求编写程序，将一个给定的整数插到原本有序的整数序列中，使结果序列仍然有序。</p>
  <a id="more"></a>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行先给出非负整数N（&lt;10）；第二行给出N个从小到大排好顺序的整数；第三行给出一个整数X。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出将X插入后仍然从小到大有序的整数序列，每个数字后面有一个空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><p> 5<br>1 2 4 5 7<br>3</p>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><p>1 2 3 4 5 7 </p>
<h1 id="代码在最后，此处是分析（写的很基础）（更新后为两种方法）"><a href="#代码在最后，此处是分析（写的很基础）（更新后为两种方法）" class="headerlink" title="代码在最后，此处是分析（写的很基础）（更新后为两种方法）."></a>代码在最后，此处是分析（写的很基础）（更新后为两种方法）.</h1><p><em>方法一的思路：定义数组=&gt; 找到插入值的位置=&gt; 将其后面的值转换位置=&gt; 将其插入，输出数组即可。</em></p>
<ol>
<li>首先，我们分析这道题，不难发现其在增加一个数后<strong>数组的大小发生了变化</strong>，所以我们在定义时直接int a【n+1】即可解决.</li>
<li>之后，我们遍历数组，将第二行输入的数字赋值到数组a【n+1】中即可。<br>接着我们就开始进行数据的调换，<del>但把大象装进冰箱的第一步是打开冰箱门</del>，即我们首先要<strong>找到x即插入值的位置</strong>应该在哪里。所以我们不难想到遍历数组，当其大于a[i]且小于a[i+1],（在此题中，保证了不重复，不会出现相等的情况）则记录下这个i，此为其位置！</li>
<li><p>再找到其位置后，我们可以开始转换吧，采用的思想是将其错位放置，即例如原本为第五个位置的数放置在第六个位置，将第四个位置的数放在第五个位置（顺序可不能反了啊2333）。<br>那么又会出现一个最大的问题！<strong>如何合理安排其转换</strong>？理解了思路后，其实实践中，我们就会发现许多问题，比如错位放置的时候，在哪里停止？从哪里开始？<br>在数组中，其第一个数从a[0]开始的，所以其开始的顺序是与正常的逻辑有所差异（即差一位）。所以我们<strong>先熟悉正常的，常见的，for循环而了解其循环的次数与特性。</strong><br> 1.当我们输入：（以题目中给出的参考输入值为准）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)或者<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br></code></pre></td></tr></table></figure>
<p> 那么我们会循环n（即n-0）次.由于我们使用的数组为保持一致性，我们还是使用第一种.</p>
</li>
</ol>
<p>2.在此题中，我们需要交换多少次呢？我们原来一共有n个数，后来变为n+1个数，我们从一般情况来看：当满足以下条件时我们可以得到其位置（即i）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(x&gt;a[i]&amp;&amp;x&lt;a[i+<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<p> 但我们也应注意到（载体给定的数据中）是第3个而且其i=2；此时我们输入的数据中，最后一个是i=n-1；<br> 在这里我们使用新的变量j来计数,并实现交换数组。（保持i的不变）在此循环中我们循环了(n-1)-i+1次即在i后面我们有这么多次交换。<strong>注意：a[i]不变，a[i+1]最终会进行x的赋值实现插入（被替换）</strong>。（此处类比上述1的特性）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(j=n<span class="hljs-number">-1</span>;j&gt;i;j- -);<br></code></pre></td></tr></table></figure>
<p>3.最后，我们考虑到将x插入，则一般情况解决，但是其中的特殊情况：比如x最小或最大在最前面或最后一个，则需要单独处理。 （有朋友指出给定的数字与有序数列中的相同时的bug，已经修复，而且我觉得题意最后要求排列后为有序数列，就不会给出这样的情况（也许是我错了，但最好加上等于号排除这种可能）。感谢提出问题并交流） </p>
<h3 id="真的代码！"><a href="#真的代码！" class="headerlink" title="真的代码！"></a>真的代码！</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,j,i,t,x;<br><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>		<span class="hljs-keyword">int</span> a[n+<span class="hljs-number">1</span>];<br><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//input</span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);<br><br>	<span class="hljs-keyword">if</span>(x&lt;a[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//special min </span><br>		<span class="hljs-keyword">for</span>(j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<span class="hljs-comment">//有多少个n移多少次！ </span><br>	 	a[j+<span class="hljs-number">1</span>]=a[j];<br>	 	&#125;a[<span class="hljs-number">0</span>]=x;<br>	&#125;<br> 	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;a[n<span class="hljs-number">-1</span>])a[n]=x;<span class="hljs-comment">//special max </span><br> 	<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//do</span><br>	 <span class="hljs-keyword">if</span>(x&gt;a[i]&amp;&amp;x&lt;=a[i+<span class="hljs-number">1</span>])&#123;<br>	 	<span class="hljs-keyword">for</span>(j=n<span class="hljs-number">-1</span>;j&gt;i;j--)&#123;<br>	 		a[j+<span class="hljs-number">1</span>]=a[j];<br>	 	&#125;a[i+<span class="hljs-number">1</span>]=x;<br>	 	<span class="hljs-keyword">break</span>;<br>	 &#125;<br>	&#125; <br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//output</span><br>		<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>	<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法二的思路：从后向前比较，如果x&gt;最后一个数字a[n-1]那么将a[n]赋值为x即可停止程序；如果x&lt;a[n-1]，那么我们将a[n-1]向后移一位，再继续循环比较。</p>
<ul>
<li>这样的好处是我们不必再去考虑一些特殊情况的处理</li>
<li>更加符合我们的逻辑习惯</li>
<li>代码也更为简单</li>
</ul>
<h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> n,j,i,t,x;<br><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>		<span class="hljs-keyword">int</span> a[n+<span class="hljs-number">1</span>];<br><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//input</span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);<br>	&#125;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);<br><br><span class="hljs-comment">//	if(x&lt;a[0])&#123;//special min </span><br><span class="hljs-comment">//		for(j=n-1;j&gt;=0;j--)&#123;//有多少个n移多少次！ </span><br><span class="hljs-comment">//	 	a[j+1]=a[j];</span><br><span class="hljs-comment">//	 	&#125;a[0]=x;</span><br><span class="hljs-comment">//	&#125;</span><br><span class="hljs-comment">// 	else if(x&gt;a[n-1])a[n]=x;//special max </span><br><span class="hljs-comment">// 	</span><br><span class="hljs-comment">//	else </span><br>	<span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//do</span><br>	 <span class="hljs-keyword">if</span>(x&gt;a[i])&#123;<br>	 a[i+<span class="hljs-number">1</span>]=x;<br>	 <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//找到x的位置并插入了</span><br>	 <span class="hljs-keyword">else</span> a[i+<span class="hljs-number">1</span>]=a[i];<span class="hljs-comment">//没找到，将大的数字向右移一位，继续比较。				 </span><br>	&#125; <br>	<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//output</span><br>		<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);<br>	<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法时间复杂度分析</title>
    <url>/2020/02/08/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90d%E5%A4%A7o/</url>
    <content><![CDATA[<h1 id="1-2-算法分析"><a href="#1-2-算法分析" class="headerlink" title="1.2 算法分析:"></a>1.2 算法分析:</h1><p><img src="https://i.loli.net/2020/02/08/vLTN4YAGuk5enzZ.png" alt="Untitled.png"></p>
<p>分为：事后统计法与事前分析估算法。</p>
<p>当然，第一种需要执行程序。而且存在着其他的因素来干扰结果。（与硬件有关）</p>
<p>所以采用<strong>事前分析评估法</strong>来分析算法的效率。</p>
  <a id="more"></a>
<h3 id="1-2-1算法时间复杂度分析："><a href="#1-2-1算法时间复杂度分析：" class="headerlink" title="1.2.1算法时间复杂度分析："></a>1.2.1算法时间复杂度分析：</h3><p>算法是由控制结构（顺序，分支，循环3种）和原操作（固有数据类型的操作）构成。</p>
<p>算法的的运行时间取决于两者的综合效果。o</p>
<p><img src="https://i.loli.net/2020/02/08/Y1yP4zWnVuaSC5K.png" alt="Untitled 1.png"></p>
<p>设n为算法中的问题规模，通常用大O、大Ω或  等三种渐进符号表示算法的执行时间与n之间的一种增长关系。</p>
<p><img src="https://i.loli.net/2020/02/08/lpOyIUejhMig8fS.png" alt="Untitled 2.png"></p>
<p>算法的执行时间主要与问题规模有关（即数据的多少有关）不妨将数据规模设为n；</p>
<p>分析问题规模n，找出<strong>基本语句</strong>，求出其运行次数f(n)。</p>
<p><em>基本语句：算法中的基本语句是执行次数与整个算法的执行次数程正比的语句，他对算法执行时间的贡献最大（最费时间），是算法中最重要的操作。（</em>上文的例子中：s+=a[i][i]便是基本语句。）</p>
<p>在此例子中：f(n)=n</p>
<p>这种<strong>时间衡量方法得出的不是具体的时间，而是一种增长趋势的度量（即加速度）</strong>。换而言之，这是在n足够大的情况下算法中基本语句的执行次数在渐进意义下的<strong>阶</strong>（我们可以将其理解为高阶，低阶这样的概念）</p>
<h3 id="大o表示法："><a href="#大o表示法：" class="headerlink" title="大o表示法："></a>大o表示法：</h3><p>大O表示法就是将算法的所有步骤转换为代数项，然后<strong>排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数。</strong></p>
<p>数学家可能会对我的“整体影响”假设有点沮丧，但是开发人员为了节省时间，这种方式更容易简化问题：</p>
<p><code>规律 Big-O
2 O(1) --&gt; 就是一个常数
2n + 10 O(n) --&gt; n 对整体结果会产生最大影响
5n^2 O(n^2) --&gt; n^2 具有最大影响</code></p>
<p>简而言之，这个例子所要表达的就是：我们只关注表达式中对表达式最终结果会产生最大影响的因子。（当常数非常大而n很小的时候并不是这样的，但是我们现在不要担心这种情况）。</p>
<p>下面是一些常用的时间复杂度以及简单的定义。更完整的定义可以翻阅<a href="https://en.wikipedia.org/wiki/Time_complexity" target="_blank" rel="noopener">维基百科</a>(英文）。</p>
<ul>
<li><strong>O(1)—</strong> 常量时间：给定一个大小为n的输入，概算法只需要一步就可以完成任务。</li>
<li><strong>O(log n)—</strong>对数时间：给定大小为n的输入，该算法每执行一步，它完成任务所需要的步骤数目会以一定的因子减少。</li>
<li><strong>O(n)—</strong>线性时间：给定大小为n的输入，该算法完成任务所需要的步骤直接和n相关（1对1的关系）。</li>
<li><strong>O(n²)—</strong>二次方时间：给定大小为n的输入，完成任务所需要的步骤是n的平方。</li>
<li><strong>O(C^n)—</strong>指数时间：给定大小为n的输入，完成任务所需要的步骤是一个常数的n次方（非常大的数字）。（c为常数）</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/TbekNSdj5A4lxhR.png" alt="Untitled 3.png"></p>
<p>从图中我们也可以看到不同的效率对于事件的影响是极大的。</p>
<p>在这个网站中我们也可以看到一些常见的算法效率：</p>
<p><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></p>
<p>那么？<strong>什么才是大o表示法</strong>：下面的链接讲述的很详细。</p>
<p><a href="https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/" target="_blank" rel="noopener">Analysis of Algorithms | Big-O analysis - GeeksforGeeks</a></p>
<p>综合来讲，大o表示法表示的是增长率的上界。</p>
<p>而且需要的是紧凑上界！！！</p>
<p><img src="https://i.loli.net/2020/02/08/w7SqJhMX29KZ45Y.jpg" alt="1 2.jpeg"></p>
<h3 id="大Ω表示法："><a href="#大Ω表示法：" class="headerlink" title="大Ω表示法："></a>大Ω表示法：</h3><p>大Ω符号用来描述增长率的下界，表示f(n)的增长最少像g(n) 增长的那样快，也就是说，</p>
<p>当输入规模为n时，算法消耗时间的最小值。 与大O符号对称，这个下界的阶越高，结果就越有价值，所以，对于10n~2+4n+2，Ω(n2)比Ω(n) 有价值。一个算法的时间用大Ω符号表示时，总是采用最有价值的g(n)表示，称之为“紧凑下界”或“紧确下界”。 </p>
<h3 id="大-表示法："><a href="#大-表示法：" class="headerlink" title="大  表示法："></a>大  表示法：</h3><p>大?符号比大O符号和大Ω符号都精确，</p>
<p>当且仅当g(n)既是f(n)的上界又是f(n)的下界。即当大o表示法和大Ω表示法相同时，即为该表示法。</p>
<p>最后：如下：分别表示3种符号</p>
<p><img src="https://i.loli.net/2020/02/08/1cKPxilrG96sEY2.png" alt="Untitled 4.png"></p>
<p>另附以下特性：</p>
<p><img src="https://i.loli.net/2020/02/08/oZBcmqPKAshu6UM.jpg" alt="1 2 1.jpeg"></p>
<p>额。</p>
<p>⑴ 找出算法中的基本语句；　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。　⑵ 计算基本语句的执行次数的数量级；　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。　⑶ 用大Ο记号表示算法的时间性能。　将基本语句执行次数的数量级放入大Ο记号中。　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p>
<pre><code>for (i=1; i&lt;=n; i++)       x++;  for (i=1; i&lt;=n; i++)      　for (j=1; j&lt;=n; j++)            x++;
</code></pre><p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(<em>n</em>2)，则整个算法的时间复杂度为Ο(n+<em>n</em>2)=Ο(<em>n</em>2)。　Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中<strong>Ο(log<em>2n</em>)、Ο(n)、 Ο(nlog<em>2n</em>)、Ο(<em>n</em>2)和Ο(<em>n</em>3)</strong>称为多项式时间，<strong>而Ο(<em>2</em>n )和Ο(n!)称为指数时间</strong>。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为<strong>P</strong>（Polynomial,多项式）<strong>类问题</strong>，而把后者（即指数时间复杂度的算法）称为<strong>NP（Non-Deterministic Polynomial, 非确定多项式）问题</strong>。 一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。</p>
<p>（4）<strong>在计算算法时间复杂度时有以下几个简单的程序分析法则:</strong></p>
<p>(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间</p>
<p>(2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则” <strong>求和法则</strong>:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n))) 特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))</p>
<p>(3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间</p>
<p>(4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则” <strong>乘法法则</strong>: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1<em>T2=O(f(n)</em>g(n))</p>
<p>(5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数</p>
<p><strong>（5）下面分别对几个常见的时间复杂度进行示例说明：</strong></p>
<p><strong>(1)、O(1)</strong></p>
<pre><code>Temp=i; i=j; j=temp;
</code></pre><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。<strong>注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</strong></p>
<p><strong>(2)、</strong>O(<em>n</em>2)** 2.1. 交换i和j的内容</p>
<pre><code>sum=0；                 （一次）  
for(i=1;i&lt;=n;i++)     （n+1次）   
for(j=1;j&lt;=n;j++) （n2次）      
sum++；            （n2次）
</code></pre><p>解：<strong>因为Θ(2<em>n</em>2 +n+1)=<em>n</em>2 （Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(<em>n</em>2)；</strong></p>
<p>2.2.</p>
<pre><code>for (i=1;i&lt;n;i++)   {    y=y+1;         ①      
for (j=0;j&lt;=(2*n);j++)          x++;         ②    }
</code></pre><p>解： 语句1的频度是n-1 语句2的频度是(n-1)<em>(2n+1)=2**</em>n<em>2<strong> -n-1 f(n)=2</strong></em>n<em>2<strong> -n-1+(n-1)=2</strong></em>n<em>2<strong> -2； 又</strong>Θ(2</em>n<em>2-2)=</em>n<em>2<strong>  该程序的时间复杂度T(n)=O(</strong></em>n<em>2<strong> ).　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 </strong>(3)、O(n)*</em></p>
<pre><code>a=0;  b=1;                      ①  
for (i=1;i&lt;=n;i++) ②  {     
s=a+b;　　　　③   
b=a;　　　　　④     
a=s;　　　　　⑤  }
</code></pre><p>解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n).</p>
<p><strong>(4)、O(log<em>2n</em>)</strong></p>
<pre><code>i=1;     ①  
hile (i&lt;=n)  i=i*2; ②
</code></pre><p>解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=<strong>log<em>2n</em></strong> 取最大值f(n)=<strong>log<em>2n</em></strong>, T(n)=O(<strong>log<em>2n</em></strong> )</p>
<p><strong>(5)、O(<em>n</em>3)</strong></p>
<pre><code>for(i=0;i&lt;n;i++)   {      
for(j=0;j&lt;i;j++)      {       
for(k=0;k&lt;j;k++)          
x=x+2;      }   }
</code></pre><p>解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)<em>1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(**</em>n<em>3)*</em></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>大o表示法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计单词数</title>
    <url>/2019/12/21/%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。</p>
  <a id="more"></a>
<p>现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2 ）。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共22行。</p>
<p>第11行为一个字符串，其中只含字母，表示给定单词；</p>
<p>第22行为一个字符串，其中只可能包含字母和空格，表示给定的文章。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从00 开始）；如果单词在文章中没有出现，则直接输出一个整数-1−1。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">To<br><span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> <span class="hljs-built_in">or</span> not <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> question<br></code></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">to</span><br>Did <span class="hljs-keyword">the</span> Ottoman Empire lose <span class="hljs-keyword">its</span> power <span class="hljs-keyword">at</span> <span class="hljs-keyword">that</span> <span class="hljs-built_in">time</span><br></code></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>
<h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>数据范围：</p>
<p>1≤1≤单词长度≤10≤10。</p>
<p>1≤1≤文章长度≤1,000,000≤1,000,000。</p>
<p>noip2011普及组第2题，洛谷新手村。</p>
<h5 id="本题思路："><a href="#本题思路：" class="headerlink" title="本题思路："></a>本题思路：</h5><ol>
<li><p>本来打算使用scanf(“%s”)来实现一个接着一个的单词输入，并strcmp判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;	<span class="hljs-keyword">char</span> s[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">char</span> p[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">char</span> t[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">char</span> x;<br>	<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);<br>	<span class="hljs-built_in">strcpy</span>(p,s);<br>	<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]&gt;=<span class="hljs-string">'A'</span>&amp;&amp;s[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">'Z'</span>)<br>	p[<span class="hljs-number">0</span>]=s[<span class="hljs-number">0</span>]+<span class="hljs-number">32</span>;<br>	<span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]&gt;=<span class="hljs-string">'a'</span>&amp;&amp;s[<span class="hljs-number">0</span>]&lt;=<span class="hljs-string">'z'</span>)<br>	p[<span class="hljs-number">0</span>]=s[<span class="hljs-number">0</span>]<span class="hljs-number">-32</span>;<br>	<br>	<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,t);<br>	x=getchar();<br>	<span class="hljs-keyword">while</span>(x!=<span class="hljs-string">'\n'</span>)&#123;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(t,s)||<span class="hljs-built_in">strcmp</span>(t,p))&#123;<br>		<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>		index=i;<br>		cnt++;<br>	&#125;i++;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,t);<br>	x=getchar();<br>&#125;<br>	<span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1"</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d"</span>,cnt,index);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是经过测试发现，%s后并不会将此单词的下一个单词计入，而是跳转到下一行，继续。与题意不符。而且单词的长度不确定。所以转变思路使用getchar一个一个判断。</p>
</li>
<li><p>最后采用以下思路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> sent,<span class="hljs-keyword">word</span>;<br><span class="hljs-keyword">int</span> lens,lenw,t,pos; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    getline(<span class="hljs-built_in">cin</span>,<span class="hljs-keyword">word</span>);  <br>    getline(<span class="hljs-built_in">cin</span>,sent);   <span class="hljs-comment">//字符串含有空格输入，不可以用cin，否则to me只能读到to </span><br>    lenw=<span class="hljs-keyword">word</span>.<span class="hljs-built_in">size</span>();   <br>    lens=sent.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenw;i++)<br>     <span class="hljs-keyword">word</span>[i]=<span class="hljs-built_in">toupper</span>(<span class="hljs-keyword">word</span>[i]);  <span class="hljs-comment">//转成大写 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lens;i++)<br>     sent[i]=<span class="hljs-built_in">toupper</span>(sent[i]);<br>   t=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=lens-lenw;i++)&#123;<br>   	<span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>;j&lt;lenw;j++)&#123;<br>   		<span class="hljs-keyword">if</span>(sent[i+j]!=<span class="hljs-keyword">word</span>[j])<span class="hljs-keyword">break</span>;<br>   		<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;sent[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">' '</span>)<span class="hljs-keyword">break</span>;<br>   	&#125;<span class="hljs-comment">//用于判断是否为逐字符合。</span><br>	   <span class="hljs-keyword">if</span>(j==lenw&amp;&amp;(sent[i+j]==<span class="hljs-string">' '</span>||i+j==lens))<br>           <span class="hljs-comment">//判断条件是否符合</span><br>       &#123;<br>	   	t++;<br>	   	<span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)pos = i;<br>	   &#125; <br>   	<br>   &#125;<br>   <br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;pos;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述答案的作者为: <a href="https://www.luogu.com.cn/user/8436" target="_blank" rel="noopener">Zehra</a>  </p>
</li>
</ol>
<p>以上即为解答，其中在寻找解题方案的过程中，我还发现许多大佬的许多种方案：比如状态机，根据不同的状态跑程序，但是略微有些麻烦，于是决定使用以上的方案。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>记录，发现</title>
    <url>/2019/11/06/%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="记录与发现"><a href="#记录与发现" class="headerlink" title="记录与发现"></a>记录与发现</h2><p>pta，acm，蓝桥等。</p>
]]></content>
  </entry>
  <entry>
    <title>蓝牙模块HC05的双设备简单配对通信</title>
    <url>/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>HC05采用的是AT指令进行配置， 采用串口通信进行数据传输。</p>
<p><a href="https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf" target="_blank" rel="noopener">指令集文档</a>可以任意在互联网中查找到。</p>
  <a id="more"></a>
<h2 id="如何完成手机蓝牙和模块通信"><a href="#如何完成手机蓝牙和模块通信" class="headerlink" title="如何完成手机蓝牙和模块通信"></a>如何完成手机蓝牙和模块通信</h2><p>电源是5V，同时采用CL/LF</p>
<p>连接之后，先通过</p>
<p>AT+ROLE=0</p>
<p>将其设置为从模式（slave），即可匹配(1234)</p>
<p><strong>注意</strong>：</p>
<ol>
<li>HC05，VCC接入3.3V可能没有反应，应连到5V</li>
<li>模块和电源相连时刻，有两种方法进入AT指令状态：<ol>
<li>提前一直按下HC-05上的按键，直到其灯闪烁为缓慢亮起，即可松开</li>
<li>将EN引脚置高（3.3V即可），但需要注意EN为高电平是HC05不能正常工作，只有将EN调为低电平，HC05恢复</li>
</ol>
</li>
<li>波特率需要一致，建议统一38400</li>
<li>模块所有AT指令需要加上换行符号否则无效（即选择CR/LF），且尽量大写</li>
</ol>
<p><a href="https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html" target="_blank" rel="noopener">https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html</a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SoftwareSerial</span>.</span></span>h&gt;<br><br><span class="hljs-comment">// Pin3为RX，接HC05的TXD</span><br><span class="hljs-comment">// Pin2为TX，接HC05的RXD</span><br>SoftwareSerial <span class="hljs-constructor">BT(10, 11)</span>;<br><span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span>;<br><span class="hljs-built_in">int</span> ledPin=<span class="hljs-number">13</span>;<br><br>void setup<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>println(<span class="hljs-string">"BT is ready!"</span>);<br>  <span class="hljs-comment">// HC-05默认，38400</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);<br>  pin<span class="hljs-constructor">Mode(<span class="hljs-params">ledPin</span>, OUTPUT)</span>;<br>  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;<br>  delay(<span class="hljs-number">500</span>);<br>  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;<br>&#125;<br><br>void loop<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>read<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>print(<span class="hljs-keyword">val</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>read<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>print(<span class="hljs-keyword">val</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'1'</span>)<br>      &#123;<br>    <span class="hljs-comment">// 返回到手机调试程序上</span><br>    <span class="hljs-comment">// 此时的蓝牙状态应该正常模式，而不是调试模式</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--high\n"</span>);<br>    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;<br>      &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'2'</span>)<br>      &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--low\n"</span>);<br>    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="双蓝牙模块连接（主从模式）"><a href="#双蓝牙模块连接（主从模式）" class="headerlink" title="双蓝牙模块连接（主从模式）"></a>双蓝牙模块连接（主从模式）</h3><p>一个通过连接PC由串口通信（模拟一个设备的指令操作）</p>
<p>另一个采用Arduino进行点灯来作为从设备的响应动作</p>
<p>首先需要将其配置</p>
<p>这里首先采用较为安全的固定地址相连接：</p>
<ol>
<li><p>将主设备调试（测试能否正常工作）</p>
<p>AT</p>
<p>如果不能，可能是串口波特率问题</p>
</li>
</ol>
<p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled.png" alt="Untitled"></p>
<ol>
<li><p>调整设备通信波特率</p>
<p>查看波特率：</p>
<p>AT+UART?</p>
</li>
</ol>
<p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 1.png" alt="Untitled 1"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">发现波特率不一致为<span class="hljs-number">9600</span>时进行更改，默认状态下就是两个波特率，正常模式下就是<span class="hljs-number">9600</span>，这里我们将其更改为<span class="hljs-number">38400</span>方便调试，当然也可能会带来一定的问题。<br></code></pre></td></tr></table></figure>
<p>更改波特率：</p>
<p>AT+UART=38400,0,0</p>
<ol>
<li><p>调整主从设备模式</p>
<p>AT+ROLE=1</p>
</li>
<li><p>调整连接模式：</p>
<p>AT+CMODE=0</p>
</li>
<li><p>绑定从机：</p>
<p>在获取到从机的address之后（查询从机地址指令AT+ADDR?），我们进行绑定：</p>
</li>
</ol>
<p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 2.png" alt="Untitled 2"></p>
<p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 3.png" alt="Untitled 3"></p>
<p><strong>注意</strong>：此处将冒号，替换成了逗号（英文状态下的逗号）</p>
<p>最后，（<del>莫名</del>）成功了，刚开始连接上后，无法正常通信，重启了就好了。</p>
<p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 5.png" alt="Untitled 5"></p>
<p>从机代码较为简单：</p>
<p>在对芯片作简要的波特率修正和查询addr之后采用Arduino 编程即可,代码同上不用修改。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本次的实验中，我们通过PC端连接一个蓝牙模块作为主设备（master）来通过串口发送数据，通过另一个 HC-05 传递数据，进而使得另一边的Arduino设备实现点灯功能。</p>
<p>主要涉及了串口收发以及对多串口应用的理解，在Arduino和PC通信（下载线）的同时又通过另一个串口和HC05通信，两串口间的数据传递以及在PC屏幕上的数据呈现，要求了我们对于不同串口的特点的理解：即该串口Print将会到何处，该串口Receive将会收到谁的，我们如何呈现到PC（即将PC和设备相连的串口进行发送或者说转发），从而进一步熟悉了数据的流动特点。 </p>
<p>串口的首发，乃至于说数据包的收发，可以参考另一个<a href="https://github.com/jefine/51MCU_course_design" target="_blank" rel="noopener">WiFi项目的串口收发</a>，也可看出串口通信在实际的物联网通信应用中十分广泛。</p>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>HC05</tag>
      </tags>
  </entry>
  <entry>
    <title>输出全组合二进制</title>
    <url>/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<p>这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。</p>
  <a id="more"></a>
<p>首先：辨析一下排列和组合的区别。</p>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列： </p>
<script type="math/tex; mode=display">
\frac{n!}{(n-k)!}</script><p>组合：</p>
<script type="math/tex; mode=display">
\frac{n!}{(n-k)!*k!}</script><p>可以看出排列的数目<strong>大于等于</strong>组合的数目，以及他们的计算方式如上图。公式来源详见<a href="https://zhuanlan.zhihu.com/p/41855459" target="_blank" rel="noopener">解析链接</a>，这很快帮助你回忆如何计算。</p>
<hr>
<p>回归题目：</p>
<p>n个元素的子集一共有 $2^n$个（从下面的对应关系中的二进制数也可看出的确是$2^n$)</p>
<p>那么他们此间的对应关系是这样的：</p>
<script type="math/tex; mode=display">
\begin{Vmatrix}
子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\
二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\
对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\
\end{Vmatrix}</script><p>这个神奇的的排列规律是我们进行下面编程的理论（可以从二进制看子集与十进制）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n=<span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//解释一下1&lt;&lt;n是位运算，结果是2^n</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&amp; (<span class="hljs-number">1</span>&lt;&lt;j))<span class="hljs-comment">//其中i只在第一次空集的时发挥作用。</span><br>            <br>            <span class="hljs-comment">//这里巧妙地运用了二进制的知识，并且运用位运算的性质，得到结果</span><br>            <br>            <span class="hljs-built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">" "</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>刚开始，觉得这个输出很神奇，直接输出了n个数字的所有集合（还按照一定的顺序），代码还十分简洁。</p>
<p>其中两个for循环中的if判断可谓是亮点了。</p>
<p>那么究竟是什么意思呢，记住这里还要会回顾一下那个表格了：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">if (<span class="hljs-name">i</span> &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure>
<p>首先明确一下 <strong>“&amp;”：<em>与</em>， 即在二进制中 </strong>同一为一（取每一位二进制的数字，两者均为1时为1）：</p>
<p>例如 0001 &amp; 0011为 1；</p>
<p>​        0010 &amp;  0001为0。</p>
<p>此行代码中的’ i ‘指的是二进制数中1的个数，可以发现在二进制中第一次i==0，而二进制数中不含1的只有空集，与结果相对应；</p>
<p>接着我们分析<strong>i==1</strong>时刻，判断条件其实可以替换为（0001 &amp; ( i&lt;&lt;j )),这是说明只有二进制数最后一位为1的才能呵前面$1_{(10)}$或者说$0001_{(2)}$相 “与&amp;” 为真。那么我们可以看出只有1 3  5 7这样的奇数才满足尾数为1，才能使得条件成立。BUT我们分析一下判断条件里的另一个变量1&lt;&lt;j，代表的是$2^n$，也就是说只有j==0的时候，才成立，这也就是第二行结果“0”的来历；</p>
<p>同理我们可以分析出<strong>i==2</strong>，即二进制的0010的时候只有j==1的时候才成立；</p>
<p><strong>i==3</strong>的时候，即左边为$0011_{(2)}$的时候这个时候只要是 在最后一位为一或者倒数第二位数字是一的二进制数即可，也就是说 十进制的0，1，3，5，7都可成立。但是 要注意的是 （i&lt;&lt;j)只能为十进制的$2^n$,所含的奇数只有1。所以除0，1外的j均不成立。</p>
<p>经过上面的分析我们<del>不得不</del>对代码的正确性给予了肯定，但好像还是不太清楚为什么能够这样做。</p>
<p>那我们不妨回首二进制。</p>
<p>不难发现，我们最终并没有用到3，4，5，6，7这样的十进制数字（尽管他们在上表中有所对应，但那也不过是各种情况的编号罢了，），只是用了0，1，2这恰好是[0,n)的范围内的数字。大胆推测 只有当i的数字越大那么在j中二进制中的1 出现的概率越大，（tips，$0111_{(2)}$恰好是7，二进制中的1的个数是（2+1）个1 emm~）。例如$7_{(10)}$ 对应$0111_{(2)}$那么他就可以有三个数字的集合成立了（果然是012）</p>
<p><del>上面一段有点饶头，仔细想想，都是对的，但似乎没什么用~可以无视</del>~~</p>
<p>自己在不断探索的过程中，仍能够不断的发现二进制的奇妙用途，和神奇1 的对应。此题还需慢慢回味。</p>
<hr>
<p>​    数日后，再次回顾此代码，发现有着许多的新的感悟：之前不太明白的地方都一一揭开：</p>
<p>首先就是</p>
<script type="math/tex; mode=display">
\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制(i)&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><p>哈哈，这个和上图的有什么区别呢？<del>并没有</del>，只是多了一个标识i</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure>
<p>回顾代码：不难看出其实对于作者的行为我<del>们</del>是有一些困惑的。为什么要这样做？</p>
<p>那我们不妨解释一下i和j的作用好了</p>
<p><strong>i</strong>  :其实对应的是上表中的对应的十进制：也就是说，我们将i循环了$n^2$次，其实就是恰好我们将这n个子集打印出来。</p>
<p><strong>j</strong>  :其实是二进制的从低到高位依次赋值1，并判断是否&amp;，1&lt;&lt;j 其实就是 $2^j$ 次方wow，当j为0时其实就是二进制的最后一位为1，j=1时判断倒数第二位是否为1。那么判断的另一个对象是谁呢？当然是i。</p>
<p>每一个i的二进制都不相同，我们就可以依次利用j来判断该位上是否有数字有的话就把j输出出去，j是[0,n)所以可以利用二进制完美地实现所有子集的输出。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>L1-006 连续因子</title>
    <url>/2020/01/02/%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<p>一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p>
  <a id="more"></a>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数 N（1&lt;N&lt;231）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 <code>因子1*因子2*……*因子k</code> 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><p>630</p>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><p>3<br>5<em>6</em>7</p>
<p>思路为从2开始累乘（加1），紧接着就判断是否乘积是其因子<br>如果是，那么记录下来长度，开始的i；<br>一直到乘积大于n停止；<br>然后使乘积（prd）等于1；i++； </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-comment">//简写 ，使用long long更好 </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ll n;<br>	<span class="hljs-built_in">cin</span>&gt;&gt;n;<br>	ll prd;<span class="hljs-comment">//是乘积（product） </span><br>	<span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,len=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(n);i++)&#123;<span class="hljs-comment">//sqrt是为了最后一个点过去（减少计算量） </span><br>		prd=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;prd&lt;n;j++)&#123;<br>			prd*=j;<br>			<span class="hljs-keyword">if</span>(n%prd==<span class="hljs-number">0</span>&amp;&amp;j-i+<span class="hljs-number">1</span>&gt;len)&#123;<br>				start=i;<br>				len=j-i+<span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<br>	&#125;<br>	<span class="hljs-keyword">if</span>(start==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//等于0的话就意味着它是一个质数！那么排去1.他的因子就只有本身了。 </span><br>		start=n;<br>		len = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;start;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start+<span class="hljs-number">1</span>;i&lt;start+len;i++)<br>	<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"*"</span>&lt;&lt;i;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pta</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序-较为详细的分析</title>
    <url>/2019/12/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-%E8%BE%83%E4%B8%BA%E8%AF%A6%E7%BB%86%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。 </p>
  <a id="more"></a>
<h3 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h3><p>我们通过记录最小下标进行排序。但有几个需要注意的的地方。</p>
<p>首先，我们将被排序的数组，分为两个部分：有序区和无序区。</p>
<p>我们在每一轮的寻找中最小值下标后记得交换，然后一定要将最小值下标再次初始化为第二个（假设刚刚是第一轮查找）（这个初始下标也成了分界有序区和无序去的下标），并且我们每次都要寻找到新的无序区的最小的下标。</p>
<h3 id="函数样例："><a href="#函数样例：" class="headerlink" title="函数样例："></a>函数样例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span> <br></span>&#123; <br>    <span class="hljs-keyword">int</span> i, j, min_idx; <br>  <br>    <span class="hljs-comment">// 一个接着一个，将无序区的排列为有序</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++) <br>    &#123; <br>        <span class="hljs-comment">// Find the minimum element in unsorted array </span><br>        min_idx = i; <span class="hljs-comment">//一定要记得有初始化，而且他的位置在这里哦。</span><br>        <span class="hljs-comment">//及上面提及的从新开始寻找最小值。</span><br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; n; j++) <br>          <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min_idx]) <br>            min_idx = j; <br>  <br>        <span class="hljs-comment">//交换最小值和其自己</span><br>        <span class="hljs-comment">//我们在这里可以加一个判断，来(可能)减少其交换次数</span><br>        <span class="hljs-comment">//if(i! = min_idx)//如果使用的话，记得加大括号将下面的三个都括起来哦</span><br>        <span class="hljs-keyword">int</span> t = arr[min_idx];<br>        arr[min_idx] = arr[i];<br>        arr[i] = t;<br>        <br>        <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>也许我们都会陷入一个又一个的坑，希望能帮助大家，踩坑多么有意义啊。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>负数二进制（码制与数制）</title>
    <url>/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<p>主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和<strong>应用</strong>，后者为重点）</p>
  <a id="more"></a>
<h2 id="二进制的计算"><a href="#二进制的计算" class="headerlink" title="二进制的计算"></a>二进制的计算</h2><p>在此次的课程中在开始便讲述了二进制的计算：</p>
<p>但其均为正数的时候，计算较为简单和一般的十进制的计算无异（竖式）</p>
<p>但是当其为负数的时候我们就要多加一个步骤了</p>
<p>在这里，先补充以下编码：</p>
<p><strong>编码：</strong></p>
<p>我们常常将信息通过编码储存起来。</p>
<blockquote>
<p>信息编码（Information Coding）是为了方便信息的存储、检索和使用，在进行信息处理时赋予信息元素以代码的过程。即用不同的代码与各种信息中的基本单位组成部分建立一一对应的关系。信息编码必须标准、系统化，设计合理的编码系统是关系信息管理系统生命力的重要因素。</p>
<p>信息编码的目的　信息编码的目的在于为计算机中的数据与实际处理的信息之间建立联系，提高信息处理的效率。</p>
</blockquote>
<p>我们在小学（可能，大雾）的时候，就已经学过如何将十进制和二进制进行相互的转化。</p>
<p>但是，在当时，出于年纪小，我们并没有学会如何实现负数的运算。</p>
<p>那么，首先我们康一下：<strong>负数二进制是如何表示的</strong>。</p>
<p>有人说：在最前添加一bit（一位）：1代表负数，0代表正数。</p>
<p>那么在计算的时候我们是不是就可以直接去计算了呢？</p>
<p>并不是这样的我们这样去计算的话就犯下一个错误：</p>
<p>将<strong>数制和码制混淆。</strong></p>
<p><strong>数制：</strong>即<strong>计数制，数数的方法。</strong>是指十进制二进制，八进制此类的进制。</p>
<p><strong>码制</strong>（用编码的方式表示信息<strong>,即用不同数码表示不同事物时遵循的规则。</strong>例如：学号，身份证号，车牌号）:与前者不同的是，码制表示的并不真的只是一个数字，而是一个信息。人们通过编码的方式将他们转化为数字（不同进制均可）。这就涉及到了 信息→数字 的转换。同样不同的编码方式，所得出的结果自然是不同的。所以也可以用来加密。常用的有：BCD，ASCII等。</p>
<p>目前，数字电路中都采用二进制。</p>
<ol>
<li><p>表示数量时称二进制</p>
</li>
<li><p>表示事物时称<strong>二值逻辑</strong></p>
<p>好了，回归正题~</p>
<hr>
</li>
</ol>
<p>其实按照我们正常的思路我们自己是希望能够按照十进制的方式（竖式）去进行计算的。</p>
<p>在有了前面的基础之后，我们自己对于码制和数制有了一定的了解。那么我们是不是可以计算负数二进制了呢?</p>
<p>并不是，首先我们要将负数的二进制标识出来吧。</p>
<p>假设我们向上面所说的添加一个负号，</p>
<p>那么是不是我们可以推出呢:</p>
<script type="math/tex; mode=display">
-13_{(10)} = -1101_{(2)}</script><p>To be honest:</p>
<p>我们很想让它成为这样的但是并不可行。</p>
<p>这里可以去随意尝试一个例子即可（例如 -13+10）</p>
<p>我们会发现计算的结果转化为10进制之后是错的。</p>
<p>为什么呢，<strong>就是码制和数制之间，我们搞混了</strong>。负数的二进制的第一个1是码制，代表的是一个含义：负数，而我们在计算的时候将其作为一个数值进行了计算，自然错误。那么有解决的方法么？</p>
<p>当然，那么我们应该在哪里修改呢？</p>
<p>在二级制的负数表达上进行修改！</p>
<p>事实上，如果我们去计算器（高级计算器）上实行进制转换。我们会发现-13，并不是单纯的将13的二进制前一位添加了一个1，而是添加在最前1之后，将13的<strong>二进制取反，然后将这个二进制+1.</strong></p>
<p>那么我们怎么去理解这个二进制的意思呢？</p>
<p>举个例子： </p>
<script type="math/tex; mode=display">
-13_{(10)} = 10011_{(2)}</script><p>是指 第一个数字作为 负数，其余仍为正数：</p>
<script type="math/tex; mode=display">
\begin{array}{cc} 1&0&0& 1& 1 \\ -16*1&8*0&4*0&2*1&1*1\\

\end{array}</script><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>二进制的负数的运算既在我们的意料之中，又在我们的意料之外。惊喜连连~</p>
]]></content>
      <categories>
        <category>数字电路</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云-身份证识别调用</title>
    <url>/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>首先，这里选用的sdk是java（支持本地上传版本）和python</p>
<p>阿里云的sdk最好是通过maven来导入，而且在<strong>使用maven的时候注意将镜像设置为阿里云</strong>，否则会很慢。</p>
  <a id="more"></a>
<h4 id="AccessKey"><a href="#AccessKey" class="headerlink" title="AccessKey"></a>AccessKey</h4><p>记得在阿里云上申请（目前免费）accessKey 及密码。</p>
<p>并将其放在application. properties 处</p>
<h4 id="在线测试"><a href="#在线测试" class="headerlink" title="在线测试"></a><a href="https://help.aliyun.com/document_detail/151899.html?spm=a2c4g.11186623.6.603.46ba4dd3pI0g28" target="_blank" rel="noopener">在线测试</a></h4><p>发现可以在线测试呀！！！而且可以使用临时生成的accesskey自动进行，wow!</p>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/onlineTest.png" alt="onlineTest"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><del>并不会！（嘤嘤嘤）</del>（勉强会一点点的python（借助样例））</p>
<h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><p>参考了一份（java嘿嘿）</p>
<p>主要需要编写的有：</p>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pic.png" alt="pic"></p>
<h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><p>首先需要使用 <code>pip install aliyun-python-sdk-core</code>  命令，安装阿里云SDK核心库 。</p>
<p>然后执行下载文字识别包：<code>pip install aliyun-python-sdk-ocr</code> </p>
<p>新建.py文件见下列代码cv，然后将自己的ak填入即可。之后在url的地方图片的链接（仅支持阿里云的oss，代码中给出了一个示例，可以使用）</p>
<p>下面的set_Side就是正反面</p>
<p>运行即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> aliyunsdkcore.client <span class="hljs-keyword">import</span> AcsClient<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ClientException<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ServerException<br><span class="hljs-keyword">from</span> aliyunsdkocr.request.v20191230.RecognizeIdentityCardRequest <span class="hljs-keyword">import</span> RecognizeIdentityCardRequest<br><br>client = AcsClient(<span class="hljs-string">'&lt;accessKeyId&gt;'</span>, <span class="hljs-string">'&lt;accessSecret&gt;'</span>, <span class="hljs-string">'cn-shanghai'</span>)<br><br>request = RecognizeIdentityCardRequest()<br>request.set_accept_format(<span class="hljs-string">'json'</span>)<br><br>request.set_ImageURL(<span class="hljs-string">"http://explorer-image.oss-cn-shanghai.aliyuncs.com/1786373016143448/index.jpg?OSSAccessKeyId=LTAI4Fk9FstqSEYnqKJ5Dpeo&amp;Expires=1589709652&amp;Signature=wdCT6OMdBw2mvOdvVecgkDWtqcI%3D"</span>)<br>request.set_Side(<span class="hljs-string">"face"</span>)<br><br>response = client.do_action_with_exception(request)<br><span class="hljs-comment"># python2:  print(response) </span><br>print(str(response, encoding=<span class="hljs-string">'utf-8'</span>))<br></code></pre></td></tr></table></figure>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pyresult.png" alt="pyresult"></p>
<p>上图是python的测试结果。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试图片（图源网络）</p>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/images.jpg" alt="images"></p>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/index.jpg" alt="index"></p>
<p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/result.png" alt="result"></p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>基本符号要求。（总算成功了）</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>基于阿里云开放平台我们可以便捷使用的工具还有很多很多， 包括人脸人体、文字识别、商品理解、内容安全、图像识别、图像生产、分割抠图、视觉搜索、目标检测、图像分析处理、视频理解、视频生产、视频分割13个类目 ，日后便去完成！</p>
]]></content>
      <categories>
        <category>justForFun</category>
      </categories>
      <tags>
        <tag>cloud</tag>
      </tags>
  </entry>
</search>
