<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    
    <title>java中对象的创建，初始化与引用 - Jefine</title>
    <meta charset="utf-8">
    
    <meta name="title" content="java中对象的创建，初始化与引用 - Jefine">
    <meta name="description" content="">
    <meta property="og:image" content="/favicon.png">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Source Serif Pro', 'Source Han Serif TC', 'Noto Serif CJK TC', 'Noto Serif TC', serif;
        }
    </style>
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/arduino-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Jefine</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
            
            
            <li class="menu-item">
                
                <a href="/" class="menu-item-link">Home</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/archives" class="menu-item-link">Archives</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/about" class="menu-item-link">About</a>
                
            </li>
            
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
    <div class="post-title">
        <h1 class="title">java中对象的创建，初始化与引用</h2>
    </div>
    <div class="post-content">
        <p>在java的学习过程中，对于对象/基本数据类型是如何创建于初始化和引用的，在这一过程中发生了什么，为什么？下面就是有一定的讲解：</p>
<h2 id="java对象与引用："><a href="#java对象与引用：" class="headerlink" title="java对象与引用："></a>java对象与引用：</h2><p>A a1 = new A();</p>
<p>它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。</p>
<p><strong>在声明时：=符号并不表示赋值，而是引用，是一个传递地址的过程。</strong></p>
<p>再如：</p>
<p>A a2;</p>
<p>它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null;</p>
<p>再如：</p>
<p>a2 = a1;</p>
<p>它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址），使得a2和a1指向了同一对象。</p>
<p>综上所述，可以简单的记为，在初始化时，“=”语句左边的是引用，右边new出来的是对象。</p>
<p>在后面的左右都是引用的“=”语句时，左右的引用同时指向了右边引用所指向的对象。</p>
<h2 id="JAVA中对象创建和初始化过程"><a href="#JAVA中对象创建和初始化过程" class="headerlink" title="JAVA中对象创建和初始化过程"></a>JAVA中对象创建和初始化过程</h2><p>分析一下JAVA中对象创建和初始化过程中涉及的相关概念问题，java中<strong>栈</strong>(stack)与<strong>堆</strong>(heap)，<strong>对象</strong>、<strong>引用</strong>、<strong>句柄</strong>的概念。</p>
<h3 id="1-Java中的数据类型"><a href="#1-Java中的数据类型" class="headerlink" title="1.Java中的数据类型"></a>1.Java中的数据类型</h3><p>Java中有3个数据类型：<strong>基本数据类型</strong>(在Java中，boolean、byte、short、int、long、char、float、double这八种是基本数据类型)、<strong>引用类型</strong>和<strong>null类型</strong>。其中，<strong>引用类型包括类类型(含数组)、接口类型。（和struck有点类似哈）</strong></p>
<p>下列语句声明了一些变量：</p>
<p>int k ;</p>
<p>A a; //a是A数据类型的对象变量名（仅作声明）。</p>
<p>B b1,b2,…,b10000;// 假定B是抽象类或接口。</p>
<p>String s;</p>
<p>注意：从数据类型与变量的角度看，基本数据类型变量k、类类型变量a和s、抽象类或接口类型变量b(1万个)，它们都是变量(标识符)。</p>
<h2 id="2-关于句柄-handle"><a href="#2-关于句柄-handle" class="headerlink" title="2.关于句柄(handle)"></a>2.关于句柄(handle)</h2><p>为了区别<strong>引用类型</strong>的变量标识符和<strong>基本数据类型</strong>变量标识符，我们特别的<strong>使用Handle来称呼引用类型的变量标识符</strong>。上面例子中b1至b10000、a、s都是Handle。Handle直观的看就是手柄、把手，我们采用计算机界常用的中文翻译“句柄”。</p>
<h3 id="2-1【Windows编程中的】句柄的含义"><a href="#2-1【Windows编程中的】句柄的含义" class="headerlink" title="2.1【Windows编程中的】句柄的含义"></a>2.1【Windows编程中的】句柄的含义</h3><p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。</p>
<p>从上面的定义中的我们可以看到，句柄是一个标识符，是拿来标识对象或者项目的，它就象我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个16位的无符号整数。应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</p>
<p>如果想更透彻一点地认识句柄，我可以告诉大家，<strong>句柄是一种指向指针的指针。我们知道，所谓指针是一种内存地址</strong>。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢?</p>
<p>为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p>
<p><strong>句柄地址(稳定)→记载着对象在内存中的地址────→对象在内存中的地址(不稳定)→实际对象</strong></p>
<h3 id="2-2Java中句柄的意义"><a href="#2-2Java中句柄的意义" class="headerlink" title="2.2Java中句柄的意义"></a>2.2Java中句柄的意义</h3><p>对句柄以前的【Windows编程中的】含义有了深刻的认识，我们可以说Handle是一个我们学习Java时非常需要的术语。它的意义在于区别“对象本身”和对象变量(或者严格点：对象所属的数据类型的变量标识符)。</p>
<h3 id="2-3回到1中的变量声明："><a href="#2-3回到1中的变量声明：" class="headerlink" title="2.3回到1中的变量声明："></a>2.3回到1中的变量声明：</h3><p>现在，你应该对下面的注释一目了然。</p>
<p>int k, j ;//k里面存放的是一个整型数。</p>
<p>A a; //a里面存放地址。</p>
<p>B b1,b2,…,b10000;// b1，…，b10000里面存放地址。</p>
<p>String s; //s里面存放地址。</p>
<h2 id="3-关于引用-reference"><a href="#3-关于引用-reference" class="headerlink" title="3.关于引用(reference)"></a>3.关于引用(reference)</h2><p>什么是“引用”? “the identifier you manipulate is actually a ‘reference’ to an object”。(Thinking in Java 2e )</p>
<p>翻译是：你操纵的标识符实际上是一个对象的“引用”。或者精确些，翻译成：你操作的标识符实际上是指向一个对象的“引用”。显然，原文中reference是一个有方向感的东西。（说为“指向”也是蛮好）</p>
<p>回到Java中来，引用可以想象成对象的身份证号码、对象的ID或者对象的手机号码。当然，更多的说法是，引用是对象在内存中住的房间号码。直观的说，对象的引用是创建对象时的返回值!引用是new表达式的返回值。</p>
<p>new A(); 这里真正创建了一个对象，但我们没有用句柄去持有(hold、拿着、保存)该引用。从微观上看，new表达式完成了对象初始化的任务(三步曲，下文详细分析)，整体上看则返回一个引用。</p>
<p>再次回到1中的变量声明，再看看下面的注释。</p>
<p>A a; //声明句柄a，但未初始化，所以里面的值为null。</p>
<p>B b1,b2,…,b10000;// 声明句柄b1，…，b10000，但未初始化，所以里面的值为null。</p>
<p>String s; //声明句柄s，但未初始化，所以里面的值为null。</p>
<h2 id="4-句柄与引用的关系"><a href="#4-句柄与引用的关系" class="headerlink" title="4.句柄与引用的关系"></a>4.句柄与引用的关系</h2><p>A a;//声明句柄a，值为null</p>
<p>a=new A();//句柄的初始化(句柄 = 引用;即把引用赋值给句柄)</p>
<p>引用：new A()的值。引用可以简单的看作对象占据内存空间的地址;通过对象的引用，就可以方便的与其他对象区别开来，引用就是对象独特的身份标识。</p>
<p>完成句柄的初始化后，就可以用句柄遥控对象了。</p>
<p>当然，这只是从一方面解释对象的创建和初始化，理解了句柄和引用的关系后，下面分析对象初始化的整个过程。先做以下准备工作，说说栈与堆。</p>
<h2 id="5-java中栈-stack-与堆-heap"><a href="#5-java中栈-stack-与堆-heap" class="headerlink" title="5.java中栈(stack)与堆(heap)"></a>5.java中栈(stack)与堆(heap)</h2><p>在java中内存分为“栈”和“堆”这两种(Stack and Heap).基本数据类型存储在“栈”中，对象引用类型实际存储在“堆”中，在栈中只是保留了引用内存的地址值。</p>
<p>顺便说说“==”与“equals()方法”，以帮助理解两者(Stack and Heap)的概念。</p>
<p>在Java中利用”==”比较变量时候，系统使用变量在stack(栈)中所存的值来作为对比的依据，基本数据类型在stack中所存的值就是其?容值，而引用类型在stack中所存放的值是本身所指向Heap中对象的地址值。<strong>Java.lang包中的Object类有public boolean equals (Object obj)方法。它比较两个对象是否相等。仅当被比较的两个引用指向同一对象时(句柄相等)，对象的equals()方法返回true（是对象的比较哦)</strong>。(至于String类的equals()方法，它重写(override)equals()方法，不在本文讨论之列。)</p>
<h2 id="6-对象的创建和初始化过程"><a href="#6-对象的创建和初始化过程" class="headerlink" title="6.对象的创建和初始化过程"></a>6.对象的创建和初始化过程</h2><p>在java中对象就是类的实例。在一般情况下，当把一个类实例化时，此类的所有成员，包括变量和方法，都被复制到属于此数据类型的一个新的实例中去。分析以下两段代码。</p>
<h3 id="6-1-Vehicle-veh1-new-Vehicle"><a href="#6-1-Vehicle-veh1-new-Vehicle" class="headerlink" title="6.1 Vehicle veh1 = new Vehicle();"></a>6.1 Vehicle veh1 = new Vehicle();</h3><p>上面的语句做了如下的事情：</p>
<p>①右边的“new Vehicle”，是以Vehicle类为模板，在堆空间里创建一个Vehicle类对象(也简称为Vehicle对象)。</p>
<p>②末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果没创建，Java会补上一个默认的构造函数。(一般根据类型为null，0）</p>
<p>③左边的“Vehicle veh1”创建了一个Vehicle类引用变量。</p>
<p>④“=”操作符使对象引用指向刚创建的那个Vehicle对象。(回想一下句柄与引用)</p>
<p>将上面的语句分为两个步骤：</p>
<p>Vehicle veh1;</p>
<p>veh1 = new Vehicle();</p>
<p>这样写，就比较清楚了，有两个实体：</p>
<p>一是对象引用变量，一是对象本身。</p>
<p>在堆空间里创建的实体，与在栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是似乎很难准确的“抓”住它。我们仔细研究一下第二句，找找刚创建的对象叫什么名字?有人说，它叫“Vehicle”。不对，“Vehicle”是类(对象的创建模板)的名字。一个Vehicle类可以据此创建出无数个对象，这些对象不可能全叫“Vehicle”。对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。</p>
<h3 id="6-2-Vehicle-veh2"><a href="#6-2-Vehicle-veh2" class="headerlink" title="6.2 Vehicle veh2;"></a>6.2 Vehicle veh2;</h3><p>veh2 = veh1;</p>
<p>由于veh1和veh2只是对对象的引用，第二行所做的不过是把veh1的引用(地址)赋值给veh2，使得veh1和veh2同时指向唯一的一个Vehicle对象。</p>
<h3 id="6-3-veh2-new-Vehicle"><a href="#6-3-veh2-new-Vehicle" class="headerlink" title="6.3 veh2 = new Vehicle();"></a>6.3 veh2 = new Vehicle();</h3><p>则引用变量veh2改指向第二个对象。</p>
<p>从以上叙述再推演下去，我们可以获得以下结论：①一个对象引用可以指向0个（null）或1个对象;②一个对象可以有N个引用指向它。</p>
<p><a href="http://blog.sina.com.cn/s/blog_7ed8eb7d0101k057.html" target="_blank" rel="noopener">原文链接，稍作修改</a></p>

    </div>
    <div class="post-meta">
        
    <span class="post-time">二〇二〇年三月十一日</span>
    </div>
</article>

<div class="prev_next">
    <nav id="prev_next">

<div class="prev">
    
    <p>Newer</p>
    <a href="/2020/03/17/LinkedList链表/"><div class="article-nav-title">LinkedList链表</div></a>
    
</div>
<div class="next">
    
    <p>Older</p>
    <a href="/2020/03/01/java日期处理/"><div class="article-nav-title">java日期处理</div></a>
    
</div>

</nav>
</div>

<div class="post-comment">
    



</div>

    </main><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>