<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>算法时间复杂度分析 | jefine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">jefine</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/about">About</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-算法时间复杂度分析d大o" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      算法时间复杂度分析
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2020-02-08T11:40:05.000Z" itemprop="datePublished">二月 8, 2020, 7:40 晚上</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h1 id="1-2-算法分析"><a href="#1-2-算法分析" class="headerlink" title="1.2 算法分析:"></a>1.2 算法分析:</h1><p><img src="https://i.loli.net/2020/02/08/vLTN4YAGuk5enzZ.png" alt="Untitled.png"></p>
<p>分为：事后统计法与事前分析估算法。</p>
<p>当然，第一种需要执行程序。而且存在着其他的因素来干扰结果。（与硬件有关）</p>
<p>所以采用<strong>事前分析评估法</strong>来分析算法的效率。</p>
  <a id="more"></a>
<h3 id="1-2-1算法时间复杂度分析："><a href="#1-2-1算法时间复杂度分析：" class="headerlink" title="1.2.1算法时间复杂度分析："></a>1.2.1算法时间复杂度分析：</h3><p>算法是由控制结构（顺序，分支，循环3种）和原操作（固有数据类型的操作）构成。</p>
<p>算法的的运行时间取决于两者的综合效果。o</p>
<p><img src="https://i.loli.net/2020/02/08/Y1yP4zWnVuaSC5K.png" alt="Untitled 1.png"></p>
<p>设n为算法中的问题规模，通常用大O、大Ω或  等三种渐进符号表示算法的执行时间与n之间的一种增长关系。</p>
<p><img src="https://i.loli.net/2020/02/08/lpOyIUejhMig8fS.png" alt="Untitled 2.png"></p>
<p>算法的执行时间主要与问题规模有关（即数据的多少有关）不妨将数据规模设为n；</p>
<p>分析问题规模n，找出<strong>基本语句</strong>，求出其运行次数f(n)。</p>
<p><em>基本语句：算法中的基本语句是执行次数与整个算法的执行次数程正比的语句，他对算法执行时间的贡献最大（最费时间），是算法中最重要的操作。（</em>上文的例子中：s+=a[i][i]便是基本语句。）</p>
<p>在此例子中：f(n)=n</p>
<p>这种<strong>时间衡量方法得出的不是具体的时间，而是一种增长趋势的度量（即加速度）</strong>。换而言之，这是在n足够大的情况下算法中基本语句的执行次数在渐进意义下的<strong>阶</strong>（我们可以将其理解为高阶，低阶这样的概念）</p>
<h3 id="大o表示法："><a href="#大o表示法：" class="headerlink" title="大o表示法："></a>大o表示法：</h3><p>大O表示法就是将算法的所有步骤转换为代数项，然后<strong>排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数。</strong></p>
<p>数学家可能会对我的“整体影响”假设有点沮丧，但是开发人员为了节省时间，这种方式更容易简化问题：</p>
<p><code>规律 Big-O
2 O(1) --&gt; 就是一个常数
2n + 10 O(n) --&gt; n 对整体结果会产生最大影响
5n^2 O(n^2) --&gt; n^2 具有最大影响</code></p>
<p>简而言之，这个例子所要表达的就是：我们只关注表达式中对表达式最终结果会产生最大影响的因子。（当常数非常大而n很小的时候并不是这样的，但是我们现在不要担心这种情况）。</p>
<p>下面是一些常用的时间复杂度以及简单的定义。更完整的定义可以翻阅<a href="https://en.wikipedia.org/wiki/Time_complexity" target="_blank" rel="noopener">维基百科</a>(英文）。</p>
<ul>
<li><strong>O(1)—</strong> 常量时间：给定一个大小为n的输入，概算法只需要一步就可以完成任务。</li>
<li><strong>O(log n)—</strong>对数时间：给定大小为n的输入，该算法每执行一步，它完成任务所需要的步骤数目会以一定的因子减少。</li>
<li><strong>O(n)—</strong>线性时间：给定大小为n的输入，该算法完成任务所需要的步骤直接和n相关（1对1的关系）。</li>
<li><strong>O(n²)—</strong>二次方时间：给定大小为n的输入，完成任务所需要的步骤是n的平方。</li>
<li><strong>O(C^n)—</strong>指数时间：给定大小为n的输入，完成任务所需要的步骤是一个常数的n次方（非常大的数字）。（c为常数）</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/TbekNSdj5A4lxhR.png" alt="Untitled 3.png"></p>
<p>从图中我们也可以看到不同的效率对于事件的影响是极大的。</p>
<p>在这个网站中我们也可以看到一些常见的算法效率：</p>
<p><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></p>
<p>那么？<strong>什么才是大o表示法</strong>：下面的链接讲述的很详细。</p>
<p><a href="https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/" target="_blank" rel="noopener">Analysis of Algorithms | Big-O analysis - GeeksforGeeks</a></p>
<p>综合来讲，大o表示法表示的是增长率的上界。</p>
<p>而且需要的是紧凑上界！！！</p>
<p><img src="https://i.loli.net/2020/02/08/w7SqJhMX29KZ45Y.jpg" alt="1 2.jpeg"></p>
<h3 id="大Ω表示法："><a href="#大Ω表示法：" class="headerlink" title="大Ω表示法："></a>大Ω表示法：</h3><p>大Ω符号用来描述增长率的下界，表示f(n)的增长最少像g(n) 增长的那样快，也就是说，</p>
<p>当输入规模为n时，算法消耗时间的最小值。 与大O符号对称，这个下界的阶越高，结果就越有价值，所以，对于10n~2+4n+2，Ω(n2)比Ω(n) 有价值。一个算法的时间用大Ω符号表示时，总是采用最有价值的g(n)表示，称之为“紧凑下界”或“紧确下界”。 </p>
<h3 id="大-表示法："><a href="#大-表示法：" class="headerlink" title="大  表示法："></a>大  表示法：</h3><p>大?符号比大O符号和大Ω符号都精确，</p>
<p>当且仅当g(n)既是f(n)的上界又是f(n)的下界。即当大o表示法和大Ω表示法相同时，即为该表示法。</p>
<p>最后：如下：分别表示3种符号</p>
<p><img src="https://i.loli.net/2020/02/08/1cKPxilrG96sEY2.png" alt="Untitled 4.png"></p>
<p>另附以下特性：</p>
<p><img src="https://i.loli.net/2020/02/08/oZBcmqPKAshu6UM.jpg" alt="1 2 1.jpeg"></p>
<p>额。</p>
<p>⑴ 找出算法中的基本语句；　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。　⑵ 计算基本语句的执行次数的数量级；　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。　⑶ 用大Ο记号表示算法的时间性能。　将基本语句执行次数的数量级放入大Ο记号中。　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p>
<pre><code>for (i=1; i&lt;=n; i++)       x++;  for (i=1; i&lt;=n; i++)      　for (j=1; j&lt;=n; j++)            x++;
</code></pre><p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(<em>n</em>2)，则整个算法的时间复杂度为Ο(n+<em>n</em>2)=Ο(<em>n</em>2)。　Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中<strong>Ο(log<em>2n</em>)、Ο(n)、 Ο(nlog<em>2n</em>)、Ο(<em>n</em>2)和Ο(<em>n</em>3)</strong>称为多项式时间，<strong>而Ο(<em>2</em>n )和Ο(n!)称为指数时间</strong>。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为<strong>P</strong>（Polynomial,多项式）<strong>类问题</strong>，而把后者（即指数时间复杂度的算法）称为<strong>NP（Non-Deterministic Polynomial, 非确定多项式）问题</strong>。 一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。</p>
<p>（4）<strong>在计算算法时间复杂度时有以下几个简单的程序分析法则:</strong></p>
<p>(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间</p>
<p>(2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则” <strong>求和法则</strong>:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n))) 特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))</p>
<p>(3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间</p>
<p>(4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则” <strong>乘法法则</strong>: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1<em>T2=O(f(n)</em>g(n))</p>
<p>(5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数</p>
<p><strong>（5）下面分别对几个常见的时间复杂度进行示例说明：</strong></p>
<p><strong>(1)、O(1)</strong></p>
<pre><code>Temp=i; i=j; j=temp;
</code></pre><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。<strong>注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</strong></p>
<p><strong>(2)、</strong>O(<em>n</em>2)** 2.1. 交换i和j的内容</p>
<pre><code>sum=0；                 （一次）  
for(i=1;i&lt;=n;i++)     （n+1次）   
for(j=1;j&lt;=n;j++) （n2次）      
sum++；            （n2次）
</code></pre><p>解：<strong>因为Θ(2<em>n</em>2 +n+1)=<em>n</em>2 （Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(<em>n</em>2)；</strong></p>
<p>2.2.</p>
<pre><code>for (i=1;i&lt;n;i++)   {    y=y+1;         ①      
for (j=0;j&lt;=(2*n);j++)          x++;         ②    }
</code></pre><p>解： 语句1的频度是n-1 语句2的频度是(n-1)<em>(2n+1)=2**</em>n<em>2<strong> -n-1 f(n)=2</strong></em>n<em>2<strong> -n-1+(n-1)=2</strong></em>n<em>2<strong> -2； 又</strong>Θ(2</em>n<em>2-2)=</em>n<em>2<strong>  该程序的时间复杂度T(n)=O(</strong></em>n<em>2<strong> ).　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 </strong>(3)、O(n)*</em></p>
<pre><code>a=0;  b=1;                      ①  
for (i=1;i&lt;=n;i++) ②  {     
s=a+b;　　　　③   
b=a;　　　　　④     
a=s;　　　　　⑤  }
</code></pre><p>解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n).</p>
<p><strong>(4)、O(log<em>2n</em>)</strong></p>
<pre><code>i=1;     ①  
hile (i&lt;=n)  i=i*2; ②
</code></pre><p>解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=<strong>log<em>2n</em></strong> 取最大值f(n)=<strong>log<em>2n</em></strong>, T(n)=O(<strong>log<em>2n</em></strong> )</p>
<p><strong>(5)、O(<em>n</em>3)</strong></p>
<pre><code>for(i=0;i&lt;n;i++)   {      
for(j=0;j&lt;i;j++)      {       
for(k=0;k&lt;j;k++)          
x=x+2;      }   }
</code></pre><p>解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)<em>1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(**</em>n<em>3)*</em></p>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/%E5%A4%A7o%E8%A1%A8%E7%A4%BA%E6%B3%95/" rel="tag">大o表示法</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/02/09/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E7%9A%84%E9%98%90%E8%BF%B0/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java面向对象特性的阐述
        
      </div>
    </a>
  
  
    <a href="/2020/01/31/%E4%BD%BF%E7%94%A8sort%E5%87%BD%E6%95%B0%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          使用sort函数对结构体排序
        
      </div>
    </a>
  
</nav>






    </div>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  







</body>
</html>
