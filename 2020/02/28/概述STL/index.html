<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    
    <title>概述STL - Jefine</title>
    <meta charset="utf-8">
    
    <meta name="title" content="概述STL - Jefine">
    <meta name="description" content="">
    <meta property="og:image" content="/favicon.png">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Source Serif Pro', 'Source Han Serif TC', 'Noto Serif CJK TC', 'Noto Serif TC', serif;
        }
    </style>
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/arduino-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script>
<link rel="alternate" href="/atom.xml" title="Jefine" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Jefine</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
            
            
            <li class="menu-item">
                
                <a href="/" class="menu-item-link">Home</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/archives" class="menu-item-link">Archives</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/about" class="menu-item-link">About</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/atom.xml" class="menu-item-link">Rss</a>
                
            </li>
            
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
    <div class="post-title">
        <h1 class="title">概述STL</h2>
    </div>
    <div class="post-content">
        <p>使用stl可以大大提高算法设计的效率和可靠性。</p>
  <a id="more"></a>
<ol>
<li>概述：</li>
</ol>
<p>STL 即Standard Template Library标准模板类库。</p>
<p>是标准c++库的子集</p>
<p>通用，强大</p>
<ol>
<li>构成：</li>
</ol>
<p>container：容器（储存元素）</p>
<p>algorithm：算法（操作元素）</p>
<p>iterator：迭代器（类似指针）</p>
<p>容器container:是一种数据结构</p>
<h2 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h2><p>1）</p>
<p><a href="https://jefine.github.io/2020/02/27/stlvector/">vector向量容器</a></p>
<p>2）</p>
<p>string 类似于上面的函数，有个别的例外。</p>
<p>3）</p>
<p>Dequen双端队列容器</p>
<p>是链表和字符串的调和产物，是多个连续的队列块。</p>
<p>4）list链表容器</p>
<p>是一个双链表类模板，只能使用++ - -来使用迭代器</p>
<h2 id="2-关联容器："><a href="#2-关联容器：" class="headerlink" title="2. 关联容器："></a>2. 关联容器：</h2><p>关联容器中每个元素都有一个关键字（key），通过key来储存和读取原损失，这些关键词可能于元素在容器中的位置无关，所以关联容器中不提供顺序容器中的front(),push_front(),pop_back()等操作，可以实现快速搜索（运用了分类的数据结构）</p>
<p>1）set（集合容器）/multiset（多重集合容器）</p>
<p>区别：</p>
<p>set中元素的关键字是唯一的，而multiset的关键字可以不唯一。<strong>默认情况下会对元素按照升序排列。</strong></p>
<p>而如果需要集合中的元素可以重复那么可以使用multiset。</p>
<p>又由于set没有重复的元素，所以如果添加的元素相同，那么不添加；而multiset可以有重复的元素，所以在删除的时候，会将其全部删除然后返回一个被删去元素个数。</p>
<p>特殊的函数有：</p>
<p>count（k）返回k在set中的次数。</p>
<p>find（k)如存在返回该元素的迭代器，否则返回end（）；</p>
<p>upper/lower_bound（k）返回关键字&gt;k或&gt;=k的第一个元素的迭代器</p>
<p>2）map（映射容器）/multimap（多重映射容器）</p>
<p>映射是实现关键字和值的各系的储存结构，可以用key来访问value</p>
<p>实现关键字和值关系的对应，而map是一一对应；而multimap是</p>
<p>同时map/multimap容器中的key和value是pair类型（不是像set一样两者都是key类型）pair是一个结构体声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pair</span><br>&#123;</span> T first;<span class="hljs-comment">//对应key值</span><br>  T second;<span class="hljs-comment">//对应value值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照key升序排列，以红黑树的形式。map支持【】；而multimap不允许【】（在使用map[key]的时侯如果不存在该key值那么就以其为关键字插入一个元素。</p>
<p>三种方式插入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mym;<br>    mym[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;<br>    mym.insert(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>));<br>    mym.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">'c'</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span>(it = mym.<span class="hljs-built_in">begin</span>();it!=mym.<span class="hljs-built_in">end</span>();++it)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="适配器容器："><a href="#适配器容器：" class="headerlink" title="适配器容器："></a>适配器容器：</h2><p>是基于其他的容器实现的容器，在底层容器实现适配器容器的功能，实际上可以将其作为一个一般的容器去使用。后进后出（只能从顶部出入）</p>
<p>1）stark 栈容器：</p>
<p>后进后出默认的底层容器是deque，（当然也可以指定其他的容器作为stark的底层容器）</p>
<p>只有简单的pop（）出栈；push（）入栈；empty（）；size（）</p>
<p>2）queue队列容器：先进先出。</p>
<p>插入的元素在队尾，pop（）出的元素在队首。</p>
<p>3)priority_queue(优先队列容器）</p>
<p>可随意顺序入队列但是一旦进入就会被排序（按照值的大小排序）</p>
<p>在这个里面使用pop（）来找到队伍最前面的（也是最大值的）</p>

    </div>
    <div class="post-meta">
        
    <span class="post-time">二〇二〇年二月廿八日</span>
    </div>
</article>

<div class="prev_next">
    <nav id="prev_next">

<div class="prev">
    
    <p>Newer</p>
    <a href="/2020/02/29/P1023税收与补贴问题/"><div class="article-nav-title">P1023税收与补贴问题</div></a>
    
</div>
<div class="next">
    
    <p>Older</p>
    <a href="/2020/02/27/stlvector/"><div class="article-nav-title">stlvector</div></a>
    
</div>

</nav>
</div>

<div class="post-comment">
    



</div>

    </main><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>