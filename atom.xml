<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jefine</title>
  
  <subtitle>小小的梦呓</subtitle>
  <link href="https://jefine.github.io/atom.xml" rel="self"/>
  
  <link href="https://jefine.github.io/"/>
  <updated>2021-08-24T13:57:10.532Z</updated>
  <id>https://jefine.github.io/</id>
  
  <author>
    <name>jefine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4GES600S开发</title>
    <link href="https://jefine.github.io/2021/08/24/4GES600SEVB/"/>
    <id>https://jefine.github.io/2021/08/24/4GES600SEVB/</id>
    <published>2021-08-24T13:43:14.000Z</published>
    <updated>2021-08-24T13:57:10.532Z</updated>
    
    <content type="html"><![CDATA[<p>移远通信 ES600S开发板的Demo和一些基础的操作指南</p>  <a id="more"></a><h1 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h1><h2 id="配置环境与基本认识文档："><a href="#配置环境与基本认识文档：" class="headerlink" title="配置环境与基本认识文档："></a>配置环境与基本认识文档：</h2><p><a href="https://python.quectel.com/doc/doc/Quick_start/zh/index.html" target="_blank" rel="noopener">QuecPython</a></p><p> <a href="4GES600SEVB\固件下载与脚本下载图解.pdf.pdf">固件下载与脚本下载图解.pdf.pdf</a> </p><h3 id="开发板使用几大步骤："><a href="#开发板使用几大步骤：" class="headerlink" title="开发板使用几大步骤："></a>开发板使用几大步骤：</h3><p>1.插上模组；</p><p>2.模组开机（具体步骤：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；</a></p><p>3.驱动安装（注意事项：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；</a></p><p>4.烧录QuecPython固件</p><p>注意事项见：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节</a></p><p>具体步骤的视频连接：<a href="https://www.bilibili.com/video/BV1ci4y1w7g8/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ci4y1w7g8/</a></p><p>5.下载Demo程序（官网的下载专区<a href="https://python.quectel.com/download有个Demo的文件夹）" target="_blank" rel="noopener">https://python.quectel.com/download有个Demo的文件夹）</a></p><p>6.例程无法跑通请先自查并参考官网wiki（<a href="https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库" target="_blank" rel="noopener">https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库</a></p><h3 id="开发板需要注意的地方："><a href="#开发板需要注意的地方：" class="headerlink" title="开发板需要注意的地方："></a>开发板需要注意的地方：</h3><p> <a href="4GES600SEVB\Quectel_EC600x-CN(_QuecOpen">Quectel_EC600x-CN(_QuecOpen)兼容性设计讲稿_-0506.pdf</a>兼容性设计讲稿_-0506.pdf) </p><p>Page24</p><p>EC600N-CN/EC600S-CN (QuecOpen)接喇叭则需增加外部PA设计（放大听<br>筒信号）</p><p>EC600N-CN/EC600S-CN QuecOpen 复用键盘引脚（PIN 48~57）也可以复用成<br>GPIO功能使用，在不用键盘情况下可使用<br>复用成GPIO口时要注意开机默认状态和电源域，具体参考Quectel_EC600x-CN<br>QuecOpen_GPIO配置表_V1.0</p><p>EC600S-CN/EC600N-CN QuecOpen 开机默认是PU，用于控灯、电机和外部电源<br>使能之类要注意模块上电时有上拉动作</p><p>天线设计</p><p> <a href="4GES600SEVB\Quectel_天线设计指导_V3.2.pdf.pdf">Quectel_天线设计指导_V3.2.pdf.pdf</a> </p><h1 id="小实验："><a href="#小实验：" class="headerlink" title="小实验："></a>小实验：</h1><h2 id="如何将软硬件结合？"><a href="#如何将软硬件结合？" class="headerlink" title="如何将软硬件结合？"></a>如何将软硬件结合？</h2><p>另外在查询开发板上的GPIO的号码时，可以看看板子中间的引脚介绍，可以解决不少问题，查找不到的可以按照下面的方法进行查找。</p><p>即如何查找软件 GPIO 或 ADC 等接口与物理开发板接口的位置</p><p>下面以查找KEY2所对应的GPIO号为例：</p><p>首先打开EC600X_QuecPython_EVB_V1.3 SCH.pdf文件</p><p> <a href="4GES600SEVB\EC600X_QuecPython_EVB_V1.3_SCH(2">EC600X_QuecPython_EVB_V1.3_SCH(2).pdf.pdf</a>.pdf.pdf) </p><p>然后根据需要切换到第六GPIO+UART这一页也是最经常查找的</p><p><img src="/2021/08/24/4GES600SEVB/Untitled.png" alt="p"></p><p> 可以看到左下角的S4,S5即是我们所要寻找的，找到引脚号PIN60后</p><p>即可根据<a href="https://python.quectel.com/wiki/#/zh-cn/api/QuecPythonClasslib?id=pin" target="_blank" rel="noopener">网页API</a>查询到相关的GPIO号码，如图12 即为所求。</p><p>有部分不易寻找到内容可以采取多种类似说法，大小写，简要内容的搜索来查找。</p><p><img src="/2021/08/24/4GES600SEVB/Untitled 1.png" alt="p"></p><h2 id="简单的外设Demo"><a href="#简单的外设Demo" class="headerlink" title="简单的外设Demo"></a>简单的外设Demo</h2><p><a href="https://python.quectel.com/doc/doc/little_demo/zh/QuecPythonTest/QuecPythonLED.html" target="_blank" rel="noopener">QuecPython</a></p><h3 id="UART串口："><a href="#UART串口：" class="headerlink" title="UART串口："></a>UART串口：</h3><p><img src="/2021/08/24/4GES600SEVB/Untitled 2.png" alt="p1"></p><p><img src="/2021/08/24/4GES600SEVB/Untitled 3.png" alt="p"></p><h3 id="External-interrupt外部中断"><a href="#External-interrupt外部中断" class="headerlink" title="External_interrupt外部中断"></a>External_interrupt外部中断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> ExtInt<br><br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><br><span class="hljs-comment"># 参考自 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=extint</span><br><br>state = <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callBack</span><span class="hljs-params">(args)</span>:</span><br><br>    <span class="hljs-keyword">global</span> state<br><br>    print(<span class="hljs-string">'### interrupt  &#123;&#125; ###'</span>.format(args))<br>    <span class="hljs-comment">#传入的应该是一个List，[GPIOX,X] ,第二个参数不清楚</span><br><br>    state = state - <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br><br>    <span class="hljs-comment"># 映射GPIO12的下降沿触发回调函数</span><br>    <span class="hljs-comment"># GPIO12即key2</span><br><br>    extint = ExtInt(ExtInt.GPIO12, ExtInt.IRQ_FALLING, ExtInt.PULL_PU, callBack)<br><br>    <span class="hljs-comment"># 等待按键按下，触发</span><br><br>    <span class="hljs-keyword">while</span> state:<br>        time.sleep_ms(<span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 停止映射外部中断</span><br><br>    extint.disable()<br><br>    print(<span class="hljs-string">"The main function has exited"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    main()<br></code></pre></td></tr></table></figure><h3 id="WatchDog-看门狗"><a href="#WatchDog-看门狗" class="headerlink" title="WatchDog 看门狗"></a>WatchDog 看门狗</h3><p>看门狗的复位指的是<strong>重启机器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实验1：独立看门狗实验</span><br><span class="hljs-comment"># API资料参考连接：  https://python.quectel.com/wiki/#/zh-cn/api/?id=wdt</span><br><br><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> WDT<br><span class="hljs-keyword">import</span> utime<br><br>wdt = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 定义全部变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Watchdog</span><span class="hljs-params">()</span>:</span>  <span class="hljs-comment"># 2秒钟内调用喂狗函数，否则系统复位</span><br>    <span class="hljs-keyword">global</span> wdt  <span class="hljs-comment"># 声明全部变量</span><br>    <span class="hljs-keyword">if</span> wdt <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        wdt = WDT(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 启动看门狗，间隔时长 单位 秒</span><br>    wdt.feed()  <span class="hljs-comment"># 喂狗</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_1</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 1'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_2</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 2'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_3</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 3'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span><br>    print(<span class="hljs-string">'功能函数 3_2'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_4</span><span class="hljs-params">()</span>:</span><br>    utime.sleep_ms(<span class="hljs-number">1000</span>)<br>    print(<span class="hljs-string">'功能函数 4'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    print(<span class="hljs-string">'尝试在5s后喂狗'</span>)<br>    utime.sleep_ms(<span class="hljs-number">5000</span>)  <span class="hljs-comment"># 延时5秒</span><br>    Watchdog()<br>    print(<span class="hljs-string">'来不及喂狗，系统已经复位'</span>)<span class="hljs-comment">#此行代码不会显示因为机器已经重启了</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_1()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_2()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_3()  <span class="hljs-comment"># 用户程序</span><br>    print(<span class="hljs-string">'喂狗'</span>)<br>    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span><br>    func_4()  <span class="hljs-comment"># 用户程序</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    main()<br></code></pre></td></tr></table></figure><h3 id="温湿度检测"><a href="#温湿度检测" class="headerlink" title="温湿度检测"></a>温湿度检测</h3><p>测得不准，勉强能看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''<br>File: i2c_aht10.py<br>Project: i2c<br>File Created: Monday, 28th December 2020 5:17:28 pm<br>Author: chengzhu.zhou<br>-----<br>Last Modified: Tuesday, 29th December 2020 9:01:35 pm<br>Modified By: chengzhu.zhou<br>-----<br>Copyright 2020 - 2020 quectel<br>'''</span><br><br><span class="hljs-keyword">import</span> log<br><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> I2C<br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><span class="hljs-string">"""<br>1. calibration<br>2. Trigger measurement<br>3. read data<br>"""</span><br><br><span class="hljs-comment"># API  手册 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=i2c</span><br><span class="hljs-comment"># AHT10 说明书</span><br><span class="hljs-comment">#  https://server4.eca.ir/eshop/AHT10/Aosong_AHT10_en_draft_0c.pdf</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aht10class</span><span class="hljs-params">()</span>:</span><br>    i2c_log = <span class="hljs-literal">None</span><br>    i2c_dev = <span class="hljs-literal">None</span><br>    i2c_addre = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># Initialization command</span><br>    AHT10_CALIBRATION_CMD = <span class="hljs-number">0xE1</span><br>    <span class="hljs-comment"># Trigger measurement</span><br>    AHT10_START_MEASURMENT_CMD = <span class="hljs-number">0xAC</span><br>    <span class="hljs-comment"># reset</span><br>    AHT10_RESET_CMD = <span class="hljs-number">0xBA</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_data</span><span class="hljs-params">(self, data)</span>:</span><br>        self.i2c_dev.write(self.i2c_addre,<br>                           bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,<br>                           bytearray(data), len(data))<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data</span><span class="hljs-params">(self, length)</span>:</span><br>        r_data = [<span class="hljs-number">0x00</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length)]<br>        r_data = bytearray(r_data)<br>        self.i2c_dev.read(self.i2c_addre,<br>                          bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,<br>                          r_data, length,<br>                          <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> list(r_data)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_init</span><span class="hljs-params">(self, addre=<span class="hljs-number">0x38</span>, Alise=<span class="hljs-string">"Ath10"</span>)</span>:</span><br>        self.i2c_log = log.getLogger(Alise)<br>        self.i2c_dev = I2C(I2C.I2C1, I2C.STANDARD_MODE)  <span class="hljs-comment"># 返回i2c对象</span><br>        self.i2c_addre = addre<br>        self.sensor_init()<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_transformation_temperature</span><span class="hljs-params">(self, data)</span>:</span><br>        r_data = data<br>        <span class="hljs-comment">#　根据数据手册的描述来转化温度</span><br>        humidity = (r_data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">12</span>) | (<br>            r_data[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">4</span>) | ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>)<br>        humidity = (humidity/(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) * <span class="hljs-number">100.0</span><br>        print(<span class="hljs-string">"current humidity is &#123;0&#125;%"</span>.format(humidity))<br>        temperature = ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xf</span>) &lt;&lt; <span class="hljs-number">16</span>) | (<br>            r_data[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | r_data[<span class="hljs-number">4</span>]<br>        temperature = (temperature * <span class="hljs-number">200.0</span> / (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) - <span class="hljs-number">50</span><br>        print(<span class="hljs-string">"current temperature is &#123;0&#125;°C"</span>.format(temperature))<br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sensor_init</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># calibration</span><br>        self.write_data([self.AHT10_CALIBRATION_CMD, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>])<br>        time.sleep_ms(<span class="hljs-number">300</span>)  <span class="hljs-comment"># at last 300ms</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ath10_reset</span><span class="hljs-params">(self)</span>:</span><br>        self.write_data([self.AHT10_RESET_CMD])<br>        time.sleep_ms(<span class="hljs-number">20</span>)  <span class="hljs-comment"># at last 20ms</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Trigger_measurement</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># Trigger data conversion</span><br>        self.write_data([self.AHT10_START_MEASURMENT_CMD, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>])<br>        time.sleep_ms(<span class="hljs-number">200</span>)  <span class="hljs-comment"># at last delay 75ms</span><br>        <span class="hljs-comment"># check has success</span><br>        r_data = self.read_data(<span class="hljs-number">6</span>)<br>        <span class="hljs-comment"># check bit7</span><br>        <span class="hljs-keyword">if</span> (r_data[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">7</span>) != <span class="hljs-number">0x0</span>:<br>            print(<span class="hljs-string">"Conversion has error"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            self.aht10_transformation_temperature(r_data[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">i2c_aht10_test</span><span class="hljs-params">()</span>:</span><br>    ath_dev = aht10class()<br>    ath_dev.aht10_init()<br><br>    <span class="hljs-comment"># 测试十次</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        ath_dev.Trigger_measurement()<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    i2c_aht10_test()<br></code></pre></td></tr></table></figure><h3 id="Photoresistor-光敏电阻"><a href="#Photoresistor-光敏电阻" class="headerlink" title="Photoresistor 光敏电阻"></a>Photoresistor 光敏电阻</h3><p>得到的数值为ADC电压值</p><p><img src="/2021/08/24/4GES600SEVB/Untitled 4.png" alt="p"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''<br>File: Photoresistor.py<br>Project: adc<br>File Created: Thursday, 24th December 2020 5:44:08 pm<br>Author: chengzhu.zhou<br>-----<br>Last Modified: Wednesday, 30th December 2020 10:10:33 am<br>Modified By: chengzhu.zhou<br>-----<br>Copyright 2020 - 2020 quectel<br>'''</span><br><br><span class="hljs-keyword">from</span> misc <span class="hljs-keyword">import</span> ADC<br><span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<br><span class="hljs-keyword">import</span> _thread<br><br><span class="hljs-comment"># unit as Ω</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Voltage_to_Resistance</span><span class="hljs-params">(Volt)</span>:</span><br>    <span class="hljs-comment">#</span><br>    Va = <span class="hljs-number">2</span> * Volt<br>    resistance = (<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * <span class="hljs-number">40200</span> * Va)/(<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * (<span class="hljs-number">3300</span> - Va) - (<span class="hljs-number">40200</span> * Va))<br>    <span class="hljs-keyword">return</span> resistance<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Photoresistor_thread</span><span class="hljs-params">(delay, retryCount)</span>:</span><br>    <span class="hljs-comment"># creat a adc device</span><br>    AdcDevice = ADC()<br>    <span class="hljs-keyword">while</span> retryCount:<br>        retryCount = retryCount - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># get ADC.ADC0 value</span><br>        adcvalue = AdcDevice.read(ADC.ADC0)<br>        print(<span class="hljs-string">"get ADC.ADC0 Voltage value as &#123;0&#125;mv"</span>.format(adcvalue))<br>        <span class="hljs-comment"># Converted to resistance</span><br>        resistance = Voltage_to_Resistance(adcvalue)<br>        print(<span class="hljs-string">"Photoresistor  resistance as  &#123;0&#125;Ω"</span>.format(resistance))<br>        time.sleep(delay)<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># creat a thread Convert ADC to Voltage</span><br>    _thread.start_new_thread(Photoresistor_thread, (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>    print(<span class="hljs-string">"creent main thread has exit"</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;移远通信 ES600S开发板的Demo和一些基础的操作指南&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="ES600S" scheme="https://jefine.github.io/tags/ES600S/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙模块HC05的双设备简单配对通信</title>
    <link href="https://jefine.github.io/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/"/>
    <id>https://jefine.github.io/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-09T08:01:45.000Z</published>
    <updated>2021-08-09T08:27:58.180Z</updated>
    
    <content type="html"><![CDATA[<p>HC05采用的是AT指令进行配置， 采用串口通信进行数据传输。</p><p><a href="https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf" target="_blank" rel="noopener">指令集文档</a>可以任意在互联网中查找到。</p>  <a id="more"></a><p><strong>注意</strong>：</p><ol><li>HC05，VCC接入3.3V可能没有反应，应连到5V</li><li>模块和电源相连时刻，有两种方法进入AT指令状态：<ol><li>提前一直按下HC-05上的按键，直到其灯闪烁为缓慢亮起，即可松开</li><li>将EN引脚置高（3.3V即可），但需要注意EN为高电平是HC05不能正常工作，只有将EN调为低电平，HC05恢复</li></ol></li><li>波特率需要一致，建议统一38400</li><li>模块所有AT指令需要加上换行符号否则无效（即选择CR/LF），且尽量大写</li></ol><p><a href="https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html" target="_blank" rel="noopener">https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SoftwareSerial</span>.</span></span>h&gt;<br><br><span class="hljs-comment">// Pin3为RX，接HC05的TXD</span><br><span class="hljs-comment">// Pin2为TX，接HC05的RXD</span><br>SoftwareSerial <span class="hljs-constructor">BT(10, 11)</span>;<br><span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span>;<br><span class="hljs-built_in">int</span> ledPin=<span class="hljs-number">13</span>;<br><br>void setup<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>println(<span class="hljs-string">"BT is ready!"</span>);<br>  <span class="hljs-comment">// HC-05默认，38400</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);<br>  pin<span class="hljs-constructor">Mode(<span class="hljs-params">ledPin</span>, OUTPUT)</span>;<br>  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;<br>  delay(<span class="hljs-number">500</span>);<br>  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;<br>&#125;<br><br>void loop<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>read<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>print(<span class="hljs-keyword">val</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>read<span class="hljs-literal">()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>print(<span class="hljs-keyword">val</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'1'</span>)<br>      &#123;<br>    <span class="hljs-comment">// 返回到手机调试程序上</span><br>    <span class="hljs-comment">// 此时的蓝牙状态应该正常模式，而不是调试模式</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--high\n"</span>);<br>    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;<br>      &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'2'</span>)<br>      &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--low\n"</span>);<br>    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双蓝牙模块连接（主从模式）"><a href="#双蓝牙模块连接（主从模式）" class="headerlink" title="双蓝牙模块连接（主从模式）"></a>双蓝牙模块连接（主从模式）</h3><p>一个通过连接PC由串口通信（模拟一个设备的指令操作）</p><p>另一个采用Arduino进行点灯来作为从设备的响应动作</p><p>首先需要将其配置</p><p>这里首先采用较为安全的固定地址相连接：</p><ol><li><p>将主设备调试（测试能否正常工作）</p><p>AT</p><p>如果不能，可能是串口波特率问题</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled.png" alt="Untitled"></p><ol><li><p>调整设备通信波特率</p><p>查看波特率：</p><p>AT+UART?</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 1.png" alt="Untitled 1"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">发现波特率不一致为<span class="hljs-number">9600</span>时进行更改，默认状态下就是两个波特率，正常模式下就是<span class="hljs-number">9600</span>，这里我们将其更改为<span class="hljs-number">38400</span>方便调试，当然也可能会带来一定的问题。<br></code></pre></td></tr></table></figure><p>更改波特率：</p><p>AT+UART=38400,0,0</p><ol><li><p>调整主从设备模式</p><p>AT+ROLE=1</p></li><li><p>调整连接模式：</p><p>AT+CMODE=0</p></li><li><p>绑定从机：</p><p>在获取到从机的address之后（查询从机地址指令AT+ADDR?），我们进行绑定：</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 2.png" alt="Untitled 2"></p><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 3.png" alt="Untitled 3"></p><p><strong>注意</strong>：此处将冒号，替换成了逗号（英文状态下的逗号）</p><p>最后，（<del>莫名</del>）成功了，刚开始连接上后，无法正常通信，重启了就好了。</p><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 5.png" alt="Untitled 5"></p><p>从机代码较为简单：</p><p>在对芯片作简要的波特率修正和查询addr之后采用Arduino 编程即可,代码同上不用修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本次的实验中，我们通过PC端连接一个蓝牙模块作为主设备（master）来通过串口发送数据，通过另一个 HC-05 传递数据，进而使得另一边的Arduino设备实现点灯功能。</p><p>主要涉及了串口收发以及对多串口应用的理解，在Arduino和PC通信（下载线）的同时又通过另一个串口和HC05通信，两串口间的数据传递以及在PC屏幕上的数据呈现，要求了我们对于不同串口的特点的理解：即该串口Print将会到何处，该串口Receive将会收到谁的，我们如何呈现到PC（即将PC和设备相连的串口进行发送或者说转发），从而进一步熟悉了数据的流动特点。 </p><p>串口的首发，乃至于说数据包的收发，可以参考另一个<a href="https://github.com/jefine/51MCU_course_design" target="_blank" rel="noopener">WiFi项目的串口收发</a>，也可看出串口通信在实际的物联网通信应用中十分广泛。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HC05采用的是AT指令进行配置， 采用串口通信进行数据传输。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;指令集文档&lt;/a&gt;可以任意在互联网中查找到。&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="HC05" scheme="https://jefine.github.io/tags/HC05/"/>
    
  </entry>
  
  <entry>
    <title>L298N驱动电机</title>
    <link href="https://jefine.github.io/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/"/>
    <id>https://jefine.github.io/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/</id>
    <published>2021-07-08T02:59:07.000Z</published>
    <updated>2021-08-09T08:34:56.257Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍了L298N的接线方式，驱动原理及相关简要代码</p>  <a id="more"></a><h2 id="引脚介绍"><a href="#引脚介绍" class="headerlink" title="引脚介绍"></a>引脚介绍</h2><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298N.png" alt="L298N"></p><h2 id="需要注意事项："><a href="#需要注意事项：" class="headerlink" title="需要注意事项："></a>需要注意事项：</h2><p>L298N的+12V需要电压在 +7VDC to +35VDC.如果使用的电源超过了12V那么请将跳帽拔掉。</p><p>同时需要 mcu 和 L298N 供地。</p><p>H桥中，四个input对应四个output(Terminal)</p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/1.png" alt="1"></p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/2.png" alt="2"></p><p>通过对于IN的控制就可以控制out，促使其连接到的电机正转或着反转（并可以控制速度，PWM？）</p><h2 id="具体操作逻辑："><a href="#具体操作逻辑：" class="headerlink" title="具体操作逻辑："></a>具体操作逻辑：</h2><h3 id="对于普通的马达电机："><a href="#对于普通的马达电机：" class="headerlink" title="对于普通的马达电机："></a>对于普通的马达电机：</h3><p>那么只需要将其正负连接至out1，out2，通过in1，in2来控制正负就可以驱动了。</p><p>对于Arduino 来说更为简单。</p><p>其中ena非必需（采用跳帽，也可达到效果）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Motor Connections</span><br><span class="hljs-comment">//Change this if you wish to use another diagram</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnA 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnB 5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In1 9</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In2 8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In3 7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In4 6</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span><br></span>&#123;<br>  <span class="hljs-comment">// All motor control pins are outputs</span><br>  <span class="hljs-built_in">pinMode</span>(EnA, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(EnB, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In1, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In2, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In3, <span class="hljs-literal">OUTPUT</span>);<br>  <span class="hljs-built_in">pinMode</span>(In4, <span class="hljs-literal">OUTPUT</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goStraight</span><span class="hljs-params">()</span>   <span class="hljs-comment">//run both motors in the same direction</span><br></span>&#123;<br>  <span class="hljs-comment">// turn on motor A</span><br>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-comment">// set speed to 150 out 255</span><br>  <span class="hljs-built_in">analogWrite</span>(EnA, <span class="hljs-number">200</span>);<br>  <span class="hljs-comment">// turn on motor B</span><br>  <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">HIGH</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-comment">// set speed to 150 out 255</span><br>  <span class="hljs-built_in">analogWrite</span>(EnB, <span class="hljs-number">200</span>);<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br>  <span class="hljs-comment">// now turn off motors</span><br>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);  <br>  <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">LOW</span>);<br>  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span><br></span>&#123;<br>  goStraight();<br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="驱动Step-moto-28BYJ-48"><a href="#驱动Step-moto-28BYJ-48" class="headerlink" title="驱动Step moto 28BYJ-48"></a>驱动Step moto 28BYJ-48</h3><p>该继步马达一共拥有五根线，则如果需要采用L298N来驱动，一个L298N那么只能驱动一个继步电机。</p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n1.png" alt="1"></p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n2.png" alt="2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Example sketch to control a stepper motor with L298N motor driver, Arduino UNO and Stepper.h library. More info: &lt;https://www.makerguides.com&gt; */</span><br><br><span class="hljs-comment">// Include the Stepper library:</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Stepper.h&gt;</span></span><br><br><span class="hljs-comment">// Define number of steps per revolution:</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> stepsPerRevolution = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// Initialize the stepper library on pins 8 through 11:</span><br><span class="hljs-built_in">Stepper</span> myStepper = <span class="hljs-built_in">Stepper</span>(stepsPerRevolution, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Set the motor speed (RPMs):</span><br>  myStepper.<span class="hljs-built_in">setSpeed</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Step one revolution in one direction:</span><br>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">500</span>);<br><br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br><br>  <span class="hljs-comment">// Step on revolution in the other direction:</span><br>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">-500</span>);<br><br>  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>参考连接：</p><p><a href="https://www.makerguides.com/l298n-stepper-motor-arduino-tutorial/" target="_blank" rel="noopener">Stepper Motor with L298N and Arduino Tutorial (4 Examples)</a></p><p><a href="https://www.teachmemicro.com/use-l298n-motor-driver/" target="_blank" rel="noopener">How to Use L298N Motor Driver | Microcontroller Tutorials</a></p><p><a href="https://rjdlee.com/arduino-wemos-with-l298n-controller-and-28byj-48-stepper-motor/" target="_blank" rel="noopener">Arduino WeMos with L298N Controller and 28BYJ-48 Stepper Motor</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简要介绍了L298N的接线方式，驱动原理及相关简要代码&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>new_EE</title>
    <link href="https://jefine.github.io/2021/06/03/new-EE/"/>
    <id>https://jefine.github.io/2021/06/03/new-EE/</id>
    <published>2021-06-03T12:34:00.000Z</published>
    <updated>2021-06-03T12:40:28.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新坑IOT方向"><a href="#新坑IOT方向" class="headerlink" title="新坑IOT方向"></a>新坑IOT方向</h2><p>陆陆续续的进行了一些相关方向的内容，今后会多分享一些项目的总结和技术分享。</p><p>加油！</p><p>!&lt;—more—&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新坑IOT方向&quot;&gt;&lt;a href=&quot;#新坑IOT方向&quot; class=&quot;headerlink&quot; title=&quot;新坑IOT方向&quot;&gt;&lt;/a&gt;新坑IOT方向&lt;/h2&gt;&lt;p&gt;陆陆续续的进行了一些相关方向的内容，今后会多分享一些项目的总结和技术分享。&lt;/p&gt;
&lt;p&gt;加油！&lt;/</summary>
      
    
    
    
    <category term="EE" scheme="https://jefine.github.io/categories/EE/"/>
    
    
  </entry>
  
  <entry>
    <title>2021</title>
    <link href="https://jefine.github.io/2021/01/01/2021/"/>
    <id>https://jefine.github.io/2021/01/01/2021/</id>
    <published>2021-01-01T12:45:37.000Z</published>
    <updated>2021-01-24T11:26:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                    <strong>[[2020]]</strong>—-&gt;<strong>[[2021]]</strong></p><p><strong>活着</strong></p><p><img src="/2021/01/01/2021/2021.jpg" alt="2021-2020"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​                                                                    &lt;strong&gt;[[2020]]&lt;/strong&gt;—-&amp;gt;&lt;strong&gt;[[2021]]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="record" scheme="https://jefine.github.io/categories/record/"/>
    
    
    <category term="newyear" scheme="https://jefine.github.io/tags/newyear/"/>
    
  </entry>
  
  <entry>
    <title>atabc173c C - H and V</title>
    <link href="https://jefine.github.io/2020/07/23/atabc173c/"/>
    <id>https://jefine.github.io/2020/07/23/atabc173c/</id>
    <published>2020-07-23T13:21:46.000Z</published>
    <updated>2020-08-10T04:07:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>此题目主要包括了全排列，二进制的相关知识</p>  <a id="more"></a><p><a href="https://atcoder.jp/contests/abc173/tasks/abc173_c" target="_blank" rel="noopener">C - H and V</a>(单击题目可进入下图链接)</p><p><img src="/2020/07/23/atabc173c/Screenshot_2020-07-23 C - H and V.png" alt="2020-07-23 C - H and V"></p><p>题意：第一次看的时候，看的有点呆。</p><p>给定一个矩阵，每个点都被标记为白色或者黑色，然后使你开始刷漆（红漆），一次可以涂一行或者一列，任意涂刷n次（可以是0）求有多少种方案可以使得最终黑色的砖块的数量为所给的数量。</p><p>当时思考：</p><p>opps，不会吧，难道是要暴力？这个怎么暴力？这不可能暴力吧，这么复杂呢。第一行可刷可不刷，第一列可刷可不刷。那么岂不是有很多的情况么，怎么处理呢。当场傻掉。</p><p>题解：</p><p>暴力~~~（逃不过）</p><p>但是采用了和二进制映射map的操作，也就是说 对于每一行我们有两个状态，涂刷或者不涂刷，那么一共有 h 行，w列。行的变化之间是互不关联的，所以说一共有 $2^h$ 种可能，同理 列也有 $2^w$ 种可能的情况，他们都是独立的，所以该涂刷方案一共有 $2^h * 2^w = 2^{(h+w)}$ 种可能的涂刷方案2333.</p><p>注意到数据的范围： 1≤H,W≤6 所以 如果采暴力的方法我们也不过是 $2^{12} = 4096$ 次操作，并不会从boom，是一个相对计算机而言很小的一个数据大小。</p><p>那么如何去储存一个 4096（最大） 种情况呢（其中每一种情况要表示：一共要涂刷的行或者列），我们采用了二进制状态映射的方法（<a href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/">回想之前全排列的二进制方法</a>） 同样这次我们对于 矩阵的行 而言，一共有h行，那么一共有 $2^h$ 种行的不同状态（即不同的涂刷方式）我们就采取二进制的方法记录，这种对于单个单位（如 此处的行）只有两种状态的数据的存储。例如：0b001 可以表示第一行第二行不刷红色，第三行刷红。</p><p>我们采用 0 表示不涂刷，或者表示涂刷都是可以的，无伤大雅（毕竟有一个不刷的状态就会有刷的情况与之对应，我们将全部情况都列出来了 了 了）。所以 十进制下的 $0-(h-1)$ 就可以将  $2^h$ 种状态全部表示出来了。</p><p>如果我们采用的是其他（比如，采用了 用一个矩阵来保存一种可能性的结果的话，那么就需要4000多个矩阵来表示，但想想一个矩阵我们采用一个二维数组emm 过于复杂咯，更何况每个矩阵依旧是需要依次遍历循环 判断黑色个数）</p><p>同理，我们也可以将列的表示如上方式，这样我们就实现了：<strong>采用一个十进制的数字（其实需要的是它所对应的二进制），来表示一行或者一列的涂刷情况了</strong>。</p><p>接着，我们就要判断出该行列状态下的黑砖的数量是不是和题目要求的一致，一致就cnt++。</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> H, W, K;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;H, &amp;W, &amp;K);<br><span class="hljs-keyword">char</span> c[H][W];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; W; ++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c[i][j]);<br>&#125;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; H); ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; W); ++j) &#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// above is the every situation that we may face</span><br><br><span class="hljs-comment">// for each block c[k][l]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; H; ++k) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; W; ++l) &#123;<br><span class="hljs-comment">//i , j = 0b0101 </span><br><span class="hljs-keyword">if</span> (!(i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) &amp;&amp; !(j &amp; (<span class="hljs-number">1</span> &lt;&lt; l)) &amp;&amp; c[k][l] == <span class="hljs-string">'#'</span>) ++cnt;<span class="hljs-comment">//1 red, 0 not red</span><br><br><span class="hljs-comment">//if ((i &amp; (1 &lt;&lt; k)) &amp;&amp; (j &amp; (1 &lt;&lt; l)) &amp;&amp; c[k][l] == '#') ++cnt;//0 red, 1 not red</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (cnt == K) ++ans;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;此题目主要包括了全排列，二进制的相关知识&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="atcoder 二进制" scheme="https://jefine.github.io/tags/atcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hdu1240Asteroids</title>
    <link href="https://jefine.github.io/2020/07/18/hdu1240Asteroids/"/>
    <id>https://jefine.github.io/2020/07/18/hdu1240Asteroids/</id>
    <published>2020-07-18T08:30:07.000Z</published>
    <updated>2021-01-24T11:23:32.366Z</updated>
    
    <content type="html"><![CDATA[<p>Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。</p>  <a id="more"></a><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 7201  Accepted Submission(s): 4454<br>**</strong></p><p>Problem Description</p><p>You’re in space.<br>You want to get home.<br>There are asteroids.<br>You don’t want to hit them.</p><p>Input</p><p>Input to this problem will consist of a (non-empty) series of up to 100 data  sets. Each data set will be formatted according to the following  description, and there will be no blank lines separating data sets.</p><p>A single data set has 5 components:</p><p>Start line - A single line, “START N”, where 1 &lt;= N &lt;= 10.</p><p>Slice list - A series of N slices. Each slice is an N x N matrix representing a horizontal slice through the asteroid field. Each position in the  matrix will be one of two values:</p><p>‘O’ - (the letter “oh”) Empty space</p><p>‘X’ - (upper-case) Asteroid present</p><p>Starting Position - A single line, “A B C”, denoting the <A,B,C>  coordinates of your craft’s starting position. The coordinate values  will be integers separated by individual spaces.</A,B,C></p><p>Target Position - A single line, “D E F”, denoting the <D,E,F> coordinates of your  target’s position. The coordinate values will be integers separated by  individual spaces.</D,E,F></p><p>End line - A single line, “END”</p><p>The  origin of the coordinate system is <0,0,0>. Therefore, each  component of each coordinate vector will be an integer between 0 and  N-1, inclusive.</0,0,0></p><p>The first coordinate in a set indicates the column. Left column = 0.</p><p>The second coordinate in a set indicates the row. Top row = 0.</p><p>The third coordinate in a set indicates the slice. First slice = 0.</p><p>Both the Starting Position and the Target Position will be in empty space.</p><p>Output</p><p>For each data set, there will be exactly one output set, and there will be no blank lines separating output sets.</p><p>A single output set consists of a single line. If a route exists, the  line will be in the format “X Y”, where X is the same as N from the  corresponding input data set and Y is the least number of moves  necessary to get your ship from the starting position to the target  position. If there is no route from the starting position to the target  position, the line will be “NO ROUTE” instead.</p><p>A move can only be in one of the six basic directions: up, down, left, right, forward,  back. Phrased more precisely, a move will either increment or decrement a single component of your current position vector by 1.</p><p>Sample Input</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">START <span class="hljs-number">1</span><br>O<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br>END<br>START <span class="hljs-number">3</span><br>XXX<br>XXX<br>XXX<br>OOO<br>OOO<br>OOO<br>XXX<br>XXX<br>XXX<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>END<br>START <span class="hljs-number">5</span><br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>END<br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-literal">NO</span> <span class="hljs-string">ROUTE</span><br></code></pre></td></tr></table></figure><p>Source</p><p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=South+Central+USA+2001&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> South Central USA 2001 </a> </p><p>poj2225 亦为此题</p><h2 id="题意及要求"><a href="#题意及要求" class="headerlink" title="题意及要求"></a>题意及要求</h2><p>先来说说真实的题意吧：</p><p>题目给出一个三维的图，使得从一个三维的点，从起点到终点最短距离以及能否走到。多次输出题目。</p><p>看似是一道很简单的[[bfs]]题目，其实他就是一道很简单的bfs题目。</p><p>不信你看，本题目其中的bfs的内容就是这样正常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>          <span class="hljs-comment">//  cout&lt;&lt;"x,y,z is  "&lt;&lt;next.x&lt;&lt;" "&lt;&lt;next.y&lt;&lt;" "&lt;&lt;next.z&lt;&lt;"  val is "&lt;&lt;val[next.x][next.y][next.z]&lt;&lt;" CHECK is "&lt;&lt;CHECK(next.x,next.y,next.z)&lt;&lt;endl;</span><br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>但是</strong></p><p>问题来了，这道题还是对我造成了很大的困扰的，因为在数据的输入和存储这一块吃了大亏。</p><p>第一次看完题目，感觉像是给出是一个坐标点，然后所给的数据分成了多层，层与层是可以互通的，就想着把他当作二维的来做。写的时候还感到奇怪，为什么有六种动作呢，不就是只有四种（前后左右）么？还沾沾自喜，感觉自己找到了捷径。。。。。。</p><p>后来吧，总是wa，看了别人的讨论才发现原来题看错了，理解错误（英语还需增强啊，<del>太尬了</del>~~~）</p><p>这个时候的心情再回首回去当时，就感觉当时的自己仿佛是低维空间的生物在理解着三维世界的神奇（并且是失败的那种），科幻的感觉啊啊。</p><p>接着在写正确的三维的版本的时候，仍是接连不断的错误喷涌而来，通过长久的层层的debug（数小时）发现是在输入和储存方面出现了错误，题目给定的是一个接着一个二维图数据，所以需要自己去转化，但是，当时自己只想到了第一层，把高度使用行号/n来判断，他的高度，但是忘记给行号更改了，导致自己出现了错误，许多点没有标记上。（属于坐标错误吧，矩阵储存失败。。。）</p><p>导致了本应很顺利的题目，搞了很久，另外，题目给定的顺序是 列 行，而不是行列，所有还需要自己翻一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(x,y,z) (x&gt;=0&amp;&amp;x<span class="hljs-meta-string">&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;z&gt;=0&amp;&amp;z&lt;n&amp;&amp;!(vis[x][y][z])&amp;&amp;val[x][y][z])</span></span><br><span class="hljs-comment">//val bug</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,z,cnt;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> move[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;<br>&#125;;<br>    <span class="hljs-keyword">bool</span> vis[n][n][n];  <br>    <span class="hljs-keyword">bool</span> val[n][n][n];<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    CLR(val,<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">int</span> A,B,C,D,E,F;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n*n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'O'</span>)val[i%n][j][i/n]=<span class="hljs-number">1</span>;<br>        &#125;<br>        getchar();<br>    &#125;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d %d %d %d\n"</span>, &amp;B,&amp;A,&amp;C,&amp;E,&amp;D,&amp;F);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"END\n"</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>    node t;<br>    t.x = A;t.y= B;t.z =C;t.cnt=<span class="hljs-number">0</span>;<br>    q.push(t);<br>    vis[A][B][C]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"START %d\n"</span>,&amp;n))&#123;<br>        bfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>poj3414Pots</title>
    <link href="https://jefine.github.io/2020/07/16/poj3414Pots/"/>
    <id>https://jefine.github.io/2020/07/16/poj3414Pots/</id>
    <published>2020-07-16T11:25:05.000Z</published>
    <updated>2021-01-24T11:23:42.629Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。</p><p>此题目：细心，冷静，多思考。</p><p>当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。</p>  <a id="more"></a><hr><h4 id="Pots"><a href="#Pots" class="headerlink" title="Pots"></a>Pots</h4><div class="table-container"><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th><th></th><th></th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 31113</td><td></td><td><strong>Accepted:</strong> 12915</td><td></td><td>Special Judge</td></tr></tbody></table></div><p>Description</p><p>You are given two pots, having the volume of <strong>A</strong> and <strong>B</strong> liters respectively. The following operations can be performed:</p><ol><li>FILL(i)    fill the pot <strong>i</strong> (1 ≤ <strong>i</strong> ≤ 2) from the tap;</li><li>DROP(i)   empty the pot <strong>i</strong> to the drain;</li><li>POUR(i,j)  pour from pot <strong>i</strong> to pot <strong>j</strong>; after this operation either the pot <strong>j</strong> is full (and there may be some water left in the pot <strong>i</strong>), or the pot <strong>i</strong> is empty (and all its contents have been moved to the pot <strong>j</strong>).</li></ol><p>Write a program to find the shortest possible sequence of these operations that will yield exactly <strong>C</strong> liters of water in one of the pots.</p><p>Input</p><p>On the first and only line are the numbers <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).</p><p>Output</p><p>The first line of the output must contain the length of the sequence of operations <strong>K</strong>. The following <strong>K</strong> lines must each describe one operation. If there are several sequences  of minimal length, output any one of them. If the desired result can’t  be achieved, the first and only line of the file must contain the word ‘<strong>impossible</strong>’.</p><p>Sample Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2002" target="_blank" rel="noopener">Northeastern Europe 2002</a>, Western Subregion</p><hr><p>题目的中文大约是：给定两个容积为a，b的水壶，初始状态为空；再给一个水量c。每次操作可以如下进行：</p><ol><li>将壶1或者壶2填满；</li><li>将壶1或者壶2全部倒掉；</li><li>将一个壶中的水导入另一个壶中（能倒入多少就倒入多少，当然其中一个壶不能是空的，另一个不能是满的）</li></ol><p>输入abc，需要你输出当其中一个水壶的水量达到c时所用的次数与倾倒步骤打印出来；当然如果永远达不到c的话，输出impossible即可。</p><p>tips：多组输入，c符合规范。</p><p>emm，不妨以此题目为例，梳理一下[[bfs]]的做法好了。</p><p>首先我们要判断这道题目是[[bfs]]，从题目中可以清楚看出，求最短路径，每次的操作是固定的那么基本上就可以用bfs去解决。先看一般，再看特殊的地方需要什么东西来解决（比如题目所求的cnt，步骤）</p><ol><li><p><strong>确定一个状态包括了什么</strong>：比如，有的题目仅仅需要该点的位置，有的题目还需要其他的东西；只能具体问题具体分析了。在此题目中，我们可以看到一个状态就是我们的a，b两个水壶的储水量。</p><p>那么我们将其设定为一个struct node即可包括 两个int 代表两个水壶的储水量。</p><p>特别是考虑到本题目需要cnt和倒水的步骤，那么我们在每个状态里的的步骤都是不一样的，就用string 储存吧，然后每一个步骤添加的时候记得加上换行符号”\n”;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p><strong>寻找vis范围</strong>，确定了总的范围我们才可以利用vis来判断我们是否踩过这个点，这也是最有效的方法来避免死循环,也是迫使队列结束的好方法。有题目给出的“These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).”所以我们知道a有100种可能，b也是。（小提示，如果你发现有题目似乎用不到vis那么大概也许<strong>可能</strong>他不一定需要使用bfs来解题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br></code></pre></td></tr></table></figure><p>对了，记住此题目是多行输入，意味着如果你的vis不及时初始化就会fc</p><p>在这里初始化 vis 可以使用memset，常见用法是这样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br>CLR(vis,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li><li><p>找到起点和终点的状态。终点顾名思义其中有一个水壶的储水量是c的时候就代表了end，而开始我们发现他给定的是两个空的水壶，所以我们给定一个node 初始化全0,记得标记vis是1，然后将其推到队列里作为起始点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>   <br>   node t;<br>   t.cnt=<span class="hljs-number">0</span>;<br>   t.x=<span class="hljs-number">0</span>;<br>   t.y=<span class="hljs-number">0</span>;<br>   t.s=<span class="hljs-string">""</span>;<br>vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure><p>但，不难发现，第一步的走法其实只有给两个壶其中之一填满。所以我们也可以是将其设为两个初始点，添加到队列其中去，但是记得更改相关的数值，参考下code。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node t;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = a;<br>   t.y = <span class="hljs-number">0</span>;<br>   t.s = <span class="hljs-string">"FILL(1)\n"</span>;<br>   q.push(t);<br>   <br>   vis[a][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = <span class="hljs-number">0</span>;<br>   t.y = b;<br>   t.s = <span class="hljs-string">"FILL(2)\n"</span>;<br>   vis[<span class="hljs-number">0</span>][b] = <span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure><p>当然，两者的区别并不是很大，选择前者更容易理解一些，也更加符合一般的bfs的要求。</p></li><li><p>下面就要进入queue队列的循环中去咯~</p><p>进入循环当然先把front给从队列中打捞出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br></code></pre></td></tr></table></figure><p>这里的t 是借用了上面的t实际上,我们往往是重新node next  的做法往往更普遍一些。</p><p>有了 此次开头的中心点，我们就要赶紧确定什么时候能结束了，万一我们直接就出去了呢哈哈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里有一丝丝的玄机，因为这里采用了break，所以我们在最后bfs返回的是cnt的值，所以我们要将cnt给赋值了，才能return 回去。虽然我们在这里就输出了cnt，但返回的cnt是用来判断我们是否是impossible，如果我们一直没有找到使得题目成立条件，而队列走走完了，那我们就一直没有给cnt赋过值，所以我们自然是返回的是0 那么，就可在main函数中做出特判。</p></li><li><p>接下来就是几种动作的出现，其实就是6种</p><p> FILL(1),FILL(2),DROP(1),DROP(2),POUR(1,2),POUR(2,1) </p><p>我们在对其分别进行情况的判定，然后一一进行就可以了。当然这个过程是艰苦的，如果在一些相似的地方没有思考清楚而是cv的话，容易由于没有看清而出现许多问题。所以奥里给，这一部分需要认真一些。</p><p>对了，我们在前面看到我们既然进行到了这一步，一定是出不去了所以front.cnt++；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp">front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// </span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>最后return cnt;就可以结束这个bfs了。小心，因为代码过长，一处很小的错误可能就会gg。</p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>对，你没有看错，两套代码，中英双文嘿嘿，两种代码其实在一些小的方面有所不同，参考第一个即可，第二个是他人代码（出处已不可寻）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">0</span>;<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br><br>    node t;<br>    t.cnt=<span class="hljs-number">0</span>;<br>    t.x=<span class="hljs-number">0</span>;<br>    t.y=<span class="hljs-number">0</span>;<br>    t.s=<span class="hljs-string">""</span>;<br>    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br>        <span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// &lt;?</span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(bfs()==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"impossible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//personal code.</span><br><br><span class="hljs-comment">/*<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;map&gt;<br>#include&lt;set&gt;<br>#include&lt;queue&gt;<br>#include&lt;string&gt;<br>#include&lt;iostream&gt;<br>using namespace std;<br>#define CLR(arr,val) memset(arr,val,sizeof(arr))<br><br>int n , m , x;<br>bool vis[200][200];<br>//图上所有点的取值区域可用 a，b的不同的水量状态表示！<br>struct nodes&#123;<br>int x, y;<br>string step;<br>int cnt;<br>&#125;;<br> <br>int bfs() &#123;<br>int cnt = 0;<br>CLR(vis, 0);//init<br>queue&lt;nodes&gt; q;<br>nodes nd1;<br><br>nd1.x = 0;//(init)<br>nd1.y = 0;<br>nd1.cnt = 0;<br>    nd1.step = "";<br>q.push(nd1);<br>vis[0][0]=1;<br><br>while(!q.empty()) &#123;<br>nodes nd = q.front();<br>q.pop();<br>if (nd.x == x || nd.y == x) &#123;// end<br>cnt = nd.cnt;<br>cout&lt;&lt;cnt&lt;&lt;"\n";// it looks like nothing at all. However this cnt is connect to the return value!<br>                            //there is one possible thing is that we could at the last step that we find the right idea!<br>cout&lt;&lt;nd.step;<br>break;<br>&#125;<br>++nd.cnt;// every time the nd will be renew one as front;<br>nodes nd2;//as next<br>nd2.cnt = nd.cnt; <br>if (nd.x &lt; n &amp;&amp; !vis[n][nd.y]) &#123;//if fronter is not full&amp;&amp; not visit the status when it is full<br>nd2.x = n;<br>nd2.y = nd.y;<br>nd2.step = nd.step + "FILL(1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>if (nd.y &lt; m &amp;&amp; !vis[nd.x][m]) &#123;<br>nd2.x = nd.x;<br>nd2.y = m;<br>nd2.step = nd.step + "FILL(2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>if (nd.x &gt; 0 &amp;&amp; nd.y != m) &#123;//when a is not a empty one &amp;&amp; b is not full<br>if (nd.x &gt;= (m - nd.y) &amp;&amp; nd.x != 0) &#123;//if a couldn't pour it's all to b<br>nd2.x = (nd.x - (m - nd.y));// a will pour as more as it could <br>nd2.y = m;<br>&#125; <br>            else &#123;//a could pour all to b<br>nd2.y = (nd.x + nd.y);<br>nd2.x = 0;<br>&#125;<br><br>if (!vis[nd2.x][nd2.y]) &#123;<br>nd2.step = nd.step + "POUR(1,2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>&#125;<br><br>if (nd.y &gt; 0 &amp;&amp; nd.x != n) &#123;//pour b to a<br>if (nd.y &gt;= (n - nd.x) &amp;&amp; nd.y != 0) &#123;<br>nd2.y = (nd.y - (n - nd.x));<br>nd2.x = n;<br>&#125; else &#123;<br><br>nd2.x = (nd.y + nd.x);<br>nd2.y = 0;<br>&#125;<br>if (!vis[nd2.x][nd2.y]) &#123;<br>nd2.step = nd.step + "POUR(2,1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>&#125;<br><br>if (nd.x &gt; 0 &amp;&amp; !vis[0][nd.y]) &#123;//a is not empty<br>nd2.x = 0;<br>nd2.y = nd.y;<br>nd2.step = nd.step + "DROP(1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>if (nd.y &gt; 0 &amp;&amp; !vis[nd.x][0]) &#123;<br>nd2.x = nd.x;<br>nd2.y = 0;<br>nd2.step = nd.step + "DROP(2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>&#125;<br>return cnt;<br>&#125;<br> <br>int main()<br>&#123;<br>while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;x) &#123;<br>if (bfs() == 0) &#123;<br>cout&lt;&lt;"impossible"&lt;&lt;endl;<br>&#125; <br>&#125;<br>&#125;<br>*/</span><br></code></pre></td></tr></table></figure><p>当然，这道题目还见到有用其他方法去配合bfs进行解题的，</p><p><a href="https://blog.csdn.net/qq_34374664/article/details/53170539" target="_blank" rel="noopener">其他方法之一</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。&lt;/p&gt;
&lt;p&gt;此题目：细心，冷静，多思考。&lt;/p&gt;
&lt;p&gt;当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="poj bfs" scheme="https://jefine.github.io/tags/poj-bfs/"/>
    
  </entry>
  
  <entry>
    <title>BFS小结</title>
    <link href="https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/"/>
    <id>https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/</id>
    <published>2020-07-15T07:52:04.000Z</published>
    <updated>2021-01-24T11:22:14.986Z</updated>
    
    <content type="html"><![CDATA[<p>BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.</p><p>todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）</p>  <a id="more"></a><h2 id="BFS是什么"><a href="#BFS是什么" class="headerlink" title="BFS是什么?"></a>BFS是什么?</h2><blockquote><p> <strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href="https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">图形搜索算法</a>。简单的说，BFS是从<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">根节点</a>开始，沿着树的宽度遍历树的<a href="https://zh.wikipedia.org/wiki/节点" target="_blank" rel="noopener">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。  (<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">链接</a>)</p></blockquote><h2 id="BFS流程是"><a href="#BFS流程是" class="headerlink" title="BFS流程是?"></a>BFS流程是?</h2><p>从起点出发,将到终点之间将所有的路几乎全部走一遍。</p><p>一般用来寻找最短路程.</p><p>思想上来说是穷举所有的情况,踩遍所有的可能点或找到终点。</p><p>我们通常是这样做的:</p><p>需要: </p><ul><li><p>一个状态所需要的内容作为一个节点。（比如坐标等）</p></li><li><p>一个足够大的位置集合,来表示我们是否来过(可能是二维数组甚至更高维度，也可能是其他的形式，要看具体状态的要求).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[max];<br></code></pre></td></tr></table></figure></li><li><p>一个队列,表示我们即将将队列中的每一个元素作为一个新的起点去重新出发.(queue).</p></li><li><p>一个起点,一个终点.</p></li><li><p>可能需要: 一个记录步数的数组(或其他形式),用来记录是第几步向外，一般放在节点结构里.int step[];</p></li></ul><h4 id="什么时候开始"><a href="#什么时候开始" class="headerlink" title="什么时候开始?"></a>什么时候开始?</h4><p>我们常常从起点开始<del>(废话)</del>, 起点仅仅只有一个点, 我们先将其标记一下,表示我们来过了,然后我们将其加入队列.</p><p>我们将从起点开始的每一个可能可以去的位置,都进行遍历,然后将它们添加到队列中去.</p><p>上面的步骤可以说是每一道题目的必需步骤了,然后我们就要依据题目的条件进行分析咯~</p><h4 id="我们什么时候结束"><a href="#我们什么时候结束" class="headerlink" title="我们什么时候结束?"></a>我们什么时候结束?</h4><p><strong>当队列为空的时候</strong>,何时队列为空呢——当我们踩扁所有的点的时候(不能踩的当然就算了).</p><p>我们依据题目,在地图上的点,并不是每个点都可以踩的,<del>要不然还这么辛苦干么.</del></p><p>那我们就要总结出来: 什么是往下一个点的规律(可以往那里移动?),什么点是不能踩的,约束条件是什么.</p><p>所以,我们往往判断一个点可不可以踩的时候我们要对他有很多的约束条件.</p><p>例如，在二维的地图上，不能越界，不能进入禁止的点，没有来过此点等等。</p><p>例如,小老鼠走迷宫的问题:那么我们就可以根据题目,得到我们小老鼠不能碰的那些点,每次小老鼠可以怎样走动呢?上下左右都可以走,我们就还要判断他们是否出界.进行挑选出那些<strong>从一点可以到该点所能触及的所有不违反规则的点</strong>,别忘了,我们还要判断他们是不是我们要寻找的终点.</p><p>在一层一层的脱离过程中我们会发现还要根据题目要求记下一些东西,往往是所走的路程是多少,那么刚刚提及的最后一个记录步数的数组就可以起效了,我们往往这样使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">step[next] = step[front]+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>因为我们从一点出发往往会经过许许多多的点,然而这些点都是我们一步可以走到的点.不能将他们累加起来作为我们的实际步数.</p><p>宏观上看,我们其实更像是一个池塘中的波纹,每一个波纹有小及大的向外扩散.那么看起来与BFS的算法思想是极为相似的,我们也是从一点抛下一颗小石子,然后等波纹自己寻找到终点(水中的另外一颗小石头的位置).可以想象到我们如果碰触到终点后不停止,那么水波将不断的向远处扩散,知道池塘全部被波及.但我们往往不需要那样做,那样通常是最坏的情况了(也意味着我们要踩所有的可能点呢).</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h4><ol><li>首先将根节点放入队列中。</li><li>从队列中取出第一个节点，并检验它是否为目标。 <ul><li>如果找到目标，则结束搜索并回传结果。</li><li>否则将它所有尚未检验过的直接子节点加入队列中。</li></ul></li><li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li><li>重复步骤2。</li></ol><p>其中重要 的就是我们需要限制的约束条件和下一个位置的可能点.</p><p>当然[[bfs]]是一个思想并不拘泥于为某道题目而服务,所以我们往往需要多加练习,在面对求最短路径的时候,才能从容不迫的写出题解.</p><h3 id="需要注意的几个小点点："><a href="#需要注意的几个小点点：" class="headerlink" title="需要注意的几个小点点："></a>需要注意的几个小点点：</h3><ol><li><p>vis是为了防止我们将踩过的点再次踩入</p><p>想象一下，我们水花的方向是四周的一圈，那么也一定会有的向着我们已经走过的路的水波方向，我们要做好辨别工作，那么就给他们加上一个vis的判断。他们的范围就是所有的可能涉及的区域集合。可能通常是数组。</p><p>这样，我们不必花费过多的时间去判断该行为是否会造成逆流，我们只需要进行有效的标注即可！</p><p>杜绝了同样的状态二次出现！</p></li><li><p>我们通常会遇到需要记录层数的时刻，那么最好是使用一个node 里面放上cnt来记录当前节点的层数。</p></li><li><p>我们在对于一个节点进行多个动作时候，需要注意，我们要将其恢复为front的状态，或者更方便一些的，我们直接将其 cnt++；在循环的过程中，我们一直采用front来判断条件或者是对即将入队的节点进行赋值。</p><p>eg：在洛谷1135的题目中我们在队列的循环过程中的front进行变动的做法：而不是对t进行改动。在其他的题目中也经常适用，不要改变t，除非即将入队，判断采用front的+-等进行操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t.cnt = front.cnt+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(CHECK((front.h+high[front.h])))&#123;<br>    t.h = front.h+high[front.h];<br>    vis[t.h] = <span class="hljs-number">1</span>;<br>    q.push(t);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们如果需要记录可以达到多少个点，那么我们在队列中，只要 !vis 我们就可以给他count++；一般是放在动作里面的。如上面的代码情况就放在vis[t.h]=1 下面一行即可。</p></li><li><p>如果我们需要遍历出到每一个点的最短步数，如洛谷p1443，我们最暴力的想法就是给定每一点作为终点，不断地去跑bfs，然而这样是复杂度很高的，完全没有必要这样做，我们既然目标是所有的点，那么我们再 声明一个和vis的范围相同的一个ans数组来记录一个queue的每个点（！vis）的时候的步数即可，未记录的即为无法达到，通过遍历ans数组即可获得相关内容。</p></li><li><p>遇到三维的状态（hdu1204）时，只需要注意输入，接着按照正常的bfs动作流程即可。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.&lt;/p&gt;
&lt;p&gt;todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>输出全组合二进制</title>
    <link href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/</id>
    <published>2020-07-04T11:48:29.000Z</published>
    <updated>2020-08-10T04:08:57.143Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。</p>  <a id="more"></a><p>首先：辨析一下排列和组合的区别。</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列： </p><script type="math/tex; mode=display">\frac{n!}{(n-k)!}</script><p>组合：</p><script type="math/tex; mode=display">\frac{n!}{(n-k)!*k!}</script><p>可以看出排列的数目<strong>大于等于</strong>组合的数目，以及他们的计算方式如上图。公式来源详见<a href="https://zhuanlan.zhihu.com/p/41855459" target="_blank" rel="noopener">解析链接</a>，这很快帮助你回忆如何计算。</p><hr><p>回归题目：</p><p>n个元素的子集一共有 $2^n$个（从下面的对应关系中的二进制数也可看出的确是$2^n$)</p><p>那么他们此间的对应关系是这样的：</p><script type="math/tex; mode=display">\begin{Vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{Vmatrix}</script><p>这个神奇的的排列规律是我们进行下面编程的理论（可以从二进制看子集与十进制）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n=<span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//解释一下1&lt;&lt;n是位运算，结果是2^n</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&amp; (<span class="hljs-number">1</span>&lt;&lt;j))<span class="hljs-comment">//其中i只在第一次空集的时发挥作用。</span><br>            <br>            <span class="hljs-comment">//这里巧妙地运用了二进制的知识，并且运用位运算的性质，得到结果</span><br>            <br>            <span class="hljs-built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">" "</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>刚开始，觉得这个输出很神奇，直接输出了n个数字的所有集合（还按照一定的顺序），代码还十分简洁。</p><p>其中两个for循环中的if判断可谓是亮点了。</p><p>那么究竟是什么意思呢，记住这里还要会回顾一下那个表格了：</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (<span class="hljs-name">i</span> &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure><p>首先明确一下 <strong>“&amp;”：<em>与</em>， 即在二进制中 </strong>同一为一（取每一位二进制的数字，两者均为1时为1）：</p><p>例如 0001 &amp; 0011为 1；</p><p>​        0010 &amp;  0001为0。</p><p>此行代码中的’ i ‘指的是二进制数中1的个数，可以发现在二进制中第一次i==0，而二进制数中不含1的只有空集，与结果相对应；</p><p>接着我们分析<strong>i==1</strong>时刻，判断条件其实可以替换为（0001 &amp; ( i&lt;&lt;j )),这是说明只有二进制数最后一位为1的才能呵前面$1_{(10)}$或者说$0001_{(2)}$相 “与&amp;” 为真。那么我们可以看出只有1 3  5 7这样的奇数才满足尾数为1，才能使得条件成立。BUT我们分析一下判断条件里的另一个变量1&lt;&lt;j，代表的是$2^n$，也就是说只有j==0的时候，才成立，这也就是第二行结果“0”的来历；</p><p>同理我们可以分析出<strong>i==2</strong>，即二进制的0010的时候只有j==1的时候才成立；</p><p><strong>i==3</strong>的时候，即左边为$0011_{(2)}$的时候这个时候只要是 在最后一位为一或者倒数第二位数字是一的二进制数即可，也就是说 十进制的0，1，3，5，7都可成立。但是 要注意的是 （i&lt;&lt;j)只能为十进制的$2^n$,所含的奇数只有1。所以除0，1外的j均不成立。</p><p>经过上面的分析我们<del>不得不</del>对代码的正确性给予了肯定，但好像还是不太清楚为什么能够这样做。</p><p>那我们不妨回首二进制。</p><p>不难发现，我们最终并没有用到3，4，5，6，7这样的十进制数字（尽管他们在上表中有所对应，但那也不过是各种情况的编号罢了，），只是用了0，1，2这恰好是[0,n)的范围内的数字。大胆推测 只有当i的数字越大那么在j中二进制中的1 出现的概率越大，（tips，$0111_{(2)}$恰好是7，二进制中的1的个数是（2+1）个1 emm~）。例如$7_{(10)}$ 对应$0111_{(2)}$那么他就可以有三个数字的集合成立了（果然是012）</p><p><del>上面一段有点饶头，仔细想想，都是对的，但似乎没什么用~可以无视</del>~~</p><p>自己在不断探索的过程中，仍能够不断的发现二进制的奇妙用途，和神奇1 的对应。此题还需慢慢回味。</p><hr><p>​    数日后，再次回顾此代码，发现有着许多的新的感悟：之前不太明白的地方都一一揭开：</p><p>首先就是</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制(i)&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><p>哈哈，这个和上图的有什么区别呢？<del>并没有</del>，只是多了一个标识i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure><p>回顾代码：不难看出其实对于作者的行为我<del>们</del>是有一些困惑的。为什么要这样做？</p><p>那我们不妨解释一下i和j的作用好了</p><p><strong>i</strong>  :其实对应的是上表中的对应的十进制：也就是说，我们将i循环了$n^2$次，其实就是恰好我们将这n个子集打印出来。</p><p><strong>j</strong>  :其实是二进制的从低到高位依次赋值1，并判断是否&amp;，1&lt;&lt;j 其实就是 $2^j$ 次方wow，当j为0时其实就是二进制的最后一位为1，j=1时判断倒数第二位是否为1。那么判断的另一个对象是谁呢？当然是i。</p><p>每一个i的二进制都不相同，我们就可以依次利用j来判断该位上是否有数字有的话就把j输出出去，j是[0,n)所以可以利用二进制完美地实现所有子集的输出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>负数二进制（码制与数制）</title>
    <link href="https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/"/>
    <id>https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/</id>
    <published>2020-06-28T06:56:31.000Z</published>
    <updated>2021-01-24T11:21:02.340Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和<strong>应用</strong>，后者为重点）</p>  <a id="more"></a><h2 id="二进制的计算"><a href="#二进制的计算" class="headerlink" title="二进制的计算"></a>二进制的计算</h2><p>在此次的课程中在开始便讲述了二进制的计算：</p><p>但其均为正数的时候，计算较为简单和一般的十进制的计算无异（竖式）</p><p>但是当其为负数的时候我们就要多加一个步骤了</p><p>在这里，先补充以下编码：</p><p><strong>编码：</strong></p><p>我们常常将信息通过编码储存起来。</p><blockquote><p>信息编码（Information Coding）是为了方便信息的存储、检索和使用，在进行信息处理时赋予信息元素以代码的过程。即用不同的代码与各种信息中的基本单位组成部分建立一一对应的关系。信息编码必须标准、系统化，设计合理的编码系统是关系信息管理系统生命力的重要因素。</p><p>信息编码的目的　信息编码的目的在于为计算机中的数据与实际处理的信息之间建立联系，提高信息处理的效率。</p></blockquote><p>我们在小学（可能，大雾）的时候，就已经学过如何将十进制和二进制进行相互的转化。</p><p>但是，在当时，出于年纪小，我们并没有学会如何实现负数的运算。</p><p>那么，首先我们康一下：<strong>负数二进制是如何表示的</strong>。</p><p>有人说：在最前添加一bit（一位）：1代表负数，0代表正数。</p><p>那么在计算的时候我们是不是就可以直接去计算了呢？</p><p>并不是这样的我们这样去计算的话就犯下一个错误：</p><p>将<strong>数制和码制混淆。</strong></p><p><strong>数制：</strong>即<strong>计数制，数数的方法。</strong>是指十进制二进制，八进制此类的进制。</p><p><strong>码制</strong>（用编码的方式表示信息<strong>,即用不同数码表示不同事物时遵循的规则。</strong>例如：学号，身份证号，车牌号）:与前者不同的是，码制表示的并不真的只是一个数字，而是一个信息。人们通过编码的方式将他们转化为数字（不同进制均可）。这就涉及到了 信息→数字 的转换。同样不同的编码方式，所得出的结果自然是不同的。所以也可以用来加密。常用的有：BCD，ASCII等。</p><p>目前，数字电路中都采用二进制。</p><ol><li><p>表示数量时称二进制</p></li><li><p>表示事物时称<strong>二值逻辑</strong></p><p>好了，回归正题~</p><hr></li></ol><p>其实按照我们正常的思路我们自己是希望能够按照十进制的方式（竖式）去进行计算的。</p><p>在有了前面的基础之后，我们自己对于码制和数制有了一定的了解。那么我们是不是可以计算负数二进制了呢?</p><p>并不是，首先我们要将负数的二进制标识出来吧。</p><p>假设我们向上面所说的添加一个负号，</p><p>那么是不是我们可以推出呢:</p><script type="math/tex; mode=display">-13_{(10)} = -1101_{(2)}</script><p>To be honest:</p><p>我们很想让它成为这样的但是并不可行。</p><p>这里可以去随意尝试一个例子即可（例如 -13+10）</p><p>我们会发现计算的结果转化为10进制之后是错的。</p><p>为什么呢，<strong>就是码制和数制之间，我们搞混了</strong>。负数的二进制的第一个1是码制，代表的是一个含义：负数，而我们在计算的时候将其作为一个数值进行了计算，自然错误。那么有解决的方法么？</p><p>当然，那么我们应该在哪里修改呢？</p><p>在二级制的负数表达上进行修改！</p><p>事实上，如果我们去计算器（高级计算器）上实行进制转换。我们会发现-13，并不是单纯的将13的二进制前一位添加了一个1，而是添加在最前1之后，将13的<strong>二进制取反，然后将这个二进制+1.</strong></p><p>那么我们怎么去理解这个二进制的意思呢？</p><p>举个例子： </p><script type="math/tex; mode=display">-13_{(10)} = 10011_{(2)}</script><p>是指 第一个数字作为 负数，其余仍为正数：</p><script type="math/tex; mode=display">\begin{array}{cc} 1&0&0& 1& 1 \\ -16*1&8*0&4*0&2*1&1*1\\\end{array}</script><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>二进制的负数的运算既在我们的意料之中，又在我们的意料之外。惊喜连连~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和&lt;strong&gt;应用&lt;/strong&gt;，后者为重点）&lt;/p&gt;</summary>
    
    
    
    <category term="数字电路" scheme="https://jefine.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hdu1237计算器</title>
    <link href="https://jefine.github.io/2020/06/07/hdu1237%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://jefine.github.io/2020/06/07/hdu1237%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2020-06-07T02:26:22.000Z</published>
    <updated>2020-08-10T04:10:45.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1237" target="_blank" rel="noopener">简单计算器</a></h1>  <a id="more"></a><p>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 36334  Accepted Submission(s): 13065</p><p>Problem Description</p><p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。</p><p>Input</p><p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p><p>Output</p><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><p>Sample Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span>+ <span class="hljs-number">2</span> * <span class="hljs-number">5</span> - <span class="hljs-number">7</span> / <span class="hljs-number">11</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3.00</span><br><span class="hljs-number">13.36</span><br></code></pre></td></tr></table></figure><p>Source</p><p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%D5%E3%B4%F3%BC%C6%CB%E3%BB%FA%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C9%CF%BB%FA%BF%BC%CA%D4-2006%C4%EA&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 浙大计算机研究生复试上机考试-2006年 </a> </p><p>解题思路：</p><p>主要是采取了两个栈来保存操作符和运算数字。</p><p>另外：亮点在于P(c) &lt; P(op.top())这里的优先级比较：</p><p>我们可以发现通过表格或者其他的形式可以看出在运算优先级的问题上，我们只有采取这样的策略才是最好的。</p><p>当前的优先级高那么压入栈，当前优先级和栈顶（上次的）的优先级相同，或小于上次的话，自然时先算上次的，同时这样的模拟也是最符合我们自己的真实的运算过程的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Ans</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) <span class="hljs-keyword">return</span> x + y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> x - y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'*'</span>)<span class="hljs-keyword">return</span> x*y;<br>    <span class="hljs-keyword">return</span> x / y;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))<br>    &#123;<br>        <span class="hljs-keyword">char</span> c = getchar();<br>        <span class="hljs-keyword">if</span> (c==<span class="hljs-string">'\n'</span>&amp;&amp;n == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; op;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">double</span>&gt;num;<br>        num.push(n);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<span class="hljs-comment">//开始一行的运算，之前已经获取了一个n，并压入num；</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c %d"</span>, &amp;c, &amp;n);<br>            <span class="hljs-keyword">char</span> k = getchar();<br>            <span class="hljs-keyword">while</span> (!op.empty()&amp;&amp;P(c)&lt;=P(op.top()))<span class="hljs-comment">//第一次会跳过</span><br>            <span class="hljs-comment">//当操作符的栈不为空……且现在的操作符优先级小于或等于栈顶的的操作符的优先级时</span><br>            <span class="hljs-comment">//那么先将之前的进行计算</span><br>            &#123;<br>                <span class="hljs-keyword">char</span> t = op.top();<br>                op.pop();<br>                <span class="hljs-keyword">double</span> y = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> x = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>                num.push(ans);<br>            &#125;<br>            op.push(c);<br>            num.push(n);<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//这导致了上面还有压入的数字和操作符未被操作，便有了下面的判断op栈</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (!op.empty())<br>        &#123;<br>            <span class="hljs-keyword">char</span> t = op.top();<br>            op.pop();<br>            <span class="hljs-keyword">double</span> y = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> x = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>            num.push(ans);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>, num.top());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简单计算器&quot;&gt;&lt;a href=&quot;#简单计算器&quot; class=&quot;headerlink&quot; title=&quot;简单计算器&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1237&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简单计算器&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="hdu 栈" scheme="https://jefine.github.io/tags/hdu-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>pta六度空间</title>
    <link href="https://jefine.github.io/2020/06/04/pta%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <id>https://jefine.github.io/2020/06/04/pta%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</id>
    <published>2020-06-04T13:32:34.000Z</published>
    <updated>2021-01-24T11:23:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>“<a href="http://pta.patest.cn/pta/test/15/exam/4/question/715" target="_blank" rel="noopener">六度空间</a>”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。</p>  <a id="more"></a><p><img src="https://images.ptausercontent.com/35" alt="t"></p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><p><strong>输入格式说明：</strong></p><p>输入第1行给出两个正整数，分别表示社交网络图的结点数N （1&lt;N&lt;=104，表示人数）、边数M（&lt;=33*N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p><p><strong>输出格式说明：</strong></p><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>: <span class="hljs-number">70.00</span>%<br><span class="hljs-number">2</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">3</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">4</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">5</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">6</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">7</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">8</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">9</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">10</span>: <span class="hljs-number">70.00</span>%<br></code></pre></td></tr></table></figure><h3 id="一点理解："><a href="#一点理解：" class="headerlink" title="一点理解："></a>一点理解：</h3><p>时隔一个多月，再次做到此题目，发现并不会写了（<del>并不是</del>),甚至原来的题解，也不会写了，回想起来，自己还写过题解，特此更新。。。发现原来写的题解具有一定的局限性，并不是十分好理解，所以特此更新呢。</p><p>以下为原题解：</p><p>乍一看题目所求有些懵，其实所求的是每个节点相邻的6层之内的节点个数与总结点的比例；</p><p>那么我们只需要求出每个节点的相邻六层的节点的个数（bfs）</p><p>在bfs中我们还需要注意一下，我们在统计个数的时候还有记得数层数，够了层数就不再去数数了。</p><p>所以引申出来层数的判断，那么如何确定到那一层了呢？</p><p>采用的就是tail和last的不断更新（详见代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10005</span>;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[maxn];<br><span class="hljs-keyword">int</span> vertices, edges;<span class="hljs-comment">//所有的顶点数和边数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;i++)&#123;<br>        vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//init vis[]</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> tail;<br>    <span class="hljs-keyword">int</span> last = v;<span class="hljs-comment">//指的是每一圈的最后一个（每一个外圈的的每一个顶点都要入队，当该外圈的最后一个也出队了，那么这一层也循环完了</span><br>    <span class="hljs-keyword">int</span> count =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;<br>    vis[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    q.push(v);<br><br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        <span class="hljs-keyword">int</span> x = q.front();<span class="hljs-comment">//get the first每一圈的每一个顶点</span><br>        q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;g[x].size();j++)&#123;<span class="hljs-comment">//判断条件是与x相连的所有顶点的个数</span><br>            <span class="hljs-keyword">if</span>(!vis[g[x][j]])&#123;<br>                vis[g[x][j]] = <span class="hljs-literal">true</span>;<br>                q.push(g[x][j]);<br>                tail = g[x][j];<span class="hljs-comment">//每次都将替换更新，最后得到的是该节点的最后一个相连顶点</span><br>                count++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span>(x==last)&#123;<br>            <span class="hljs-comment">/*这里指的是我们将该层全部弹出时应所满足的条件<br>            注意第一次的时候是直接成立的<br>            而在第二圈（或更多）的时候，我们将<br>            第一个节点的最后一个遍历的节点作为tail<br>            然后他就成为了last即上一层的最后一个元素<br>            */</span><br>            last = tail;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(level==<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>         &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        g[x].push_back(y);<span class="hljs-comment">//建立两者之间边的关系</span><br>        g[y].push_back(x);<span class="hljs-comment">//认识是相互的，所以相互加关联</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>下面是一个月后经过了几道[[bfs]]题目熏陶后的想法:</p><p>首先读题，发现题目要求我们输出比例，显然总结点数已经给出，那么得到每一个节点的6层以内的节点数即可。</p><p>接着题目有给定了节点之间的关系，所以我们自己可以通过一个bool类型的rel(relative)的二维数组来确定两者的关系是否连通。（这一步可以在main函数中实现）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <br>    <span class="hljs-built_in">memset</span>(ral,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(ral));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        ral[x][y]=<span class="hljs-number">1</span>;<br>        ral[y][x]=<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来，我们就要把他传入bfs中了，然后使得bfs返回该节点符合关系的节点数目即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br></code></pre></td></tr></table></figure><p>在bfs 的函数中，我们很显然，起点就是我们给定的j，j即为起始点，由<strong>他出发寻找到在六层内不同的节点的个数。</strong></p><p>从这个任务中我们也可得出一个状态的内容是它自身的节点名称（在此题目中是一个int值）还要有一个cnt来表示层数，方便我们作为层数的限制条件，这在其他的bfs题目中，层数亦十分有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> cnt;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure><p>哦，我们不能忘我们刚刚给的要求了，不同的节点，相同的节点找他干嘛。。。所以还要有一个vis的一维数组，范围是所有节点数量，表示他们是否被访问过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-keyword">bool</span> ral[maxn][maxn];<br></code></pre></td></tr></table></figure><p>那么bfs的结束条件是？队列结束或者达到节点6层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>    <span class="hljs-built_in">queue</span>&lt;node&gt;q;<br>    vis[v]=<span class="hljs-number">1</span>;<br>    node t;<br>    t.cnt = <span class="hljs-number">1</span>;<br>    t.val = v;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(front.cnt&gt;<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>        t.cnt = front.cnt+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=vertices;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ral[front.val][i]&amp;&amp;!vis[i])&#123;<br>                vis[i]=<span class="hljs-number">1</span>;<br>                count++;<br>                t.val = i; <br>                q.push(t);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>bfs里面的cnt&gt;或是&gt;=我是猜的，可以通过数据检验，稍微改改就凑上了。。省得麻烦考虑了，不过最好还是考虑周全。</p><p>在这里val的数据范围是[n] [n]或者说直接定义1001（因为题目给定的数据n&lt;=10^3)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“&lt;a href=&quot;http://pta.patest.cn/pta/test/15/exam/4/question/715&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;六度空间&lt;/a&gt;”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="pta" scheme="https://jefine.github.io/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>pta拯救007</title>
    <link href="https://jefine.github.io/2020/06/03/pta%E6%8B%AF%E6%95%91007/"/>
    <id>https://jefine.github.io/2020/06/03/pta%E6%8B%AF%E6%95%91007/</id>
    <published>2020-06-03T11:57:38.000Z</published>
    <updated>2020-08-10T04:11:47.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目详情："><a href="#题目详情：" class="headerlink" title="题目详情："></a>题目详情：</h2><p>在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）<br>设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。</p>  <a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>首先第一行给出两个正整数：鳄鱼数量 N（≤100）和007一次能跳跃的最大距离 D。随后 N 行，每行给出一条鳄鱼的 (x,y) 坐标。注意：不会有两条鳄鱼待在同一个点上。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>如果007有可能逃脱，就在一行中输出”Yes”，否则输出”No”。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><p>14 20<br>25 -15<br>-25 28<br>8 49<br>29 15<br>-35 -2<br>5 28<br>27 -29<br>-8 -28<br>-20 -35<br>-25 -20<br>-13 29<br>-30 15<br>-35 40<br>12 12</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><p>Yes</p><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><p>4 13<br>-12 12<br>12 12<br>-12 -12<br>12 -12</p><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><p>No</p><h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>这道题目的解题中使用到了dfs和图的相关知识，</p><p>p[]是所输入的每个节点的数组（鳄鱼的集合）</p><p>vis[]是判断是否该节点被访问：</p><p>如果被访问过了，那么只有两种情况：1.找到出口，直接弹出（break）。2.没有出口~</p><p>所以如果节点被访问过，就意味着该节点不是出口。</p><p>另外注意我们还有对于第一次的中心岛的特殊判断，他的距离与其他的dfs过程不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,d;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>//定义节点（存储<span class="hljs-title">x</span>，<span class="hljs-title">y</span>坐标）<br>&#123;</span> <br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;p[<span class="hljs-number">110</span>];  <br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<br><span class="hljs-keyword">bool</span> flag =<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">first</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断该节点是否可以在第一次可以跳出中心岛（即判断该点是否在第一次跳出的半径内）</span><br>    <span class="hljs-keyword">return</span>(p[i].x*p[i].x+p[i].y*p[i].y &lt;= (d+<span class="hljs-number">7.5</span>)*(d+<span class="hljs-number">7.5</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">success</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断能否在该结点处一次直接跳出（d&gt;0），分别判断x，y是否可以跳出边界(即能否一步上岸)</span><br>    <span class="hljs-keyword">return</span> p[i].x-d&lt;=<span class="hljs-number">-50</span>||p[i].x+d&gt;=<span class="hljs-number">50</span>||p[i].y+d&gt;=<span class="hljs-number">50</span>||p[i].y-d&lt;=<span class="hljs-number">-50</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<span class="hljs-comment">//判断是否可以从一点跳到另一点</span><br>    <span class="hljs-keyword">return</span> (p[i].x*p[i].x+p[i].y*p[i].y)&lt;d*d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//递归，dfs判断是否可以找到出去的路</span><br>    vis[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//表示已经访问该节点</span><br>    <span class="hljs-keyword">if</span>(success(i))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-comment">//遍历寻找节点</span><br>        <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;isJump(i,j))<br>        &#123;<span class="hljs-comment">//如果该点访问过，那么此路就代表不通，应该放弃这个点；同时我们还要找到可以跳跃过去的点。</span><br>        <span class="hljs-keyword">if</span>(dfs(j))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d&gt;=<span class="hljs-number">42.5</span>)flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//应该通过遍历找到符合条件的节点</span><br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;first(i))<span class="hljs-comment">//如果没有访问过这个节点，且在第一次跳出的半径内。</span><br>                <span class="hljs-keyword">if</span>(dfs(i))&#123;<br>                    flag =<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出并不再寻找</span><br>                &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"yes"</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"no"</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目详情：&quot;&gt;&lt;a href=&quot;#题目详情：&quot; class=&quot;headerlink&quot; title=&quot;题目详情：&quot;&gt;&lt;/a&gt;题目详情：&lt;/h2&gt;&lt;p&gt;在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）&lt;br&gt;设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="pta" scheme="https://jefine.github.io/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>阿里云-身份证识别调用</title>
    <link href="https://jefine.github.io/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/"/>
    <id>https://jefine.github.io/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-17T09:54:27.000Z</published>
    <updated>2020-08-10T04:07:57.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>首先，这里选用的sdk是java（支持本地上传版本）和python</p><p>阿里云的sdk最好是通过maven来导入，而且在<strong>使用maven的时候注意将镜像设置为阿里云</strong>，否则会很慢。</p>  <a id="more"></a><h4 id="AccessKey"><a href="#AccessKey" class="headerlink" title="AccessKey"></a>AccessKey</h4><p>记得在阿里云上申请（目前免费）accessKey 及密码。</p><p>并将其放在application. properties 处</p><h4 id="在线测试"><a href="#在线测试" class="headerlink" title="在线测试"></a><a href="https://help.aliyun.com/document_detail/151899.html?spm=a2c4g.11186623.6.603.46ba4dd3pI0g28" target="_blank" rel="noopener">在线测试</a></h4><p>发现可以在线测试呀！！！而且可以使用临时生成的accesskey自动进行，wow!</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/onlineTest.png" alt="onlineTest"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><del>并不会！（嘤嘤嘤）</del>（勉强会一点点的python（借助样例））</p><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><p>参考了一份（java嘿嘿）</p><p>主要需要编写的有：</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pic.png" alt="pic"></p><h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><p>首先需要使用 <code>pip install aliyun-python-sdk-core</code>  命令，安装阿里云SDK核心库 。</p><p>然后执行下载文字识别包：<code>pip install aliyun-python-sdk-ocr</code> </p><p>新建.py文件见下列代码cv，然后将自己的ak填入即可。之后在url的地方图片的链接（仅支持阿里云的oss，代码中给出了一个示例，可以使用）</p><p>下面的set_Side就是正反面</p><p>运行即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> aliyunsdkcore.client <span class="hljs-keyword">import</span> AcsClient<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ClientException<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ServerException<br><span class="hljs-keyword">from</span> aliyunsdkocr.request.v20191230.RecognizeIdentityCardRequest <span class="hljs-keyword">import</span> RecognizeIdentityCardRequest<br><br>client = AcsClient(<span class="hljs-string">'&lt;accessKeyId&gt;'</span>, <span class="hljs-string">'&lt;accessSecret&gt;'</span>, <span class="hljs-string">'cn-shanghai'</span>)<br><br>request = RecognizeIdentityCardRequest()<br>request.set_accept_format(<span class="hljs-string">'json'</span>)<br><br>request.set_ImageURL(<span class="hljs-string">"http://explorer-image.oss-cn-shanghai.aliyuncs.com/1786373016143448/index.jpg?OSSAccessKeyId=LTAI4Fk9FstqSEYnqKJ5Dpeo&amp;Expires=1589709652&amp;Signature=wdCT6OMdBw2mvOdvVecgkDWtqcI%3D"</span>)<br>request.set_Side(<span class="hljs-string">"face"</span>)<br><br>response = client.do_action_with_exception(request)<br><span class="hljs-comment"># python2:  print(response) </span><br>print(str(response, encoding=<span class="hljs-string">'utf-8'</span>))<br></code></pre></td></tr></table></figure><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pyresult.png" alt="pyresult"></p><p>上图是python的测试结果。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试图片（图源网络）</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/images.jpg" alt="images"></p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/index.jpg" alt="index"></p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/result.png" alt="result"></p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>基本符号要求。（总算成功了）</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>基于阿里云开放平台我们可以便捷使用的工具还有很多很多， 包括人脸人体、文字识别、商品理解、内容安全、图像识别、图像生产、分割抠图、视觉搜索、目标检测、图像分析处理、视频理解、视频生产、视频分割13个类目 ，日后便去完成！</p>]]></content>
    
    
    <summary type="html">&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h4&gt;&lt;p&gt;首先，这里选用的sdk是java（支持本地上传版本）和python&lt;/p&gt;
&lt;p&gt;阿里云的sdk最好是通过maven来导入，而且在&lt;strong&gt;使用maven的时候注意将镜像设置为阿里云&lt;/strong&gt;，否则会很慢。&lt;/p&gt;</summary>
    
    
    
    <category term="justForFun" scheme="https://jefine.github.io/categories/justForFun/"/>
    
    
    <category term="cloud" scheme="https://jefine.github.io/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>大数乘法</title>
    <link href="https://jefine.github.io/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>https://jefine.github.io/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/</id>
    <published>2020-04-30T10:07:52.000Z</published>
    <updated>2020-08-10T04:08:12.841Z</updated>
    
    <content type="html"><![CDATA[<p><em>使用java语言的int数组与StringBuffer来实现</em>。</p><p>日常中，我们使用java来计算两数乘法时，我们会在遇到一些比较大的数字计算时，便无可奈何(int不够大)，这时一般采用<strong>BigInteger</strong>的方法进行计算，但是该方法也有一定的限制，或者说，我们是可以去尝试去使用String来实现和表示大数乘法的效果。</p>  <a id="more"></a><h2 id="编程思路："><a href="#编程思路：" class="headerlink" title="编程思路："></a>编程思路：</h2><p>首先我们要确定使用字符串后我们如何去实现我们的乘法计算，不妨我们回归竖式计算，进行模拟然后得出结果。</p><p>例如：37*46的计算过程，我们也可以这样计算：如下图。</p><ol><li><p><strong>先不考虑进位的问题</strong>，将两个<strong>数字</strong>相乘的结果当作一个个位数（不去进行进位，最后再依次进位，方便计算机操作，当然，方法多样，并不局限于此）</p><p><img src="/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/multiplyExample.png" alt></p></li><li><p>我们也可以发现上述规律a位数*b位数≤（a+b）位数</p><p>所以我们如果需要得到最后的位数的话，可以通过这个规律进行计算。</p></li></ol><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先，我们采用由俭入繁的理念：从简单的开始，再到复杂：</p><ol><li><p>我们考虑的是两个正整数的大数乘法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了，直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>好的计算成功，那么如果有负数存在呢？</p><p>我们只需要加上如下的判断符号的代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br></code></pre></td></tr></table></figure></li></ol><p>完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法(有符号）</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最后：bugs："><a href="#最后：bugs：" class="headerlink" title="最后：bugs："></a>最后：bugs：</h2><p>在初步形成之后，还是有一些bug的比如乘数中含有0，那么就会报错。</p><p>所以要排除这一情况。（在判断符号前加入一个判断0即可）</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-comment">//判断0</span><br><span class="hljs-keyword">if</span>(a.equals(<span class="hljs-string">"0"</span>)||b.equals(<span class="hljs-string">"0"</span>))System.out.println(<span class="hljs-string">"0"</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;使用java语言的int数组与StringBuffer来实现&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;日常中，我们使用java来计算两数乘法时，我们会在遇到一些比较大的数字计算时，便无可奈何(int不够大)，这时一般采用&lt;strong&gt;BigInteger&lt;/strong&gt;的方法进行计算，但是该方法也有一定的限制，或者说，我们是可以去尝试去使用String来实现和表示大数乘法的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
    <category term="编程" scheme="https://jefine.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java中各种类的跳转例题分析</title>
    <link href="https://jefine.github.io/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://jefine.github.io/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2020-04-01T08:46:55.000Z</published>
    <updated>2020-04-01T10:02:04.084Z</updated>
    
    <content type="html"><![CDATA[<p>在学习java的继承的过程中遇到这样的一个分析类题目，比较有意思，在这里做出简要分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请写出以下程序运行结果：</span><br><br><span class="hljs-keyword">package</span> test;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.show(<span class="hljs-keyword">new</span> Car()&#123;<br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">"test run"</span>);           <br>         &#125;<br>      &#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Car c)</span></span>&#123;<br>      c.run();<br>      c.show();<br>&#125;&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">"car run"</span>);     <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(getClass().getName());<br>&#125;&#125;<br></code></pre></td></tr></table></figure><p> 那么，我们可以通过断点的分析：</p><ol><li><p>首先。我们从main函数进入，发现他创建了Test类的一个对象t；</p><p>我们在test类中并没有寻找到Test类的构造函数，所以应该是系统默认的构造器，不进行任何的行为；</p></li><li><p>之后，我们注意一下这一步，首先是t.show（）方法，在Test的类中有这么一个方法，不过我们看到show方法是需要传入一个car类的对象，所以他new了一个car对象，离奇的是car对象后面接着一对大括号。</p></li><li><p>注意到：这里有一个匿名类，用来一次性使用的创建car对象。这样抽象类car才能被以匿名类中的内容实例化。这样，我们就完成了对car类的实例化，得到了一个car类的对象。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401173415543.png" alt="image-20200401173415543"></p></li><li><p>接着，我们以那个新new的对象作为参数，调用了Test类中的show方法。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174104233.png" alt="image-20200401174104233"></p><p>而show方法的第一条语句是c.show();注意到我们是通过匿名类创建的对象，而我们是通过匿名类中的重新写的run（）方法，所以他又跳回了第六行，输出“test run”；</p></li></ol><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174405627.png" alt="image-20200401174405627"></p><ol><li><p>好的，接下来我们又回到了show方法中，继续调用c.show(),这时，我们回头看匿名类，它里面竟然没有show的方法。。。所以他就只能调用car类的show（）方法。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174506855.png" alt="image-20200401174506855"></p></li></ol><ol><li><p>注意到了右侧返回的getName()是”test.Test$1”，好吧，test是包名，Test是类名，可以理解！</p><p>但是$1就使得不少同学迷惑了。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174856777.png" alt="image-20200401174856777"> </p></li><li><p>好的，我们这次打开文件管理系统，找到我们编译的文件所在，发现.java编译后多出了Test$1.class的文件，这个.class是怎么来的呢？对了是匿名类！这里的Test$1这个类名是编译器给它的名字（匿名类没有名字，但是java编译器要给他起个名，才好分辨）而命名的格式就是第一个Test类下面的匿名类的话就叫$1,第二个就是$2。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401175322331.png" alt="image-20200401175322331"></p></li></ol><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401180024806.png" alt="image-20200401175322331"></p><p>这样就可以了，程序就结束了！主要涉及了匿名成员类。大家有兴趣（最好可以了解一下）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习java的继承的过程中遇到这样的一个分析类题目，比较有意思，在这里做出简要分析：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
    <category term="class" scheme="https://jefine.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>一元多次多项式的加减</title>
    <link href="https://jefine.github.io/2020/03/26/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F/"/>
    <id>https://jefine.github.io/2020/03/26/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F/</id>
    <published>2020-03-26T14:00:11.000Z</published>
    <updated>2020-08-10T04:09:17.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一元多项式的加减法"><a href="#一元多项式的加减法" class="headerlink" title="一元多项式的加减法"></a>一元多项式的加减法</h1><p>tips: 三月份写过这个题解，当时确实解决了当时问题，但是方法是错的，两个月后，又做类似的题目，只是将指数由大到小的排列便错了，那么我就不（敢）再误人子弟，便删去旧的题解，写新的题解。这一次经历了两天来研究指针的问题，可以说，过程比较令人头大，但是对指针的了解也更多了一些。功不唐捐！</p><p>在学习链表的过程中，了解到可以使用链表的方式来实现一元多项式的加减（还打算实现乘法和除法，但是技术有限，一时不一会写，哈哈，以后或许会悄悄更新吧）</p>  <a id="more"></a><h2 id="如何获取到两个一元多项式"><a href="#如何获取到两个一元多项式" class="headerlink" title="如何获取到两个一元多项式"></a>如何获取到两个一元多项式</h2><p>我们可以使用到首先明确一共有多少项，输入数据应该如下示例：<br>如果希望输入的多项式是：x+2x^2+3x^3<br>那么输入的数据应该是： 3 1 1 2 2 3 3<br>第一个输入一共多少项，之后我们可以依次输入每项的底数和次方。</p><h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><p>自然是使用链表咯！</p><h2 id="代码里面见分析！"><a href="#代码里面见分析！" class="headerlink" title="代码里面见分析！"></a>代码里面见分析！</h2><p>精华应该是在于对于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br><span class="hljs-keyword">int</span> coef;<br><span class="hljs-keyword">int</span> index;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;node;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">int</span> coef;<br><span class="hljs-keyword">int</span> index;<br>node* head1 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>node* headfirst = head1;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>head1-&gt;next = t;<br>head1 = head1-&gt;next;<br>&#125;<br>head1-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br>node* head2 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>node* headsecond = head2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>head2-&gt;next = t;<br>head2 = head2-&gt;next;<br>&#125;<br>head2-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><br><br><span class="hljs-comment">//start  </span><br>Node* tail = headfirst;<br>Node* p = headfirst-&gt;next;<br>Node* q = headsecond-&gt;next;<br>Node* t = headfirst;<span class="hljs-comment">//as the result</span><br><span class="hljs-keyword">while</span>(q&amp;&amp;p)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;index &gt; q-&gt;index)&#123;<br>tail = p;<br>p= p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;index &lt; q-&gt;index)&#123;<br>tail-&gt;next = q;<br>tail = q;<br>q = q-&gt;next; <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;coef + q-&gt;coef==<span class="hljs-number">0</span>)&#123;<br>tail-&gt;next = p-&gt;next;<br>Node* temp = p;<br>p = p-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>temp = q;<br>q= q-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//coef之和不为0，index相等时 </span><br>p-&gt;coef = p-&gt;coef + q-&gt;coef;<br>tail -&gt;next = p;<br>p = p-&gt;next;<br>Node* temp = q;<br>q = q-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>&#125;<br>&#125;<br>&#125;<br>    t = t-&gt;next;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-keyword">if</span>(t!=headfirst-&gt;next&amp;&amp;t-&gt;coef&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"+"</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;t-&gt;coef&lt;&lt;<span class="hljs-string">"x"</span>;<br><span class="hljs-keyword">if</span>(t-&gt;index!=<span class="hljs-number">1</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"^"</span>&lt;&lt;t-&gt;index;<br>t = t-&gt;next;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一元多项式的加减法&quot;&gt;&lt;a href=&quot;#一元多项式的加减法&quot; class=&quot;headerlink&quot; title=&quot;一元多项式的加减法&quot;&gt;&lt;/a&gt;一元多项式的加减法&lt;/h1&gt;&lt;p&gt;tips: 三月份写过这个题解，当时确实解决了当时问题，但是方法是错的，两个月后，又做类似的题目，只是将指数由大到小的排列便错了，那么我就不（敢）再误人子弟，便删去旧的题解，写新的题解。这一次经历了两天来研究指针的问题，可以说，过程比较令人头大，但是对指针的了解也更多了一些。功不唐捐！&lt;/p&gt;
&lt;p&gt;在学习链表的过程中，了解到可以使用链表的方式来实现一元多项式的加减（还打算实现乘法和除法，但是技术有限，一时不一会写，哈哈，以后或许会悄悄更新吧）&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构基础" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="链表" scheme="https://jefine.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>p1086花生采摘</title>
    <link href="https://jefine.github.io/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/"/>
    <id>https://jefine.github.io/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/</id>
    <published>2020-03-21T08:58:48.000Z</published>
    <updated>2020-03-21T10:34:00.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。</p><p>鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图111）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”</p><p><img src="/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/1182.png" alt></p><p>我们假定多多在每个单位时间内，可以做下列四件事情中的一件：</p><ol><li>从路边跳到最靠近路边（即第一行）的某棵花生植株；</li><li>从一棵植株跳到前后左右与之相邻的另一棵植株</li><li>采摘一棵植株下的花生：</li><li>从最靠近路边（即第一行）的某棵花生植株跳回路边</li></ol><p>现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。</p><p>例如在图2所示的花生田里，只有位于(2,5),(3,7),(4,2),(5,4)的植株下长有花生，个数分别为13,7,15,9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括三个整数，M,N和K，用空格隔开；表示花生田的大小为MN（1≤M,N≤20），多多采花生的限定时间为K（0≤K≤1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i+1行的第j个整数Pij（0≤Pij≤500）表示花生田里植株（i,j）下花生的数目，0表示该植株下没有花生。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即在限定时间内，多多最多可以采到花生的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong> </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">37</span><br></code></pre></td></tr></table></figure><p><strong>输入 #2</strong> </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出 #2</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>刚开始急匆匆地一看题目（然后就陷入了一阵思考：“如何在有限的时间内拿到最多的花生呢？”哎，每个花生的个数还不一样，也就是先后顺序什么的都要去更改哎，动态规划？<del>（可是其实我不会动态规划哈哈）</del>那么怎么办呢，哎呦，然后发现了一个问题，这是一道普及题目那么不会那么难的吧？！</p><p>又重新审题后，发现我原来看错题目了！在那段极长的唠叨中，<strong>它规定的摘取顺序是按照从大到小的顺序区去采摘，</strong>而不是向我之前所想的那样，这样一来就大大简化了自己的步骤。</p><p>之后一开始打算使用一个二维数组来储存但是发现不太对，想起来结构体于是；</p><p>有了思路，使用一个结构体来储存自己的x，y，和花生的个数；然后排序，从大到小但是要记住判断下一次是不是采摘完还能回去哈哈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hua</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> num;<br>&#125;h;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(h a,h b)</span></span>&#123;    <br>        <span class="hljs-keyword">return</span>  a.num &gt; b.num; <br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m,n,k,cnt=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>,real=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;k;<br>    h a[m*n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        a[cnt].x = i;<br>        a[cnt].y = j;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[cnt++].num; <br><span class="hljs-keyword">if</span>(a[cnt<span class="hljs-number">-1</span>].num!=<span class="hljs-number">0</span>)real++;  <br>        &#125;  <br>    &#125;<br>    sort(a,a+m*n,cmp);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    k--;<span class="hljs-comment">//跳入</span><br>    <span class="hljs-keyword">int</span> least = a[i].x*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cost = a[i].x+<span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// cout&lt;&lt;real&lt;&lt;endl;</span><br>    <span class="hljs-comment">//cout&lt;&lt;"应该是：3，1"&lt;&lt;a[0].x&lt;&lt;"  "&lt;&lt;a[0].y&lt;&lt;endl;</span><br>    <span class="hljs-keyword">while</span>(k&gt;=least&amp;&amp;(i&lt;=real))&#123;<span class="hljs-comment">//省去了讨论最后一步跳出</span><br>        k-=cost;<span class="hljs-comment">//到达a[i]点所需要的步数，并加上挖出所需要的一步</span><br>       <span class="hljs-comment">// cout&lt;&lt;"least:"&lt;&lt;least&lt;&lt;"  cost:"&lt;&lt;cost;</span><br>       <span class="hljs-comment">// cout&lt;&lt;"   k:"&lt;&lt;k&lt;&lt;endl;</span><br>        ans+=a[i].num;<br>        least = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+a[i+<span class="hljs-number">1</span>].x+<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//假设能拿到下一个,且挖掘，并保证能够返回到第一行。</span><br>        cost = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+<span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，这个故事告诉我们。。。审视好题目。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝</summary>
      
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="洛谷" scheme="https://jefine.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList链表</title>
    <link href="https://jefine.github.io/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/"/>
    <id>https://jefine.github.io/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-17T09:50:51.000Z</published>
    <updated>2020-03-21T11:04:48.029Z</updated>
    
    <content type="html"><![CDATA[<p>今天说说链表：说到链表就不得不提及数组，两者相爱相杀，但又都是极为重要的基本数据结构类型。</p><p>相对于链表，我们一般情况下更熟悉数组。</p><p>（<del>听说加上英文，会显得高端不少</del>）：</p><h2 id="先讲一个小故事（虽然讲的很烂2333）"><a href="#先讲一个小故事（虽然讲的很烂2333）" class="headerlink" title="先讲一个小故事（虽然讲的很烂2333）"></a>先讲一个小故事（虽然讲的很烂2333）</h2><p>从前，一群小朋友外出游玩，到酒店申请房间啊，他们呢，申请的是数组方式的房间（哈哈）那么他们的房间号就是相连的。他们很容易的相互串门，带队者也可以轻松的找到他们每个人的所在（带队者只用记住第一个小朋友的位置和学号就好）。但问题是，他们这样申请房间的话，有的小朋友如果申请更换房间，会比较麻烦，更有甚者，不小心生病了，需要退房，那么负责人就要重新给每个人好分配房间，大多数小朋友都需要更换自己的房间，就会很麻烦。这时候，酒店管理者想到，如果我们让学号相邻的小朋友的记住他（她）下一个学号的小朋友的房间号（就像一号记住二号的房间号，二号记住三号的房间号），那么负责人还是只用记住第一个小朋友的房间号就可以按照顺序依次找到每个小朋友。（<del>当然要是其中一个小朋友忘记后面小朋友的位置的话。。。我们就失去了一堆小朋友</del>）。酒店管理者发现这样的话，不仅可以使得他们的房间利用率得到大大的提升，并且可以方便住宿人员的调动。</p><p>好的，相信读完这个尴尬的小故事，我们大概对链表有了一个感性的认识，他是为了解决一些数组的不足而出现的。下面就是严谨的分析链表的优缺点。</p><p>作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。</p><p>初学链表，一般从单向链表开始：（本文也暂时只有单向链表）</p><h2 id="Advantages-优势"><a href="#Advantages-优势" class="headerlink" title="Advantages 优势"></a><strong>Advantages 优势</strong></h2><p><strong>1)</strong> Dynamic size（动态大小）</p><p><strong>2)</strong> Ease of insertion/deletion（方便插入和删除）</p><h2 id="Drawbacks-缺点"><a href="#Drawbacks-缺点" class="headerlink" title="Drawbacks 缺点"></a><strong>Drawbacks 缺点</strong></h2><p><strong>1)</strong> Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists efficiently with its default implementation. </p><p>不允许随机访问。 我们必须从第一个节点开始顺序访问元素。 因此，我们无法使用其默认实现对链接列表进行有效的二分查找。</p><p><strong>2)</strong> Extra memory space for a pointer is required with each element of the list.</p><p>需要额外的空间去存放链表中下一个元素的位置。</p><p><strong>3)</strong> Not cache friendly. Since array elements are<br>contiguous locations, there is locality of reference which is not there<br>in case of linked lists.</p><p>不缓存友好。 由于数组元素是连续的位置，因此存在引用位置，而在链接列表的情况下则不存在。</p><p>（就是说不能写成a[6])</p><h2 id="Representation-表达（内容）"><a href="#Representation-表达（内容）" class="headerlink" title="Representation  表达（内容）"></a><strong>Representation  表达（内容）</strong></h2><p>首先，我们将一个链表中的每个元素称为一个节点（Node),特殊的第一个被叫做头节点，最后一个被叫做尾节点。（图中，abcd是四个节点，但注意a不是头节点哈哈，Head是头节点，他指向的a节点）一般来说，头节点Head不存放内容，尾节点没有下一个元素的位置。（以简单的单链表为例）</p><p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/Linkedlist.png" alt="linkedList/Linkedlist.png"></p><p>A linked list is represented by a pointer to the first node of the<br>linked list. The first node is called the head. If the linked list is<br>empty, then the value of the head is NULL.</p><p>链接列表由指向链接列表的第一个节点的指针表示。 第一个节点称为头。 如果链表为空，则head的值为NULL。（<del>好绕口</del>）<br>Each node in a list consists of at least two parts:</p><p>每一个节点至少包括两部分：<br>1) data 数据<br>2) Pointer (Or Reference) to the next node 指向下一个结点的指针（指向/引用）<br>In C, we can represent a node using structures. Below is an example of a linked list node with integer data.</p><p>在c语言中，我们使用结构体来表示，如下面的代码:</p><pre><code>struct Node {int data;struct Node* next;};</code></pre><p>In Java or C#, LinkedList can be represented as a class and a Node as a<br>separate class. The LinkedList class contains a reference of Node class<br>type.</p><p>而在java，c#中LinkedList可以表示为一个类，而Node可以表示为单独的类。 LinkedList类包含Node类类型的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> &#123;</span> <br>Node head; <span class="hljs-comment">// head of the list </span><br><br><span class="hljs-comment">/* Linked list Node*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-keyword">int</span> data; <br>Node next; <br><br><span class="hljs-comment">// Constructor to create a new node </span><br><span class="hljs-comment">// Next is by default initialized </span><br><span class="hljs-comment">// as null </span><br>Node(<span class="hljs-keyword">int</span> d) &#123; data = d; &#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写一下链表？"><a href="#写一下链表？" class="headerlink" title="写一下链表？"></a>写一下链表？</h2><h3 id="我们从c开始尝试：-现在只写到了增）"><a href="#我们从c开始尝试：-现在只写到了增）" class="headerlink" title="我们从c开始尝试：(现在只写到了增）"></a>我们从c开始尝试：(现在只写到了增）</h3><p>好的，在此之前，我们似乎好像可能看起来学会了如何使用，但是看懂了和会写出来中间还是有一定的差距的。</p><p>链表还有一下基础的知识需要去掌握：</p><p><a href="https://www.runoob.com/cprogramming/c-function-malloc.html" target="_blank" rel="noopener">malloc</a> ：用于申请一定的内存.</p><p>那么这句(struct Node*)malloc(sizeof(struct Node))是什么鬼呢？（<del>这也太长了吧</del>）</p><p>不急，我们仔细看看，他是申请了一个内存，多大呢？（struct Node）类型的所需要的储存空间；（就像房间的类型一样，偏要双人床的那种）</p><p>那么前面的那个（struct Node*）是？哦，他是说这一块申请来的内存要强制转化成struct Node类型的，就是说专门给节点使用的。<del>（自己辛辛苦苦申请来的，才不给别人用呢）。</del></p><p>对了，这句话是会返回一个地址的，就是指向自己申请内存的位置。</p><p><strong>注意：节点呀！只有Head和普通节点。我们说的头指针，尾指针一类的，都是仅仅声明，作用就像房卡一样，是可以换的，里面存放的是链表中节点的地址。</strong></p><p>好的，下面我们要耐住性子，认真的学习咯（后文的故事如果听不太懂，放心你不是一个人，多看看不是故事的内容会更好）；（下面是一个标准化的介绍）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program to introduce </span><br><span class="hljs-comment">// a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br><br><span class="hljs-comment">//这个结构体就是我们要用到的节点了，</span><br><span class="hljs-comment">//既然c语言里的基本类型没有，我们就自己造一个。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-keyword">int</span> data; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br><br><span class="hljs-comment">// Program to create a simple linkedlist with 3 nodes </span><br><span class="hljs-comment">//编程去建立一个有三个节点的链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br><span class="hljs-comment">//声明3个节点，注意了哈，这里是声明！！！</span><br><span class="hljs-comment">//并没用得到那三个节点，就像我们拿到了三个空门牌，但是房间还没造出来呢</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br><br><span class="hljs-comment">// allocate 3 nodes in the heap</span><br><span class="hljs-comment">//从堆中申请三个节点的内存（这会儿才得到房间了，并把房间号写在了门牌上） </span><br>head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br><br><span class="hljs-comment">/* Three blocks have been allocated dynamically. <br>We have pointers to these three blocks as head, <br>second and third <br>下面是灵魂的绘图（佩服佩服）来表示我们所申请的三个节点的储存状态，<br>他们是不相连的哦<br>head        second    third <br>|          |       | <br>|           |        |<br>+---+-----+ +----+----+ +----+----+ <br>| # | # |    | # | # |    | # | # | <br>+---+-----+ +----+----+ +----+----+ <br>#代表了随机值，一个是数据，一个是指针，<br>和我们的stuct node结构相同哦，<br>但是他们现在还是随机值，因为我们没有给他们赋值。<br><br># represents any random value. <br>Data is random because we haven’t assigned <br>anything yet */</span><br><br>head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>head-&gt;next = second; <br><span class="hljs-comment">// Link first node with the second node </span><br><span class="hljs-comment">// 我们给第一个节点赋值了，并且告诉了他下一个节点的位置</span><br><br><span class="hljs-comment">/* data has been assigned to the data part of the first <br>block (block pointed by the head). And next <br>pointer of first block points to second. <br>So they both are linked. <br>//那个代码由于复制可能会造成错位，木得办法，撮合着看把哈哈。<br>head second third <br>| | | <br>| | | <br>+---+---+ +----+----+ +-----+----+ <br>| 1 | o-----&gt;| # | # | | # | # | <br>+---+---+ +----+----+ +-----+----+ <br>*/</span><br><br><span class="hljs-comment">// assign data to second node </span><br>second-&gt;data = <span class="hljs-number">2</span>; <br><br><span class="hljs-comment">// Link second node with the third node </span><br>second-&gt;next = third; <br><br><span class="hljs-comment">//同上，给第二个赋值，并且告诉他下一个在哪里</span><br><span class="hljs-comment">/* data has been assigned to the data part of the second <br>block (block pointed by second). And next <br>pointer of the second block points to the third <br>block. So all three blocks are linked. <br><br>head second third <br>| | | <br>| | | <br>+---+---+ +---+---+ +----+----+ <br>| 1 | o-----&gt;| 2 | o-----&gt; | # | # | <br>+---+---+ +---+---+ +----+----+ */</span><br><br>third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>third-&gt;next = <span class="hljs-literal">NULL</span>; <br><br><span class="hljs-comment">//给第三个（也是最后一个）赋值，并告诉他，你后面没人了。</span><br><span class="hljs-comment">/* data has been assigned to data part of third <br>block (block pointed by third). And next pointer <br>of the third block is made NULL to indicate <br>that the linked list is terminated here. <br><br>We have the linked list ready. <br><br>head <br>| <br>| <br>+---+---+ +---+---+ +----+------+ <br>| 1 | o-----&gt;| 2 | o-----&gt; | 3 | NULL | <br>+---+---+ +---+---+ +----+------+</span><br></code></pre></td></tr></table></figure><p>​        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Note that only head is sufficient to represent <br>the whole <span class="hljs-built_in">list</span>. We can traverse the complete <br><span class="hljs-built_in">list</span> by following next pointers. */<br><br><span class="hljs-comment">//接下来一定要试试效果么！</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">n</span> = <span class="hljs-title">head</span>;</span><br><span class="hljs-comment">//新建立一个指针，让他去循环着跑</span><br><span class="hljs-comment">//并且哈，它指向了第一个有数据的节点</span><br><span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <span class="hljs-comment">//输出完后，他就有指向了下一个</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>这就完了？这就完了。</p><p>下面是一个简洁的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program for traversal of a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br>  <br><span class="hljs-comment">// This function prints contents of linked list starting from </span><br><span class="hljs-comment">// the given node </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(struct Node* n)</span> <br></span>&#123; <br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <br>    &#125; <br>&#125; <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br>  <br>    <span class="hljs-comment">// allocate 3 nodes in the heap </span><br>    head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>  <br>    head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>    head-&gt;next = second; <span class="hljs-comment">// Link first node with second </span><br>  <br>    second-&gt;data = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign data to second node </span><br>    second-&gt;next = third; <br>  <br>    third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>    third-&gt;next = <span class="hljs-literal">NULL</span>; <br>  <br>    printList(head); <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>当然，当我自己上手之后，生活还是狠狠地把我按在地上摩擦。。。</p><p>不妨我们模块化的写一下一个链表吧（写了很久来理解链表的优秀）</p><p>我先分开讲解每个模块的作用和意义，之后放在一起来观看，效果<del>（可能）</del>更佳。</p><p>1 必不可少的这个结构体呀！</p><p>你看，这个stuct Node *多长呀，如果我们使用的是typedef的话我们就可以将l作为一个数据类型的名字，然后把l当作int这样的来使用就好了（我们还是可以使用struct Node的）。</p><p>其次，看第二行，这个调用就很有意思了，声明了一个l数据类型的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    l* next;<span class="hljs-comment">//等效 struct Node *next</span><br>&#125;l;<br></code></pre></td></tr></table></figure><p>2 我们要创建一个链表了。</p><p>我们在main函数里面声明了一个Head的指针，并且申请了一个内存空间，并把其地址放进了head。这个时候把他传过来。</p><p>或者说，我们要了一个房卡，并要了一个房间，这个房卡就是head，房卡对应的就是该房间。</p><p>第一步：</p><p>在creat函数里面：我们先是malloc 了一个l类型的空间，这个房间的地址赋值给了新声明的n指针上。【或者说我们向酒店索要了一间l类型的房间（房卡当然比房间要好拿到一些呀），同时把这个房间的门牌号输入到了门卡上。】</p><p>第二步：我们把指针n的内容（也就是新声明的节点的地址）赋值给head指针指向的next的位置【哈哈，有点懵吧，就是说，我们现在手里一共有两张房卡对吧，一张是head（head房卡可是能打开head房间的哦），另一张是n（n可是上面有房间号码的），然后我们打开head的房间，在里面的next区域放上n房卡的内容（就是刚刚申请的房间号/地址）（用这个例子<del>可能</del>好理解哈，指针总是很奇妙的）</p><p>第三步：将n赋值,并指向空【然后我们利用n房卡打开刚刚申请的房间哈，然后在内容区域放上内容，在下一个的区域放上空，说明后面没有房间了】</p><p>这就好了。想象一下我们拿着head房卡就可以了，先是到head的next区域找到下一个房间的位置，然后进去，就能看见第一个房间的内容区域还能看到下一个房间在哪里了，当然在此处我们没有下一个房间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<span class="hljs-comment">//这里做一下判断，如果内存不足，那么报错</span><br>head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>3那我们一定要再来一个房间呀</p><p>第一步：传入一个头节点，和一个值【拿上head门卡和要往新房间里放的东西】</p><p>第二步：声明一个新的节点p，并使其和head指向相同。【再要一张门卡，复制一下head门卡的内容】这样做可以保证head不被破环。</p><p>第三步：开始找最后一个房间了，如果指向的房间中的next区域还有值，就说明后面还有房间，我们就把这个门卡p指向本来房间里的下一个房间位置，就是我们将p门卡本来打开时的是这个房间，我们使他打开的是下一个房间，（当然，他无法再打开这个房间了）然后继续搜索。直到发现只是最后一个房间。</p><p>第四步：我们新索要一个房间，原来最后一个空房间的next区域要存放上这个房间的位置了。然后我们把我们的东西也就是一个值放在新的房间，这个新房间就成了最后一个房间了，我们就需要把他的next变为NUll空，记住哦，这些步骤一步也不能缺少，否则就会酿成大错。。。（<del>无限卡壳</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>p-&gt;next =t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>4赶紧巡查一遍房间吧：</p><p>我们只用拿着head门卡就好，每次巡查的时候记得再要一个门卡自己的门卡保存着第一个房间的位置，可不能乱改。然后搜查完成一间房间之后，房卡n就成了下一个房间的房卡，继续搜查。哈哈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;l;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<br>head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    l *Head;<br>    Head = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <br>    creat(Head);<br>    add(Head,<span class="hljs-number">15</span>);<br>    disp(Head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只是写出一个链表就少了很多趣味，增改删查才是硬道理！</strong></p><p>当然了，在开始阶段，我们还是只以单链表为例：</p><h2 id="链表的增："><a href="#链表的增：" class="headerlink" title="链表的增："></a>链表的增：</h2><p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/_2020031917124912SS.png" alt="linkedList/_2020031917124912SS.png"></p><p><strong>一、 在链表的末尾增加：</strong>（再重复的系统的讲一下哈）</p><p>这个方法我们在上面已经认识到了，具体的思路就是我们通过头节点找到最后一个节点，然后在她后面添加一个节点，链接上去就可以了。（我们手持一个head房卡，沿着房间不断地走下去，找到最后的房间，在新开一间房间，然后我们在原来的最后一个房间的next的空间里放上新开房间的位置就好了）</p><p>这里假设我们已经有了一个链表了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<span class="hljs-comment">//设置临时的指针，用来指向不同的节点，实现在不影响head的情况下遍历等操作</span><br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、在链表的头部增加：</strong></p><p>这个的做法似乎比上一个还要简单呢，毕竟我们不用去一一寻找到最后一个了。</p><p>既然我们需要添加一个值，那么新建一个节点（房间）是必不可少的了。然后将值放入，让其指向本来的第一个节点，在让head指向它就好。（不怕麻烦的话，也可以重新添加一个指针变量，作为中间值，来进行操作）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    t-&gt;next = Head-&gt;next;<br>    Head -&gt;next = t;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三、在链表的中间插入：</strong></p><p>这个可以说是前两者的综合版本了。我们要先找到这个节点，然后对他进行插入。</p><p>这里就以给定一个值，作为目标值，在其后面添加一个节点吧。查找的方法是先检查一下它后面是否还有节点，如果有就判断他的值是否符合，如果不符合就使指针指向下一个节点。这样出来的结果只会有两种，一种是没有找到，也有可能是这个值就在最后一个节点里面。</p><p>这里做了两个版本的给定值寻找插入方法，一种是在其之前，另一种是在其后。（两者之间只需要一点点的代码改动就可以了，在不同的地方已经用//注释）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertBefore</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* pre  = Head;<span class="hljs-comment">//*</span><br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<span class="hljs-comment">//*</span><br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    pre-&gt;next = t;<span class="hljs-comment">//*</span><br>    t-&gt;next = p; <span class="hljs-comment">//*</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>     t-&gt;next = p-&gt;next;<span class="hljs-comment">//*</span><br>     p-&gt;next = t;<span class="hljs-comment">//*</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的删"><a href="#对链表的删" class="headerlink" title="对链表的删"></a>对链表的删</h2><p>？？？如果前面的掌握了的话，那么对链表的某个节点进行删除自然不是问题。就直接放代码了（思路和上面的<strong>insertBefore</strong>相同哦）（<del>代码其实也是参考上面的</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target)</span></span>&#123;<span class="hljs-comment">//这里传入头节点和目标值就可以了</span><br>    l* pre  = Head;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>pre-&gt;next = p-&gt;next;<span class="hljs-comment">//是的，将insertAfter代码的最后几行更改为这一行就好了。</span><br><span class="hljs-comment">//（相当于将这个节点跳过去了）</span><br>  <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//既然删除了这个节点，那么就把他释放掉，节约内存。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的改："><a href="#对链表的改：" class="headerlink" title="对链表的改："></a>对链表的改：</h2><p>？？？如果前面的掌握了的话，那么对链表的某个值进行更改自然不是问题。就直接放代码了（思路和上面的<strong>insertAfter</strong>相同哦）（<del>代码其实也是参考上面的</del>）<del>（人类的本质是复读机）</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    p-&gt;val = val;<span class="hljs-comment">//其实就是把insertAfter()最后的几行代码改为这个（2333）</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的查："><a href="#对链表的查：" class="headerlink" title="对链表的查："></a>对链表的查：</h2><p>我们不是一直在查找么？？？（<del>避免复读，</del>就不再赘述）</p><p>看到这里，首先是一份敬佩，敬佩您能够静下心来一步一步的去尝试，去探索，去思考。确实文章篇幅很长，需要一定的耐心去思考，并且链表理解起来确实不是很困难，但是如果是刚开始，去上手操作，自然还是漏洞百出，bug重重。但是只要我们多尝试，多敲代码，缕清关系，明确指针自身的所在。那么，我们的各个方面都会有一定的成长。</p><p>谢谢阅读，本文中仍有许多的不足之处，还望交流指正。</p><p>对于后期，大家还可以去了解其他的链表形式，来加强对链表的使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天说说链表：说到链表就不得不提及数组，两者相爱相杀，但又都是极为重要的基本数据结构类型。&lt;/p&gt;
&lt;p&gt;相对于链表，我们一般情况下更熟悉数组。&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;听说加上英文，会显得高端不少&lt;/del&gt;）：&lt;/p&gt;
&lt;h2 id=&quot;先讲一个小故事（虽然讲的很烂23</summary>
      
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="https://jefine.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
