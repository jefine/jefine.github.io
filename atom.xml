<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jefine</title>
  
  <subtitle>小小的梦呓</subtitle>
  <link href="https://jefine.github.io/atom.xml" rel="self"/>
  
  <link href="https://jefine.github.io/"/>
  <updated>2023-05-03T10:53:34.949Z</updated>
  <id>https://jefine.github.io/</id>
  
  <author>
    <name>jefine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux_shell_tricks</title>
    <link href="https://jefine.github.io/2023/05/03/Linux_shell_tricks/"/>
    <id>https://jefine.github.io/2023/05/03/Linux_shell_tricks/</id>
    <published>2023-05-03T13:02:38.000Z</published>
    <updated>2023-05-03T10:53:34.949Z</updated>
    
    <content type="html"><![CDATA[<p>Hi, Long time no see.<br>In the process of developing programs using Linux, I have encountered some shell problems, and below I will share some of the more common and more useful tips and tools. And keep updating them as I learn more.<br>  <a id="more"></a></p><h2 id="Why-some-shell-commands-follows-with-cat-dev-null"><a href="#Why-some-shell-commands-follows-with-cat-dev-null" class="headerlink" title="Why some shell commands follows with cat /dev/null"></a>Why some shell commands follows with cat /dev/null</h2><h3 id="Using"><a href="#Using" class="headerlink" title="Using :"></a>Using :</h3><p>Discard the normal output message.</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>Such as<br><pre><code class="hljs shell">ls -l &gt;/dev/nullcat --INCORRECT_OPTION &gt; /dev/null 2&gt;/dev/nullls -l</code></pre><br><code>&amp;&gt;/dev/null</code><br>This is just a short use for <code>&gt;/dev/null 2&gt;&amp;1</code>. It redirects file descriptor 2 (STDERR) and descriptor 1 (STDOUT) to <code>/dev/null</code>.<br>Using the command <code>stat</code>,we can see<br><pre><code class="hljs shell">~ # stat /dev/null  File: /dev/null  Size: 0               Blocks: 0          IO Block: 4096   character special fileDevice: 6h/6d   Inode: 83          Links: 1     Device type: 1,3Access: (0660/crw-rw----)  Uid: (    0/    root)   Gid: (    0/    root)Access: 1970-01-01 08:00:00.000000000Modify: 1970-01-01 08:00:00.000000000Change: 2023-04-27 02:04:41.000000000</code></pre><br>It’s size is 0 and access is 0660,means all program could read and write(butu read will return EOF)<br><img src="https://journaldev.nyc3.digitaloceanspaces.com/2020/02/File_tables.png" alt="file table"></p><p>But the dev/null is not an executable file,which means it cannot be redirect by <code>|</code> operator to redirect.The only way is use file directions <code>&gt; , &gt;&gt;, &lt;, &lt;&lt;</code> </p><p>we can discard the stderr message in two ways:<br><pre><code class="hljs shell">cat --INCORRECT_OPTION &gt; /dev/null 2&gt;/dev/nullcat --INCORRECT_OPTION &gt; dev/null 2&gt;&amp;1</code></pre><br>The second <code>2&gt;&amp;1</code> : &amp;1 tell the shell 1 is a file descriptor and not a file name.</p><h2 id="tcpdump-or-wireshark"><a href="#tcpdump-or-wireshark" class="headerlink" title="tcpdump or wireshark"></a>tcpdump or wireshark</h2><p><img src="/2023/05/03/Linux_shell_tricks/Wireshark.md" alt="Wireshark"><br>Like the wireshark in shell, a useful tool to trace the web traffic data.<br><code>tcpdump -c 5 -X icmp</code> means count 5 packets and diaplay the packet by dump(hex and asicc) and only filter the icmp(mostly used by ping).<br>Here we using 192.168.9.121 to ping the 192.168.9.141,the first 5 packets is below.<br><pre><code class="hljs shell">~ # tcpdump -c 5 -X icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes11:46:32.913679 IP 192.168.9.121 &gt; 192.168.9.141: ICMP echo request, id 1, seq 212, length 40        0x0000:  4500 003c 074a 0000 4001 df20 c0a8 0979  E..&lt;.J..@......y        0x0010:  c0a8 098d 0800 4c87 0001 00d4 6162 6364  ......L.....abcd        0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst        0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi11:46:32.914101 IP 192.168.9.141 &gt; 192.168.9.121: ICMP echo reply, id 1, seq 212, length 40        0x0000:  4500 003c 220e 0000 4001 c45c c0a8 098d  E..&lt;"...@..\....        0x0010:  c0a8 0979 0000 5487 0001 00d4 6162 6364  ...y..T.....abcd        0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst        0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi11:46:33.925833 IP 192.168.9.121 &gt; 192.168.9.141: ICMP echo request, id 1, seq 213, length 40        0x0000:  4500 003c 0752 0000 4001 df18 c0a8 0979  E..&lt;.R..@......y        0x0010:  c0a8 098d 0800 4c86 0001 00d5 6162 6364  ......L.....abcd        0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst        0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi11:46:33.926234 IP 192.168.9.141 &gt; 192.168.9.121: ICMP echo reply, id 1, seq 213, length 40        0x0000:  4500 003c 2252 0000 4001 c418 c0a8 098d  E..&lt;"R..@.......        0x0010:  c0a8 0979 0000 5486 0001 00d5 6162 6364  ...y..T.....abcd        0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst        0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi11:46:34.932416 IP 192.168.9.121 &gt; 192.168.9.141: ICMP echo request, id 1, seq 214, length 40        0x0000:  4500 003c 0754 0000 4001 df16 c0a8 0979  E..&lt;.T..@......y        0x0010:  c0a8 098d 0800 4c85 0001 00d6 6162 6364  ......L.....abcd        0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst        0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi5 packets captured6 packets received by filter0 packets dropped by kernel</code></pre></p><pre><code class="hljs shell">~ # tcpdump -tttt -c 2 -Xtcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes2023-04-27 11:51:29.797574 IP 192.168.9.141.23 &gt; 192.168.9.121.51829: Flags [P.], seq 2877355743:2877355819, ack 2896325498, win 457, length 76        0x0000:  4500 0074 e8a5 4000 4006 bd87 c0a8 098d  E..t..@.@.......        0x0010:  c0a8 0979 0017 ca75 ab80 f6df aca2 6b7a  ...y...u......kz        0x0020:  5018 01c9 94bd 0000 7463 7064 756d 703a  P.......tcpdump:        0x0030:  2076 6572 626f 7365 206f 7574 7075 7420  .verbose.output.        0x0040:  7375 7070 7265 7373 6564 2c20 7573 6520  suppressed,.use.        0x0050:  2d76 206f 7220 2d76 7620 666f 7220 6675  -v.or.-vv.for.fu        0x0060:  6c6c 2070 726f 746f 636f 6c20 6465 636f  ll.protocol.deco        0x0070:  6465 0d0a                                de..2023-04-27 11:51:29.804136 ARP, Request who-has 192.168.101.190 tell 192.168.101.184, length 46        0x0000:  0001 0800 0604 0001 1c1b 0d3d 59e5 c0a8  ...........=Y...        0x0010:  65b8 0000 0000 0000 c0a8 65be 0000 0000  e.........e.....        0x0020:  0000 0000 0000 0000 0000 0000 0000       ..............2 packets captured3 packets received by filter0 packets dropped by kernel</code></pre><p>Yes, because we using the telnet to connet the linux, it’s using the web,so we will capcure our message in the packets.</p><p>Here are some additional ways to tweak how you call <code>tcpdump</code>.</p><ul><li><strong><code>-X</code></strong> : Show the packet’s _contents_ in both <a href="https://en.wikipedia.org/wiki/Hexidecimal" target="_blank" rel="noopener">hex</a> and <a href="https://en.wikipedia.org/wiki/Ascii" target="_blank" rel="noopener">ASCII</a>.</li><li><strong><code>-XX</code></strong> : Same as <strong><code>-X</code></strong>, but also shows the ethernet header.</li><li><strong><code>-D</code></strong> : Show the list of available interfaces</li><li><strong><code>-l</code></strong> : Line-readable output (for viewing as you save, or sending to other commands)</li><li><strong><code>-q</code></strong> : Be less verbose (more quiet) with your output.</li><li><strong><code>-t</code></strong> : Give human-readable timestamp output.</li><li><strong><code>-tttt</code></strong> : Give maximally human-readable timestamp output.</li><li><strong><code>-i eth0</code></strong> : Listen on the eth0 interface.</li><li><strong><code>-vv</code></strong> : Verbose output (more v’s gives more output).</li><li><strong><code>-c</code></strong> : Only get _x_ number of packets and then stop.</li><li><strong><code>-s</code></strong> : Define the _snaplength_ (size) of the capture in bytes. Use <code>-s0</code> to get everything, unless you are intentionally capturing less.</li><li><strong><code>-S</code></strong> : Print absolute sequence numbers.</li><li><strong><code>-e</code></strong> : Get the ethernet header as well.</li><li><strong><code>-q</code></strong> : Show less protocol information.</li><li><strong><code>-E</code></strong> : Decrypt IPSEC traffic by providing an encryption key.</li></ul><h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><p>The operator is the same with the wireshark.</p><ol><li><strong>AND</strong><br>_<code>and</code>_ or <code>&amp;&amp;</code></li><li><strong>OR</strong><br>_<code>or</code>_ or <code>||</code></li><li><strong>EXCEPT</strong>  (not)<br><code>not</code>  or <code>!</code></li></ol><h2 id="time-record"><a href="#time-record" class="headerlink" title="time record"></a>time record</h2><p>Using time function will be useful to measure the real time of the program.<br><pre><code class="hljs shell">~$ time curl https://github.com -k &gt; /dev/null<span class="hljs-meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span>                                 Dload  Upload   Total   Spent    Left  Speed100  221k    0  221k    0     0   187k      0 --:--:--  0:00:01 --:--:--  187kreal    0m1.352suser    0m0.170ssys     0m0.161s</code></pre><br>curl well get the webpage to stdout, but here we just want to get the running time,so we <code>&gt; /device/null</code> to discard them.<br>Sure, we still have mang ways to get the time,but this is the linux default.</p><h2 id="Profilers"><a href="#Profilers" class="headerlink" title="Profilers"></a>Profilers</h2><p>FlameGraph is a intereseting tool,but the function’s name is too long or meaningless,hard to analysize,maybe the later,i will get a new think about the profiler.<br><a href="https://zhuanlan.zhihu.com/p/362575905" target="_blank" rel="noopener">profiling 与性能优化总结 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi, Long time no see.&lt;br&gt;In the process of developing programs using Linux, I have encountered some shell problems, and below I will share some of the more common and more useful tips and tools. And keep updating them as I learn more.&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="Linux" scheme="https://jefine.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯单片机手册</title>
    <link href="https://jefine.github.io/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/"/>
    <id>https://jefine.github.io/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/</id>
    <published>2022-06-16T08:20:14.000Z</published>
    <updated>2023-01-09T12:53:51.616Z</updated>
    
    <content type="html"><![CDATA[<p>主要是 记录下来关于蓝桥杯比赛板中的一些比较模块化和认为可在今后借鉴的内容。包括了自己的一丢丢理解和包括了广大互联网的智慧结晶。<br>2022 年<a href="赛点资源数据包_SCM_2022.zip">第十三届单片机类赛点数据包</a>，以供下载。相关介绍可以浏览 <a href="https://baiblog.top/lq2/" target="_blank" rel="noopener">链接</a> 。<br>  <a id="more"></a></p><p>首先是对开发板的一些介绍：</p><h1 id="简介：实现多功能-IO-拓展的秘密——38-译码器-锁存器"><a href="#简介：实现多功能-IO-拓展的秘密——38-译码器-锁存器" class="headerlink" title="简介：实现多功能 IO 拓展的秘密——38 译码器 + 锁存器"></a>简介：实现多功能 IO 拓展的秘密——38 译码器 + 锁存器</h1><p>首先我们可以通过下图看到 采用开发板可以实现的功能是不少的。<br><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220608215736326.png" alt><br>而开发板的模块基本上都是焊接在板子上的，51 引脚 io 资源并不像 STM32 之类的资源丰富，想要实现这些就要用到一些比较“有意思”的手段。<br><strong>38 译码器 + 锁存器</strong><br>通过不同的锁存器来将 P0 的值进行保存，这样实现了 P0 端口的复用，但因为需要不断的切换，也增添了一定的难度，需要大家去适应这样的编程方式。</p><h2 id="38-译码器选择功能"><a href="#38-译码器选择功能" class="headerlink" title="38 译码器选择功能"></a>38 译码器选择功能</h2><p>输入：<br>38 译码器，通过 P2.5，P2.6，P2.7 三个引脚输入进行译码，理论上可以控制八种 功能<br>译码器打开了不同的功能，来改变不同寄存器里的值。<br>而开发板采用四组寄存器，可以保留四个不同的 P0 的状态，来供给不同的硬件模块，实现其功能。</p><p>输出：<br>对于三八译码器,我们主要使用的是 Y4，Y5，Y6，Y7 这四个输出引脚。<br>以下是帮助我们记忆的方式。<br>Y4 -&gt; LED : 4-&gt;100 -&gt; 1000 0000 -&gt; 0x80<br>Y5 -&gt; BEEP : 5-&gt;101 -&gt; 1010 0000 -&gt; 0xa0<br>Y6 -&gt; 数码管位选 : 6-&gt;102 -&gt; 1100 0000 -&gt; 0xc0<br>Y7 -&gt; 数码管端选 : 7-&gt;103 -&gt; 1110 0000 -&gt; 0xe0</p><p>P2 = 0xc0;//开数码管位 然后 放进去一个选管位的值，他就会保存到一个寄存器里面<br>然后在打开一个寄存器的开关（与此同时，其他的就被关闭了）<br>P2 = 0xe0;//开数码管段选锁存器<br>这样就分别存进去了位和段，他俩的值 并不是由 P0 直接给的，而是由 其各自的寄存器 进行赋值的</p><h1 id="各个模块的学习"><a href="#各个模块的学习" class="headerlink" title="各个模块的学习"></a>各个模块的学习</h1><h2 id="Hello，world-点灯"><a href="#Hello，world-点灯" class="headerlink" title="Hello，world -点灯"></a>Hello，world -点灯</h2><p>快速点亮开发板，是一项可以快速验证环境的事情。<br>对于如何安装环境和配置开发板，这里因为设计的太多，就不多介绍了详细的可以采用 <a href="https://baiblog.top/lq2/" target="_blank" rel="noopener">链接中的介绍</a> 去进行操作。</p><p>51 的点灯只需要寥寥几行就可以实现，在开发板上，我们也可以快速实现：<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    P0 = <span class="hljs-number">0xfd</span>; <span class="hljs-comment">//点亮了L1，若全亮为0x00,全灭为0xff。</span>    P2 = <span class="hljs-number">0x80</span>; <span class="hljs-comment">//开LED锁存器</span>    P2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//关锁存器</span>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;            &#125;&#125;</code></pre><br>对于点灯的理解：<br>低电平触发，则将8个LED依次排列，从左到右：1111 1111 恰好构成一个十六进制的数字，该值赋给 P0，来表示 LED 的亮灭。</p><p>先给 P0 赋值，这样写可以使得 led 等其他设备，在被开启锁存器之后，不会因为 P0 的值，而发生突然的变化，这种短暂波动可以被消除，对于数码管等模块，还是有一定作用的，所以建议保持这样的习惯：先赋值，再开锁存器，然后立刻关上寄存器。对于是否提前清零 P27 - P25 个人觉得用途不大~</p><p>在日后，Led 模块作为一个非常常用的模块，我们如果每次都需要写这样的内容，不仅使得我们的代码比较凌乱，不便于我们查找错误，对于我们的逻辑分析也造成了困扰，同时，这样的写法，也会让我们在遇到多 LED 进行亮灭变化时，或者说有中断控制的情况下，不易编写代码控制，所以采用宏定义的方式，会利于我们的代码编写。<br><pre><code class="hljs cpp"><span class="hljs-comment">//以下两种宏定义都会使得没有选中的 LED 熄灭</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> led_set(x) &#123;EA =0;P0 = ~(0x01&lt;&lt;x-1);P2 = 0x80;P2 =0;EA =1;&#125; <span class="hljs-comment">//点亮某栈灯</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_SET(x) &#123;EA = 0;P0 = ~(0x01&lt;&lt;(x-1));P2 = (P2 &amp; 0x1f)|0x80;P2 = P2 &amp; 0x1f;EA = 1;&#125; <span class="hljs-comment">//更加讲究的写法</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> led_set_all(x) &#123;EA =0;P0 = x;P2 = 0x80;P2 =0;EA =1;&#125; <span class="hljs-comment">//根据输入的十六进制数，进行点亮灯</span></span></code></pre><br>当然，我们可以对于宏定义进行修改，使其在在不同的工程和情况下，更加适合我们的代码编写。<br>第一个宏定义可能不是很好记，可以在比赛时尝试一下，在开发板上运行成功了，再进行宏定义，点灯测试也很快的~</p><h2 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h2><p>数码管基本上和LED是同时使用的，而且相对于数码管其能容纳更多的信息量，进而也经常是一个状态展示模块，重要程度不言而喻。</p><p>数码管也是有一定技巧的，比如官方虽然给了共阳数码管段码表，但是其给的是竖向的，而且只有数字，没有字母，资源不够丰富。但好在还有朴实无华的 STC-ISP 工具，在其范例程序中，我们可以轻易找到共阴级数码管的段码表（甚至还能顺走一个没有问题的位码），对于段码只需要求反就可以了。<br><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220616212149304.png" alt><br>这里给出一个完整的，可运行的代码。会在屏幕上显示1 - 8 ，刷新率是1ms一个符号，即8ms一组，接近 125Hz 的超级刷新率~<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"intrins.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay1ms</span><span class="hljs-params">()</span></span>;u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;P0 = T_COM[i];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[i+<span class="hljs-number">1</span>];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;Delay1ms();<span class="hljs-keyword">if</span>(i++==<span class="hljs-number">7</span>)i=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i, j;i = <span class="hljs-number">12</span>;j = <span class="hljs-number">169</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;</code></pre></p><p>但是，在单片机中，尤其是裸机开发，一般都是单线程运行，我们如果采用的软件延时，在延迟的过程中，单片机大量时间消耗在延迟上，造成了资源浪费，同时影响了其他的模组运行，故我们采用下一节的定时器来定时中断，进行刷新。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器的配置，如果要从理论上认真了解和学习，需要对寄存器进行配置，略微有些烦琐，但如果不求甚解，那么STC-ISP依旧是不二之选。通常我会选择 1ms 进行中断，这个时间对于数码管刚好，而且可以用计数。<br>这里以定时器0作为例子，通常我也会使用它作为自己的第一个定时器，用以显示数码管。<br><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220616215412228.png" alt></p><p>但需要注意<br>上图初始化并不完整，或者说需要我们<strong>手动打开定时器</strong>，即添加 <code>ET0 = 1;EA = 1;</code> 来打开定时器0中断和全局中断开关。通常添加到 Timer0Init() 函数的最后。<br>另，我们还需要写一个中断执行程序，来执行中断达到后的任务（也就是刷新数码管）；但是数码管的内容通常也是变化的，很少情况是单一的 1234567，故我常用一个字符数组作为数码管的内容数组，每次刷新的时候，从该数组里进行刷新。因为没有对应的表，我们在smg_buf 里保存所需要显示的字符的序号即可。<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"intrins.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u8 smgi = <span class="hljs-number">0</span>;u8 smg_buf [<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_SET(x) &#123;EA = 0;P0 = ~(0x01&lt;&lt;(x-1));P2 = (P2 &amp; 0x1f)|0x80;P2 = P2 &amp; 0x1f;EA = 1;&#125;</span>u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i, j;i = <span class="hljs-number">12</span>;j = <span class="hljs-number">169</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><span class="hljs-comment">//1毫秒@12.000MHz</span></span>&#123;AUXR |= <span class="hljs-number">0x80</span>;<span class="hljs-comment">//定时器时钟1T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x20</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xD1</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Handle</span><span class="hljs-params">()</span> interrupt 1</span>&#123;P0 = T_COM[smgi];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[smg_buf[smgi]];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(smgi++==<span class="hljs-number">7</span>)smgi=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;Timer0Init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;&#125;&#125;</code></pre></p><h2 id="蜂鸣器与继电器"><a href="#蜂鸣器与继电器" class="headerlink" title="蜂鸣器与继电器"></a>蜂鸣器与继电器</h2><p>两个比较嘈杂的小玩意，所以在最新的第三代板子上特地给他们添加了开关，避免他们在烧录程序的时候滴滴滴滴，卡卡喳喳。我们也要注意，如果需要打开，就需要手动切换跳帽。<br><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220617085727539.png" alt><br>从原理图中可以清晰看出他们的关系。有时候题目会要求刚上电时候，蜂鸣器不会乱叫，我们最好在最开始初始化一下他俩。<br>这里给一个简略的代码，可以方便去第一次看，稍候会给出更加合理的代码：<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Beep_Relay_Init</span><span class="hljs-params">()</span></span>&#123;P0 = <span class="hljs-number">0</span>;P2 = <span class="hljs-number">0xa0</span>;P2 = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i, j;i = <span class="hljs-number">12</span>;j = <span class="hljs-number">169</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;Beep_Relay_Init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;Delay1ms();i++;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//继电器</span>P0 = <span class="hljs-number">0x10</span>;P2 = <span class="hljs-number">0xa0</span>;P2 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">500</span>)&#123;P0 = <span class="hljs-number">0</span>;P2 = <span class="hljs-number">0xa0</span>;P2 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1000</span>)&#123;<span class="hljs-comment">//蜂鸣器</span>P0 = <span class="hljs-number">0x40</span>;P2 = <span class="hljs-number">0xa0</span>;P2 = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1500</span>)&#123;P0 = <span class="hljs-number">0</span>;P2 = <span class="hljs-number">0x10</span>;P2 = <span class="hljs-number">0</span>;i=<span class="hljs-number">0</span>;&#125;&#125;&#125;</code></pre></p><p>而我们在使用的时候，常常我会将它和LED的处理方式类似，采用宏定义来简洁代码。<br>而且我们并不需要管其他的元器件，如果采用P0口直接对器操作那么就需要考虑其他元器件的功能，所以采用单个引脚操作最好不过了~同时采用两个状态量作为查看两者是否开启。<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u8 buzzer_state=<span class="hljs-number">0</span>;u8 relay_state=<span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUZZER_ON &#123;EA = 0;P06 = 1;P2 = 0xa0;P2 = 0;buzzer_state=1;EA = 1;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUZZER_OFF &#123;EA = 0;P06= 0;P2 = 0xa0;P2 = 0;buzzer_state=0;EA = 1;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RELAY_ON &#123;EA = 0;P04=1;P2 = 0xa0;P2 = 0;relay_state=1;EA = 1;&#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RELAY_OFF &#123;EA = 0;P04=0;P2 = 0xa0;P2 = 0;relay_state=0;EA = 1;&#125;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i, j;i = <span class="hljs-number">12</span>;j = <span class="hljs-number">169</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;BUZZER_OFF;RELAY_OFF;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;Delay1ms();i++;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1000</span>)&#123;<span class="hljs-keyword">if</span>(buzzer_state == <span class="hljs-number">0</span>)BUZZER_ON<span class="hljs-keyword">else</span> BUZZER_OFF;<span class="hljs-keyword">if</span>(relay_state == <span class="hljs-number">0</span>)RELAY_ON<span class="hljs-keyword">else</span> RELAY_OFFi=<span class="hljs-number">0</span>;&#125;&#125;&#125;</code></pre></p><h2 id="按键-矩阵键盘"><a href="#按键-矩阵键盘" class="headerlink" title="按键/矩阵键盘"></a>按键/矩阵键盘</h2><p>按键没什么好说的，一般直接写矩阵键盘，考察的一般也是矩阵键盘，因为矩阵键盘包括了按键~<br>这个没什么好说的，得背，理解也比较麻烦，可以参考<a href="https://baiblog.top/lq6" target="_blank" rel="noopener">链接</a>。<br>我们将读取键盘的时间为10ms一次，读取按键之后进行处理，改变一些状态量，然后再在Main函数里进行处理。<br>实际应用中， 我们也将这个read_key()放在另一个misc.c文件中，使得 main.c 相对简洁。<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u8 light_i=<span class="hljs-number">1</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_SET(x) &#123;EA = 0;P0 = ~(0x01&lt;&lt;(x-1));P2 = (P2 &amp; 0x1f)|0x80;P2 = P2 &amp; 0x1f;EA = 1;&#125;</span><span class="hljs-comment">//key_old 的初始化状态是根据具体的业务逻辑进行的</span><span class="hljs-comment">//初始化为我们想要的初始状态所采用的按键。</span>u8 key_old=<span class="hljs-number">1</span>,key_down,key_up;<span class="hljs-function">u8 <span class="hljs-title">read_key</span><span class="hljs-params">()</span></span>&#123;u16 t;u8 key;<span class="hljs-comment">/*这里为什么第一次将4个引脚置高，而之后置改变两个呢？因为第一次时候需要把其他引脚置高，来确保P44的准确性，算作初始化。而之后因为我们把P44拉低了，所以还需要置高，防止他影响其他的判断，而对于P34，P35我们并没有拉低他们，所以不需要改变。每次只需要把自己拉低的引脚重新置高就可了*/</span>P44 =<span class="hljs-number">0</span> ;P42 = <span class="hljs-number">1</span>;P35 = <span class="hljs-number">1</span>;P34 =<span class="hljs-number">1</span>;t = P3;P44 = <span class="hljs-number">1</span>;P42 = <span class="hljs-number">0</span>;t = t&lt;&lt;<span class="hljs-number">4</span> | (P3 &amp; <span class="hljs-number">0x0f</span>);P42 = <span class="hljs-number">1</span>;P35 = <span class="hljs-number">0</span>;t = t&lt;&lt;<span class="hljs-number">4</span> | (P3 &amp; <span class="hljs-number">0x0f</span>);P35 = <span class="hljs-number">1</span>; P34 = <span class="hljs-number">0</span>;t = t&lt;&lt;<span class="hljs-number">4</span> | (P3 &amp; <span class="hljs-number">0x0f</span>);<span class="hljs-keyword">switch</span> (~t)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0x8000</span>:key = <span class="hljs-number">4</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x4000</span>:key = <span class="hljs-number">5</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x2000</span>:key = <span class="hljs-number">6</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x1000</span>:key = <span class="hljs-number">7</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0800</span>:key = <span class="hljs-number">8</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0400</span>:key = <span class="hljs-number">9</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0200</span>:key = <span class="hljs-number">10</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0100</span>:key = <span class="hljs-number">11</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0080</span>:key = <span class="hljs-number">12</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0040</span>:key = <span class="hljs-number">13</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0020</span>:key = <span class="hljs-number">14</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0010</span>:key = <span class="hljs-number">15</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0008</span>:key = <span class="hljs-number">16</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0004</span>:key = <span class="hljs-number">17</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0002</span>:key = <span class="hljs-number">18</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">0x0001</span>:key = <span class="hljs-number">19</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:key = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> key;&#125;<span class="hljs-comment">//在里面尽量只改变状态，动作在Main函数或其他函数进行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">key_proc</span><span class="hljs-params">()</span></span>&#123;u8 key = read_key();<span class="hljs-comment">//Don't try to find out why,just feel and remember them :）</span>key_down = key &amp; (key ^ key_old);key_up = ~key &amp; (key ^ key_old);key_old = key;<span class="hljs-keyword">if</span>(key_down == <span class="hljs-number">12</span>) &#123;light_i--;<span class="hljs-keyword">if</span>(light_i&lt;<span class="hljs-number">1</span>)light_i=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(key_down == <span class="hljs-number">16</span>)&#123;light_i++;<span class="hljs-keyword">if</span>(light_i&gt;<span class="hljs-number">8</span>)light_i=<span class="hljs-number">8</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay10ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i, j;i = <span class="hljs-number">117</span>;j = <span class="hljs-number">184</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;key_proc();Delay10ms();LED_SET(light_i);&#125;&#125;</code></pre></p><h2 id="DS18B20温度"><a href="#DS18B20温度" class="headerlink" title="DS18B20温度"></a>DS18B20温度</h2><p>基本组件，也就是最基础的东西已经熟悉了，下面就是外部拓展的组件：<br>对于 DS18b20 我们需要添加 <code>onewire.h</code>  , <code>onewire.c</code>  文件到相关的文件夹中去。<br>同时，我们还需要修改 <code>onewire.c</code> 中的Delay_OneWire函数<br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay_OneWire</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> t)</span>  </span>&#123;t*=<span class="hljs-number">12</span>;<span class="hljs-keyword">while</span>(t--);&#125;</code></pre><br>其中吧 <code>t * 12</code>  因为我们采用的是12T的单片机，添加即可。<br>后续主要的就是修改<code>onewire.h</code>头文件，添加函数的方法名就行，但需要完整的添加，不再赘述。<br>对于如何读取 温度值可以查询相关的芯片手册，然后阅读 <code>u16 read_temperature()</code> 部分即可。<br>对于浮点数，不便处理，故转出时采用u16 转出，需要保留几位，乘以10的倍数即可。<br>注意数据的转化和类型之间的切换。<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"onewire.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u16 ms = <span class="hljs-number">0</span>;u16 temper = <span class="hljs-number">0</span>;u8 smg_cnt=<span class="hljs-number">0</span>;u8 smg_buf[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>&#125;;u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-comment">//return 298-&gt;29.8</span><span class="hljs-function">u16 <span class="hljs-title">read_temperature</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">float</span> temper;u8 high,low;u16 temp;init_ds18b20();Write_DS18B20(<span class="hljs-number">0xcc</span>);Write_DS18B20(<span class="hljs-number">0x44</span>);Delay_OneWire(<span class="hljs-number">200</span>);init_ds18b20();Write_DS18B20(<span class="hljs-number">0xcc</span>);Write_DS18B20(<span class="hljs-number">0xbe</span>);low = Read_DS18B20();high = Read_DS18B20();temp = high&lt;&lt;<span class="hljs-number">8</span> | low;temper = temp*<span class="hljs-number">0.0625</span>;<span class="hljs-keyword">return</span> temper*<span class="hljs-number">10</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><span class="hljs-comment">//1毫秒@12.000MHz</span></span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Handle</span><span class="hljs-params">()</span> interrupt 1</span>&#123;ms++;P0 = T_COM[smg_cnt];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[smg_buf[smg_cnt]];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(smg_cnt++==<span class="hljs-number">7</span>)smg_cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ms == <span class="hljs-number">100000</span>)ms=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;Timer0Init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(ms % <span class="hljs-number">500</span>)temper = read_temperature();smg_buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">5</span>] = temper / <span class="hljs-number">100</span>;smg_buf[<span class="hljs-number">6</span>] = temper / <span class="hljs-number">10</span> % <span class="hljs-number">10</span> + <span class="hljs-number">32</span>;smg_buf[<span class="hljs-number">7</span>] = temper % <span class="hljs-number">10</span>;&#125;&#125;</code></pre></p><h2 id="DS1302时钟"><a href="#DS1302时钟" class="headerlink" title="DS1302时钟"></a>DS1302时钟</h2><p>对于时钟芯片，DS1302 应用也是颇为广泛，不仅在比赛中，实际应用中也不少。<br>也是相对复杂一些的内容，需要我们好好去记住并练习，才能在比赛中，熟练运用。<br>还好官方把驱动给了出来，要不真的难搞~，但如何写入和读取时间是我们需要完成的。</p><p><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220617174950298.png" alt></p><p>这个表在官方的芯片文档里面有，是需要我们打开看的，编写程序也是依托于他。</p><p>其实这个也是相对简单的，只是需要我们在写入或者读出的时候，把两位数的时间，分散成高位和低位的编码方式。即高四位表示 十位，低四位表示 个位。同时注意开关写入时刻的 wp 即可。</p><p>需要注意在c语言中，乘除的优先级高于 左移右移，所以在编写 读写代码时刻需要注意。<br>同时，由于定时器中断的影响，所以最好在使用DS18B20和DS1302这样的对时序有要求的模块时刻，在函数中采用中断的开启和关闭，不影响读取的完整操作。</p><p>而 对于 <code>ds1302.h</code>  <code>ds1302.c</code> 两个文件，我们基本没有更改其内容，所以就不赘述了。<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"ds1302.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u16 ms;u8 HH,MM,SS;u8 smg_cnt;u8 smg_buf[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>&#125;;u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><span class="hljs-comment">//1毫秒@12.000MHz</span></span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Handle</span><span class="hljs-params">()</span> interrupt 1</span>&#123;P0 = T_COM[smg_cnt];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[smg_buf[smg_cnt]];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(smg_cnt++==<span class="hljs-number">7</span>)smg_cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ms == <span class="hljs-number">100000</span>)ms=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_time</span><span class="hljs-params">()</span></span>&#123;u8 t;EA = <span class="hljs-number">0</span>;t = Read_Ds1302_Byte(<span class="hljs-number">0x81</span>);SS = (t&gt;&gt;<span class="hljs-number">4</span>)* <span class="hljs-number">10</span> +(t &amp; <span class="hljs-number">0x0f</span>);t = Read_Ds1302_Byte(<span class="hljs-number">0x83</span>);MM = (t&gt;&gt;<span class="hljs-number">4</span>)* <span class="hljs-number">10</span> +(t &amp; <span class="hljs-number">0x0f</span>);t = Read_Ds1302_Byte(<span class="hljs-number">0x85</span>);HH = (t&gt;&gt;<span class="hljs-number">4</span>)* <span class="hljs-number">10</span> +(t &amp; <span class="hljs-number">0x0f</span>);EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_time</span><span class="hljs-params">(u8 hh,u8 mm,u8 ss)</span></span>&#123;EA = <span class="hljs-number">0</span>;Write_Ds1302_Byte(<span class="hljs-number">0x8e</span>,<span class="hljs-number">0</span>);Write_Ds1302_Byte(<span class="hljs-number">0x80</span>,(ss/<span class="hljs-number">10</span>)&lt;&lt;<span class="hljs-number">4</span> | ss % <span class="hljs-number">10</span>);Write_Ds1302_Byte(<span class="hljs-number">0x82</span>,(mm/<span class="hljs-number">10</span>)&lt;&lt;<span class="hljs-number">4</span> | mm % <span class="hljs-number">10</span>);Write_Ds1302_Byte(<span class="hljs-number">0x84</span>,(hh/<span class="hljs-number">10</span>)&lt;&lt;<span class="hljs-number">4</span> | hh % <span class="hljs-number">10</span>);Write_Ds1302_Byte(<span class="hljs-number">0x8e</span>,<span class="hljs-number">0x80</span>);EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;write_time(<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);Timer0Init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(ms % <span class="hljs-number">1000</span>==<span class="hljs-number">0</span>)read_time();smg_buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;smg_buf[<span class="hljs-number">2</span>] = HH / <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">3</span>] = HH % <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">4</span>] = MM / <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">5</span>] = MM % <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">6</span>] = SS / <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">7</span>] = SS % <span class="hljs-number">10</span>;&#125;&#125;</code></pre></p><h2 id="ADC-DAC"><a href="#ADC-DAC" class="headerlink" title="ADC / DAC"></a>ADC / DAC</h2><p>可以说，只有 DAC 模块才需要我们去使用万用表来测量一下哈哈。<br>数模转换 是单片机一个比较重要的点，是真实世界与数字世界之间交换的桥梁。<br>采用的是模块 PCF8591 ，该模块采用IIC协议进行通讯，可以进行ADC和DAC的处理。<br>IIC设备地址见下图：即0x90<br><img src="/2022/06/16/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%8B%E5%86%8C/image20220617215822493.png" alt></p><p>要注意，如果读取出来的DAC的值是0-255，我们转换到5v既然要小数点后两位，不妨就采用500这样的范围。但是500超过了 unsigned char 的最大范围，所以最好用 u16；<br>具体的原因于精妙的地方，因为时间原因就不再补充了。如果明天国赛比完后，还有心情的话，就来补充。<br>比完赛了，么有心情。<br><pre><code class="hljs cpp"><span class="hljs-comment">//iic.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DELAY_TIME 50</span><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> <span class="hljs-title">read_adc</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> add)</span></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> t;    EA = <span class="hljs-number">0</span>;    IIC_Start();    IIC_SendByte(<span class="hljs-number">0x90</span>);    IIC_WaitAck();    IIC_SendByte(add);    IIC_WaitAck();    IIC_Start();    IIC_SendByte(<span class="hljs-number">0x91</span>);    IIC_WaitAck();    t = IIC_RecByte();    IIC_WaitAck();    IIC_Stop();    EA = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_dac</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> t)</span></span>&#123;    EA = <span class="hljs-number">0</span>;    IIC_Start();    IIC_SendByte(<span class="hljs-number">0x90</span>);    IIC_WaitAck();    IIC_SendByte(<span class="hljs-number">0x40</span>);    IIC_WaitAck();    IIC_SendByte(t);    IIC_WaitAck();    IIC_Stop();    EA = <span class="hljs-number">1</span>;&#125;</code></pre><br><pre><code class="hljs cpp"><span class="hljs-comment">//main.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>  <span class="hljs-meta-string">"intrins.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"iic.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;u16 ms;u8 smg_cnt;u8 smg_buf[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>&#125;;u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><span class="hljs-comment">//1毫秒@12.000MHz</span></span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Handle</span><span class="hljs-params">()</span> interrupt 1</span>&#123;P0 = T_COM[smg_cnt];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[smg_buf[smg_cnt]];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(smg_cnt++==<span class="hljs-number">7</span>)smg_cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ms++ == <span class="hljs-number">100000</span>)ms=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;u16 Light_value=<span class="hljs-number">0</span>;u16 v_value=<span class="hljs-number">0</span>;Timer0Init();write_dac(<span class="hljs-number">125</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(ms%<span class="hljs-number">500</span> == <span class="hljs-number">0</span>)&#123;v_value = (u16)(read_adc(<span class="hljs-number">1</span>)*<span class="hljs-number">500.0</span>/<span class="hljs-number">255</span>);smg_buf[<span class="hljs-number">0</span>] = v_value /<span class="hljs-number">100</span> +<span class="hljs-number">32</span>;smg_buf[<span class="hljs-number">1</span>] = v_value /<span class="hljs-number">10</span> %<span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">2</span>] = v_value %<span class="hljs-number">10</span>;Light_value = read_adc(<span class="hljs-number">3</span>);smg_buf[<span class="hljs-number">4</span>] = Light_value / <span class="hljs-number">1000</span>;smg_buf[<span class="hljs-number">5</span>] = Light_value % <span class="hljs-number">1000</span> /<span class="hljs-number">100</span>;smg_buf[<span class="hljs-number">6</span>] = Light_value % <span class="hljs-number">100</span> /<span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">7</span>] = Light_value % <span class="hljs-number">10</span>;&#125;&#125;&#125;</code></pre></p><h2 id="AT24C02-EEROM"><a href="#AT24C02-EEROM" class="headerlink" title="AT24C02-EEROM"></a>AT24C02-EEROM</h2><h2 id="超声波测距"><a href="#超声波测距" class="headerlink" title="超声波测距"></a>超声波测距</h2><p>这部分并不需要其他的驱动，但这也就意味着需要我们自己去完成全部的代码。<br>主要是发送波形，接受波形，如果对应的上，那么就可以根据飞行时间来确定距离。<br>发送的比较简单，需要发送八段脉冲波(40Khz)，，意味着延迟可以这样计算：</p><script type="math/tex; mode=display">1s ->1 000 000 us ; 40 k hz -> 40 000 Hz</script><script type="math/tex; mode=display">Delay = 1 000 000 / 40 000 / 2 = 13 us</script><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"STC15F2K60S2.H"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>    <span class="hljs-meta-string">"intrins.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;sbit TX = P1^<span class="hljs-number">0</span>;sbit RX = P1^<span class="hljs-number">1</span>;u16 ms,distance;u8 smg_cnt;u8 smg_buf[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>&#125;;u8 code t_display[]=&#123;                       <span class="hljs-comment">//标准字库</span><span class="hljs-comment">//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</span>    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7C</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5E</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>,<span class="hljs-comment">//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y</span>    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x76</span>,<span class="hljs-number">0x1E</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x5C</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x37</span>,<span class="hljs-number">0x6e</span>,    <span class="hljs-number">0xBF</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xDB</span>,<span class="hljs-number">0xCF</span>,<span class="hljs-number">0xE6</span>,<span class="hljs-number">0xED</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xEF</span>,<span class="hljs-number">0x46</span>&#125;;    <span class="hljs-comment">//0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1</span>u8 code T_COM[]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>&#125;;      <span class="hljs-comment">//位码</span><span class="hljs-comment">// 13 = 1 000 000 / 40 000 / 2</span><span class="hljs-comment">// 所需的是8个40Khz的发送波</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delay13us</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span></span>&#123;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i;_nop_();_nop_();i = <span class="hljs-number">36</span>;<span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_wave</span><span class="hljs-params">()</span></span>&#123;u8 i=<span class="hljs-number">8</span>;<span class="hljs-keyword">while</span>(i--)&#123;TX = <span class="hljs-number">1</span>;Delay13us();TX = <span class="hljs-number">0</span>;Delay13us();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_wave</span><span class="hljs-params">()</span></span>&#123;u16 time;EA = <span class="hljs-number">0</span>;send_wave();EA = <span class="hljs-number">1</span>;TH1 = <span class="hljs-number">0</span>;TL1 = <span class="hljs-number">0</span>;TR1 = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>((RX == <span class="hljs-number">1</span>) &amp;&amp; (TF1 == <span class="hljs-number">0</span>));TR1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(TF1 == <span class="hljs-number">1</span>)TF1 =<span class="hljs-number">0</span>;<span class="hljs-keyword">else</span>&#123;time = (TH1 &lt;&lt; <span class="hljs-number">8</span>) | TL1;distance = (u16)(time * <span class="hljs-number">34000</span> /<span class="hljs-number">1000000</span> / <span class="hljs-number">2</span>);<span class="hljs-comment">//distance = (u16)(time * 0.017);//34 000 / 1000 000 / 2</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span><span class="hljs-comment">//1毫秒@12.000MHz</span></span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Timer0Handle</span><span class="hljs-params">()</span> interrupt 1</span>&#123;P0 = T_COM[smg_cnt];P2 = <span class="hljs-number">0xc0</span>;P2 = <span class="hljs-number">0</span>;P0 = ~t_display[smg_buf[smg_cnt]];P2 = <span class="hljs-number">0xe0</span>;P2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(smg_cnt++==<span class="hljs-number">7</span>)smg_cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ms++ == <span class="hljs-number">100000</span>)ms=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;Timer0Init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>((ms % <span class="hljs-number">200</span>) ==<span class="hljs-number">0</span>)&#123;get_wave();smg_buf[<span class="hljs-number">0</span>] = distance / <span class="hljs-number">100</span>;smg_buf[<span class="hljs-number">1</span>] = distance / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;smg_buf[<span class="hljs-number">2</span>] = distance % <span class="hljs-number">10</span>;&#125;&#125;&#125;</code></pre><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://baiblog.top/lq1/" target="_blank" rel="noopener">https://baiblog.top/lq1/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要是 记录下来关于蓝桥杯比赛板中的一些比较模块化和认为可在今后借鉴的内容。包括了自己的一丢丢理解和包括了广大互联网的智慧结晶。&lt;br&gt;2022 年&lt;a href=&quot;赛点资源数据包_SCM_2022.zip&quot;&gt;第十三届单片机类赛点数据包&lt;/a&gt;，以供下载。相关介绍可以浏览 &lt;a href=&quot;https://baiblog.top/lq2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt; 。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="EE" scheme="https://jefine.github.io/categories/EE/"/>
    
    
    <category term="BlueBridge" scheme="https://jefine.github.io/tags/BlueBridge/"/>
    
  </entry>
  
  <entry>
    <title>Flask_First_Api</title>
    <link href="https://jefine.github.io/2022/05/14/Flask_First_Api/"/>
    <id>https://jefine.github.io/2022/05/14/Flask_First_Api/</id>
    <published>2022-05-14T13:02:38.000Z</published>
    <updated>2022-06-16T08:18:53.829Z</updated>
    
    <content type="html"><![CDATA[<p>Flask 作为一个轻量级的 Python 前端网页框架，正在逐渐壮大，而在一些近期的一些项目中，也常出现其身影，作为前端和后端相互结合的框架，适合我们去快速构建一个服务器端的服务应用，同时也方便了自己的维护，更重要的是构建起较为完善的技术栈。</p>  <a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在本次的 Flask 的初步学习中采用的环境是:<br>Python 3.85 + VScode + Conda + Flask2.1</p><h3 id="关于-VScode-配置"><a href="#关于-VScode-配置" class="headerlink" title="关于 VScode 配置"></a>关于 VScode 配置</h3><p>关于 Pycharm 还是 VScode，这里采用了 VScode，主要是觉得 Pycharm 有时打开时刻比较笨重，而且最近对于 Python 的开发比较少的在 VScode 中进行，希望能够因此而熟悉一下相关    操作。</p><p>VScode 的 Python 命令行配置<br>在编写完成一个 helloworld 的时候，我们想要使用 VScode 进行终端的操作，但是默认的 VScode 的终端操作是 Powershell（默认的前缀是 ps），不是很友好，而且对于 Conda 的适配不好，所以尽量更改为 cmd 环境。<br>在我们的 CMD 环境中，我们可以使用 Flask 命令进行更好的操作。</p><p>首先在右下角的终端处进行简单更多选项的箭头，选择默认配置文件<br><img src="/2022/05/14/Flask_First_Api/image20220513192022828.png" alt></p><p>进而选择 Command Prompt（这里我更改过了，所以默认就是 cmd）</p><p>然而，在我们再次打开 VScode 的时候，cmd 并不会自动激活 conda 或者进入相关路径，这时，我们自己在右下角新建一个终端即可。这样 cmd 的配置就可以了，Conda 会自动激活当前环境，Python 的编译器会在左下角进行选择，而更多的关于 VScode 的 Python 的环境配置，可以在互联网中进行搜索解决。</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>主要使用的文档是官方文档的 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#" target="_blank" rel="noopener">QuickStart</a><br>开始第一个 Demo 吧<br><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)  <span class="hljs-meta">@app.route("/")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span></code></pre></p><p>如果将自己的 Python 文件命名为 app.py 就不用去设置环境变量了<br>如果命名为其他的需要去 声明一个环境变量（根据不同的 终端环境进行设置）其中 hello 为自己无 py 后缀的文件名。</p><pre><code class="hljs cmd">#在 <span class="hljs-built_in">cmd</span> 下<span class="hljs-built_in">set</span> FLASK_APP=hello</code></pre><pre><code class="hljs bash"><span class="hljs-comment">#在bash下</span><span class="hljs-built_in">export</span> FLASK_APP=hello</code></pre><h3 id="对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下"><a href="#对于重启后出现-cannot-import-name-‘soft-unicode’-from-‘markupsafe’-报错-如下" class="headerlink" title="对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下"></a>对于重启后出现 cannot import name ‘soft_unicode’ from ‘markupsafe’ 报错,如下</h3><pre><code class="hljs bash">File <span class="hljs-string">"E:\python3.8\lib\site-packages\jinja2\filters.py"</span>, line 13, <span class="hljs-keyword">in</span> &lt;module&gt;    from markupsafe import soft_unicodeImportError: cannot import name <span class="hljs-string">'soft_unicode'</span> from <span class="hljs-string">'markupsafe'</span> (E:\python3.8\lib\site-packages\markupsafe\__init__.py)</code></pre><p>可以尝试去降级 MarkupSafe 以解决问题<br><code>pip install MarkupSafe==2.0.1</code></p><p>继续运行程序<br><pre><code class="hljs bash">flask run</code></pre><br>单击或自行访问出现的 <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> 即可查看到运行结果<br><img src="/2022/05/14/Flask_First_Api/image20220513193229672.png" alt><br><img src="/2022/05/14/Flask_First_Api/image20220513193448880.png" alt></p><p>可以看到在前面的 @app.route(“/“) 中引号内的内容，表示了 URL 路径。<br>我们可以添加一下代码，然后重新运行（需要关闭当前的 Flask 运行界面，然后重现 flask run）</p><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/apple")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Apple</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"returned an apple!"</span></code></pre><p><img src="/2022/05/14/Flask_First_Api/image20220513194739396.png" alt></p><p>这样就实现了 API 的访问 （wow）<br>但是我们默认返回的是 String 字符串，这点需要注意。</p><h2 id="如何使用其他的访问方式-如-post？"><a href="#如何使用其他的访问方式-如-post？" class="headerlink" title="如何使用其他的访问方式 如 post？"></a>如何使用其他的访问方式 如 post？</h2><p>观察到我们命令行出现的提示信息：<br><pre><code class="hljs bash">127.0.0.1 - - [13/May/2022 19:45:15] <span class="hljs-string">"GET /apple HTTP/1.1"</span> 200 -</code></pre><br>采用的 获取方式都是 Get，一方面是因为 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#http-methods" target="_blank" rel="noopener">Flask 的默认方式</a> 就是 Get，另一方面是因为采用浏览器访问，访问就是 Get 方式。</p><h3 id="如何处理-post-请求，Flask-方面的解决办法是"><a href="#如何处理-post-请求，Flask-方面的解决办法是" class="headerlink" title="如何处理 post 请求，Flask 方面的解决办法是"></a>如何处理 post 请求，Flask 方面的解决办法是</h3><p>添加模块<br><code>from flask import request</code><br>然后对比修改代码，如下：</p><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/",methods=['GET', 'POST'])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">"here is a post"</span>    <span class="hljs-keyword">else</span> :        <span class="hljs-keyword">return</span> <span class="hljs-string">"A great world"</span></code></pre><p>需要注意，对于模块的 import 如果大小写引入错误，将会无法正常运行，同样需要注意 method 和 methods 的区分</p><h3 id="如何发送-post-请求"><a href="#如何发送-post-请求" class="headerlink" title="如何发送 post 请求"></a>如何发送 post 请求</h3><p>这里采用 postman 本地应用进行发送 post 请求<br><img src="/2022/05/14/Flask_First_Api/image20220513200854627.png" alt></p><h2 id="如何返回-JSON"><a href="#如何返回-JSON" class="headerlink" title="如何返回 JSON"></a>如何返回 JSON</h2><p>JSON 是一个结构化的数据，可以方便我们进行数据的处理<br>对于 <a href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#about-responses" target="_blank" rel="noopener">JSON 的返回值处理</a> ，我们根据文档可以看出，如果采用字典返回那么自动就会通过 一个方法<code>jsonify</code>转换成json<br><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> dict(name = <span class="hljs-string">'a'</span>,num = <span class="hljs-number">100</span>)</code></pre></p><p>添加代码后，重启服务，访问 <a href="http://127.0.0.1:5000/json" target="_blank" rel="noopener">http://127.0.0.1:5000/json</a><br><img src="/2022/05/14/Flask_First_Api/image20220513224148375.png" alt><br>可以看到， Firefox 浏览器自动将其解析为了 Json ，并进行了梅花，方便了阅读和处理。</p><h2 id="如何从前端获取数据到后端"><a href="#如何从前端获取数据到后端" class="headerlink" title="如何从前端获取数据到后端"></a>如何从前端获取数据到后端</h2><p>在 web 开发的过程中，从客户端获取信息到服务器上，就需要对于 Request 作出一定的处理：</p><h3 id="在-URL-中添加-参数-信息"><a href="#在-URL-中添加-参数-信息" class="headerlink" title="在 URL 中添加 参数 信息"></a>在 URL 中添加 参数 信息</h3><p>通常使用 get 进行操作<br>代码参考如下：<br><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/json_another")</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">json_another</span><span class="hljs-params">()</span>:</span>    name = request.args.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)    <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'qaq'</span>):        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)    <span class="hljs-keyword">else</span> :        <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'flase'</span>)</code></pre><br>如果在访问 <a href="http://127.0.0.1:5000/json_another" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another</a> 而不加任何参数的时候，就会获取不到相关的内容，进而判断失败。</p><p><img src="/2022/05/14/Flask_First_Api/image20220513230539337.png" alt></p><p>如果 <a href="http://127.0.0.1:5000/json_another?name=qaq" target="_blank" rel="noopener">http://127.0.0.1:5000/json_another?name=qaq</a> 输入正确的用户名和变量名称，那么就可以检测成功。</p><p><img src="/2022/05/14/Flask_First_Api/image20220513230650761.png" alt></p><h3 id="采用-body-的form-和-json-形式传输数据"><a href="#采用-body-的form-和-json-形式传输数据" class="headerlink" title="采用 body 的form 和 json 形式传输数据"></a>采用 body 的form 和 json 形式传输数据</h3><p>而在文档上，也提供给了我们 <a href="https://flask.palletsprojects.com/en/2.1.x/api/#flask.Request.form" target="_blank" rel="noopener" title="flask.Request.form"><code>form</code></a> 的形式，通常我们如果需要发送数据到服务器上去，往往采用 post 和 put 这样比较规范的操作（据说使用get也可以，但是有的公司万物皆哈梭 get ，总是不太好，丧失了规范性）</p><p>有时同样的代码也会有一写小 bug,通过下面的一些代码，借由 Postman 软件进行发送 post 请求，进行测试</p><pre><code class="hljs Python"><span class="hljs-meta">@app.route("/form",methods=['GET','POST'])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">form</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">'POST'</span>:        print(request.form.get(<span class="hljs-string">'name'</span>))        print(request.json)        print(request.data)        Fname = request.form.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)        <span class="hljs-keyword">if</span> (Fname == <span class="hljs-string">'null'</span>):            Jname = request.json.get(<span class="hljs-string">'name'</span>,<span class="hljs-string">'null'</span>)            <span class="hljs-keyword">if</span>(Jname == <span class="hljs-string">'qaq'</span>):                <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'true'</span>)        <span class="hljs-keyword">if</span>(Fname == <span class="hljs-string">'pap'</span>):            <span class="hljs-keyword">return</span> dict(check=<span class="hljs-string">'true'</span>)        <span class="hljs-keyword">else</span> :            <span class="hljs-keyword">return</span> dict(check = <span class="hljs-string">'false'</span>)    <span class="hljs-keyword">else</span> :        <span class="hljs-keyword">return</span> <span class="hljs-string">"this is a get request"</span></code></pre><p>可以看到，/form URL 路径仅仅对于 post 请求作出了回应，如果是其他类型的请求，直接返回  “this is a get request”<br>对于 post 请求，我们在里面放置了两种在 Body 里面的格式内容，分别是 form 和 json<br>这两种我们都将会去使用：为了避免冲突，所以将 json 和 form 的调试放在了有些不一样的 if 分支里面。<br>对于 form：<br><img src="/2022/05/14/Flask_First_Api/image20220514075344866.png" alt><br>对于 json<br><img src="/2022/05/14/Flask_First_Api/image20220514075407137.png" alt></p><p>部分参考链接：<br><a href="https://www.bilibili.com/video/BV1Fz4y1d7kc" target="_blank" rel="noopener">Bilibili 视频</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flask 作为一个轻量级的 Python 前端网页框架，正在逐渐壮大，而在一些近期的一些项目中，也常出现其身影，作为前端和后端相互结合的框架，适合我们去快速构建一个服务器端的服务应用，同时也方便了自己的维护，更重要的是构建起较为完善的技术栈。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://jefine.github.io/categories/web/"/>
    
    
    <category term="flask" scheme="https://jefine.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>干饭小助手 Meal_Alter_Bot</title>
    <link href="https://jefine.github.io/2022/05/10/%E5%B9%B2%E9%A5%AD%E5%B0%8F%E5%8A%A9%E6%89%8BMeal_Alter_Bot/"/>
    <id>https://jefine.github.io/2022/05/10/%E5%B9%B2%E9%A5%AD%E5%B0%8F%E5%8A%A9%E6%89%8BMeal_Alter_Bot/</id>
    <published>2022-05-10T09:01:45.000Z</published>
    <updated>2022-05-14T13:00:24.150Z</updated>
    
    <content type="html"><![CDATA[<p>A bot to forward the QQ message to user,then send it to your bot.</p><p>Meal_Alter_Bot 项目是基于 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener"></a><a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">https://github.com/Mrs4s/go-cqhttp</a> 项目进行开发的QQ机器人，通过监控聊天信息，获取干饭通知，通过 ESP32 Wi-Fi 通信功能，控制设备进行蜂鸣器提醒。<br>  <a id="more"></a><br>其主要的功能实现来源于 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener"></a><a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">https://github.com/Mrs4s/go-cqhttp</a> 项目所开发的机器人，该程序能够通过模拟登录自己的 QQ 帐号，将其作为机器人，对 QQ 的各种消息和提醒进行监控于处理，还能将其给进一步发送出去，实现了 QQ 不开源，不开放 API 状态下的开放功能。（当然，此项目可能违反 Tencent 相关用户协议，存在封号可能，不建议将大号作为机器人）</p><p>在将 QQ 所获取的消息进行监控后，通过 Python 功能便携 Flask 应用，实现对于 QQ 消息的实时监控，并二次筛选处自己所需要的内容，进而通过 MQTT 协议，发送的执行器，进行设备的控制。</p><h2 id="所需环境：Python3"><a href="#所需环境：Python3" class="headerlink" title="所需环境：Python3"></a>所需环境：Python3</h2><h2 id="机器人搭建"><a href="#机器人搭建" class="headerlink" title="机器人搭建"></a>机器人搭建</h2><p>指的是将自己的 QQ 作为机器人部署在服务器或个人电脑上</p><p>（支持 Win/Linux ）</p><p>这里采用的框架和应用是 <a href="https://github.com/Mrs4s/go-cqhttp" target="_blank" rel="noopener">go-cqhttp</a>，是当下为数不多可供使用的 QQ 机器人（Tencent封杀使其越来越封闭）</p><h3 id="新建文件夹，并进入对应目录"><a href="#新建文件夹，并进入对应目录" class="headerlink" title="新建文件夹，并进入对应目录"></a>新建文件夹，并进入对应目录</h3><h3 id="下载相应文件："><a href="#下载相应文件：" class="headerlink" title="下载相应文件："></a>下载相应文件：</h3><p>Linux 下通过命令行，下载合适的安装包到自己的机器上</p><p><code>wget &lt;https://github.com.cnpmjs.org/Mrs4s/go-cqhttp/releases/download/v1.0.0-beta4/go-cqhttp_linux_amd64.tar.gz</code>&gt;</p><p>而 Windows 用户可以直接在浏览器上进行下载，<a href="https://github.com/Mrs4s/go-cqhttp/releases/tag/v1.0.0-rc1" target="_blank" rel="noopener">下载地址</a></p><p>注意区分不同版本（Linux 也可以由用户下载好之后，直接上传到服务器上）</p><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>Linux 下命令如下</p><p><code>tar -zxvf go-cqhttp_linux_amd64.tar.gz</code></p><p>Win 下请按照自己的解压工具进行解压</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>Linux 下命令如下</p><p><code>chmod +x go-cqhttp</code></p><p>Win 下建议使用管理员权限 打开 go-cqhttp</p><h3 id="初始化程序"><a href="#初始化程序" class="headerlink" title="初始化程序"></a>初始化程序</h3><p>当然，现在还不需要去打开运行，我们可以先打开 config.yml 文件，进行配置</p><p>如果没有运行过 go-cqhttp 是没有此文件的，可采用本 Github 所提供的文件进行配置。</p><p>需要配置的内容不多，本项目只更改了</p><ul><li>第四五行的QQ帐号（纯数字即可），密码（注意单引号）</li><li>倒数第八行的 URL 地址，将端口发送到 127.0.0.1:10001 进行通信</li></ul><p>用户可以直接第一次运行程序后，自行进行修改上述内容进行应用。</p><p>如果不添加QQ帐号和密码到 config.yml 文件中，第一次登录后 会使用扫码登录，但是我使用此选项失败了~</p><p>接下来就是第一次运行程序，进行初始化了</p><p>Linux 下通过该命令打开</p><p><code>./go-cqhttp</code></p><p>如果是第一次打开，会让你选择采用什么方式运行，这里选择 http 也就是 1 即可</p><p>等待其配置完成</p><p>就会自动转发 信息到接口处</p><p>此时使用 Ctrl + c 便可以关闭程序。</p><h3 id="运行-Python程序"><a href="#运行-Python程序" class="headerlink" title="运行 Python程序"></a>运行 Python程序</h3><p>Python 的环境要求是 Python3</p><p>首先，打开 <a href="http://app.py" target="_blank" rel="noopener">app.py</a> ，进行修改</p><p>这里需要修改的也就是自己的 MQTT 服务器地址和所需要修改的关键词，过滤的群号，详见文件内注释说明。</p><p>在运行之前，我们还需要安装 Python 的相关库，这里用到了 paho.mqtt 和 flask</p><p>首先采用</p><pre><code class="hljs bash">pip3 install paho.mqtt</code></pre><pre><code class="hljs bash">pip3 install flask</code></pre><p>配置完成后，可以使用 python3 <a href="http://app.py" target="_blank" rel="noopener">app.py</a> 即可运行，该程序便会将需要的转发的内容发送到MQTT服务器的对应主题上。</p><p>在服务器上，我们往往采用 SSH 的方式进行连接，为避免关闭界面后，运行停止，我们可以采用命令nohup ~ &amp;将其挂起,</p><p>即使用</p><pre><code class="hljs bash">nohup ./go-cqhttp &amp;nohup python3 app.py &amp;</code></pre><p>其对应的终端输入日志将保存在.out文件中</p><h3 id="配置-ESP32"><a href="#配置-ESP32" class="headerlink" title="配置 ESP32"></a>配置 ESP32</h3><p>准备一个 ESP32 开发板，正常的型号就可以，这里仅仅采用了 WiFi，运用了 MQTT 的库文件，详细代码参考 本项目中的 ESP32_Meal_Alter_Bot 文件夹中的内容即可。</p><p>本 ESP32 项目采用 Vscode +platformio 进行开发</p><p>用户可以自行将 ESP32_Meal_Alter_Bot/src 中的主程序复制到 Arduino 程序中进行开发，对于 ESP32 的相关环境配置，网络中已经有很多，不再赘述，请善用百度。</p><p>对于 ESP32 的功能和代码修改介绍： 该开发板所控制的外部设备有且仅有一个，就是蜂鸣器，通过及其简单的高低电平使其发声，预警提醒。 在代码中，首先修改前面的 Wi-Fi 帐号密码，其次是 MQTT 服务器的地址，需要与上述一致。 在本代码中，用户可以进一步的通过 ESP32 的代码修改，进行二次过滤关键词，也可以修改不同的 MQTT 主题，进行应用。</p><p>将ESP32 代码进行编译烧录后进行上传，在测试成功后，即可正常使用。</p><p>因为疫情，被隔离在校，闲暇之余，手边恰好有相关的设备和单片机，于是便开始动手实践，本项目中，比较困难的是QQ机器人的项目查找，之后的数据流转相对简单。<br>然而做好项目的第二天，疫情形式严峻了，就送饭上门了~</p><p>诚信而言，本次项目的许多内容都是基于互联网上的成熟模组进行搭建，极大的加速了开发者的开发速度，但次项目还有着许多的潜力可以去挖掘，不仅仅是机器人，更重要的是在每一个环节，我们都可以进行二次修改，如何应对高并发，如何形成集群？等等方向都是此项目的可升华之处，作为一个点灯项目，其到此为止吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;A bot to forward the QQ message to user,then send it to your bot.&lt;/p&gt;
&lt;p&gt;Meal_Alter_Bot 项目是基于 &lt;a href=&quot;https://github.com/Mrs4s/go-cqhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mrs4s/go-cqhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Mrs4s/go-cqhttp&lt;/a&gt; 项目进行开发的QQ机器人，通过监控聊天信息，获取干饭通知，通过 ESP32 Wi-Fi 通信功能，控制设备进行蜂鸣器提醒。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://jefine.github.io/categories/web/"/>
    
    
    <category term="ESP32" scheme="https://jefine.github.io/tags/ESP32/"/>
    
    <category term="flask" scheme="https://jefine.github.io/tags/flask/"/>
    
    <category term="MQTT" scheme="https://jefine.github.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>YoloV5 学习与训练</title>
    <link href="https://jefine.github.io/2022/02/14/YoloV5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%AD%E7%BB%83/"/>
    <id>https://jefine.github.io/2022/02/14/YoloV5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%AD%E7%BB%83/</id>
    <published>2022-02-14T08:20:41.000Z</published>
    <updated>2022-02-14T08:45:54.823Z</updated>
    
    <content type="html"><![CDATA[<p>简要学习 YoloV5，通过在云端训练和本地推理，初步入门 ML 的图形识别场景。实现对特定物体的检测和框选。</p>  <a id="more"></a><p>在进行物体识别的图形应用场景下，看到 Yolo 的普遍应用，便希望自己能够用到 [[YoloV5]] 框架，同时在整个机器学习，人工智能，学习的环境下，图像类的机器学习是最为热门和具有实用性质的内容。而区别于物体分类，物体检测相对更为复杂，但是也更具有实用性和拓展性，能够在众多的场景和众多设备下进行应用与部署。因此特地进行 Yolo 的学习，希望能够尽快掌握自定义数据集的物体检测的能力。<br>积累了关于 物体识别 的相关技术栈经验。</p><p>课程主要跟随 <a href="https://www.bilibili.com/video/BV1tf4y1t7ru" target="_blank" rel="noopener">Bilibili 的网课</a> 进行学习。</p><h2 id="安装-YoloV5-5-0-时的问题"><a href="#安装-YoloV5-5-0-时的问题" class="headerlink" title="安装 YoloV5 5.0 时的问题"></a>安装 YoloV5 5.0 时的问题</h2><p>直接下载 <a href="https://github.com/ultralytics/yolov5/tree/v5.0" target="_blank" rel="noopener">tag 5.0 版本</a> 的源代码进行学习即可。<br>如果因为网络环境打不开，可以通过 Gitee 的 <a href="https://gitee.com/monkeycc/yolov5/tree/v5.0" target="_blank" rel="noopener">5.0 链接</a> 进行下载</p><p>下载后，通过 Pycharm 打开（非要用其他的也 OK），继而在 Conda 或其他 Python 选择好的环境下，根据 requerments.txt 进行 pip install ~即可。</p><h3 id="pycocotools-安装失败"><a href="#pycocotools-安装失败" class="headerlink" title="pycocotools 安装失败"></a>pycocotools 安装失败</h3><p>而对于 特殊的 pycocotools ，很难在 windows 上进行安装，目前采用的简单的方法是：</p><blockquote><p>GitHub 上有 windows 版 pycocotools 了。<br>pip install pycocotools-windows<br>win10+anaconda 环境亲测有效</p></blockquote><p>在打开 detect.py 进行运行（相当于 Hello world ）时，可能会出现一些报错提醒你有些插件没有安装，继续 pip install 即可</p><p>对于 其他问题，多半通过复制最后一行代码，百度即可找到方案</p><h3 id="出现-Can’t-get-attribute-SPPF-on-module-models-common"><a href="#出现-Can’t-get-attribute-SPPF-on-module-models-common" class="headerlink" title="出现 Can’t get attribute SPPF on module models.common"></a>出现 Can’t get attribute SPPF on module models.common</h3><p>运行 yolov5 下面 Tags5 的代码,出现了这个报错：<br>AttributeError: Cant get attribute SPPF on module models.common from e: \pyWorkSpace\yolov5-5.0\models\common.py</p><p>解决方案是：去 Tags6 里面的 model/common.py 里面去找到这个 SPPF 的类,把它拷过来到你这个 Tags5 的 model/common.py 里面,这样你的代码就也有这个类了,还要引入一个 warnings 包就行了！</p><p>有的同学找不到 SPPF 这个类，那我现在直接粘贴在这里，你们只需要复制到你们的 common.py 里面即可，记得把 import warnings 放在上面去：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> warnings<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPPF</span><span class="hljs-params">(nn.Module)</span>:</span>    <span class="hljs-comment"># Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, c1, c2, k=<span class="hljs-number">5</span>)</span>:</span>  <span class="hljs-comment"># equivalent to SPP(k=(5, 9, 13))</span>        super().__init__()        c_ = c1 // <span class="hljs-number">2</span>  <span class="hljs-comment"># hidden channels</span>        self.cv1 = Conv(c1, c_, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)        self.cv2 = Conv(c_ * <span class="hljs-number">4</span>, c2, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)        self.m = nn.MaxPool2d(kernel_size=k, stride=<span class="hljs-number">1</span>, padding=k // <span class="hljs-number">2</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x)</span>:</span>        x = self.cv1(x)        <span class="hljs-keyword">with</span> warnings.catch_warnings():            warnings.simplefilter(<span class="hljs-string">'ignore'</span>)  <span class="hljs-comment"># suppress torch 1.9.0 max_pool2d() warning</span>            y1 = self.m(x)            y2 = self.m(y1)            <span class="hljs-keyword">return</span> self.cv2(torch.cat([x, y1, y2, self.m(y2)], <span class="hljs-number">1</span>))</code></pre><h2 id="在运行-detect-或-train-时，提示-缺少-pycocotools"><a href="#在运行-detect-或-train-时，提示-缺少-pycocotools" class="headerlink" title="在运行 detect 或 train 时，提示 缺少 pycocotools"></a>在运行 detect 或 train 时，提示 缺少 pycocotools</h2><p>这是因为在运行的时候，程序会去检测 requerments 是否完全达标，在 requerments 里面将 pycocotools 屏蔽 ‘#’ 即可，因为我们已经安装了 pycocotools-windows ，而其其意义不大。</p><h2 id="运行-YoloV5"><a href="#运行-YoloV5" class="headerlink" title="运行 YoloV5"></a>运行 YoloV5</h2><p>通过 在 Terminal 运行<br><code>python detect.py</code><br>或者 Pycharm 在 detect 文件下的运行</p><p>当然，我们在这个下面进行运行视频，也是可以的，但其实也是一帧一帧进行处理的。</p><p>之后，在 [[Colab]] 上进行 YoloV5 的学习不仅能够快速方便地配置环境，而且能够充分利用云服务器的 GPU 进行训练。<br>Colab 的服务器上 GPU，免费的一半是 K80，12G ，粗略计算 比本人笔记本的 Cpu 推理，机器学习的速度快 30 倍。<br>之后通过 Google Driver 进行保存相关的模型数据，自己是将其作为了一个大的压缩包，给放到云盘上了，方便下次直接恢复运行的环境。</p><p>当然之后又通过 <a href="https://aistudio.baidu.com/aistudio/projectdetail/2495241?channelType=0&amp;channel=0" target="_blank" rel="noopener">螺丝螺母</a> 分类的项目通过 Yolov5 进行了重新训练，主要耗费时间的就是 数据集格式的转换，通过自己的低水平 Python 代码和高水平的 GitHub AutoPiolt 的协作，写了好几个小时，才将其转换过来，好在跑起来之后 的效果不错，97% 的准确率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简要学习 YoloV5，通过在云端训练和本地推理，初步入门 ML 的图形识别场景。实现对特定物体的检测和框选。&lt;/p&gt;</summary>
    
    
    
    <category term="ML" scheme="https://jefine.github.io/categories/ML/"/>
    
    
    <category term="YoloV5" scheme="https://jefine.github.io/tags/YoloV5/"/>
    
  </entry>
  
  <entry>
    <title>ESP32_IDF_VScode配置环境</title>
    <link href="https://jefine.github.io/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <id>https://jefine.github.io/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</id>
    <published>2022-01-09T07:37:54.000Z</published>
    <updated>2022-01-09T07:40:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>ESP32官方推荐的IDF开发环境，可以作为插件，在VScode中进行编译烧录。<br>需要安装数G环境，如果不是必须，可以尽量使用 Arduino 方式进行编程。</p>  <a id="more"></a><ol><li>安装 vscode</li><li>到<a href="https://dl.espressif.com/dl/esp-idf/?idf=4.3" target="_blank" rel="noopener">连接中</a>下载离线的 idf 安装器</li></ol><p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled.png" alt="pic"></p><p>一定要使用离线版本的，因为在线版本安装的时候需要下载依赖，而且由于国内网络环境问题，所以很慢，甚至还很可能发生失败。</p><ol><li>打开 vscode，安装插件 esp-idf<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 1.png" alt="pic"></li><li>配置 idf 源码的位置和 tools 的位置，这个位置就是刚开始安装 offline 这个环境时选<br>择的位置。</li></ol><p>具体的是 按下 ctrl+p 然后输入 &gt;ESP-IDF: configure paths 详细见箭头处<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 2.png" alt="pic"></p><ol><li>接着就是上图的方块处，配置插件</li></ol><p>应该出现的红框如果没有出现，那就意味着上一步的 path 没有配置</p><p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 3.png" alt="pic"></p><ol><li>接着就应该直接创建虚拟的 python 环境了，但是<strong>如果挂了代理，需要关闭</strong>，否则会出现下载失败的提示。</li><li>这样就配置好了。</li><li>使用例程创建一个工程<br><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 4.png" alt="pic"></li></ol><p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 5.png" alt="pic"><br>配置 device，可以选择 ESP32 也可以选择 ESP32C3。</p><p><img src="/2022/01/09/ESP32_IDF_VScode%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/Untitled 6.png" alt="pic"></p><ol><li>然后编译，下载，就行了（如果下载失败，就在其 connect 的时候先按下 boot，再按下 reset，松开reset，再松开boot就行了，应该是第一步reboot 到 boot模式没起到效果，这里手动就可以了） </li></ol><p>注意：通过 vscode 进行的编译十分缓慢 大约2min，<strong>如果使用 ESPIDF 终端，大概在30s</strong></p><p>而对于Menu configure 暂时不改动（基本上不需要改动）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ESP32官方推荐的IDF开发环境，可以作为插件，在VScode中进行编译烧录。&lt;br&gt;需要安装数G环境，如果不是必须，可以尽量使用 Arduino 方式进行编程。&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="ESP32" scheme="https://jefine.github.io/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>ESP32</title>
    <link href="https://jefine.github.io/2022/01/09/ESP32/"/>
    <id>https://jefine.github.io/2022/01/09/ESP32/</id>
    <published>2022-01-09T07:20:59.000Z</published>
    <updated>2022-01-18T12:09:14.425Z</updated>
    
    <content type="html"><![CDATA[<p>近期，多次使用了 ESP32 系列的模组，发现 ESP32 的一些优良特性，后期打算继续将其作为网络节点，特此介绍 ESP32 的可用性以及其特点。</p>  <a id="more"></a><p><a href="https://www.espressif.com/en/products/socs/esp32" target="_blank" rel="noopener">ESP32</a> 是一颗国产芯片，由位居上海的乐鑫科技研发，在其 <a href="https://www.espressif.com/zh-hans/home" target="_blank" rel="noopener">官网</a> 上我们可看到更为详细的说明。<br>以下特点吸引了我：</p><ul><li><strong>WIFI &amp; Bluetooth</strong>： 双模的网络链接方式，让我们可以去探寻更多的物联网设备通信的可能性。（虽然我没有用过 ESP32 的蓝牙，但是我可不用，但不能没有🙈）</li><li><strong>MCU</strong> ：自己既可作为一个独立的模块正常工作，而且是采用了 32 架构的芯片，其性能也可以达到几百 MHz（区别于不同的型号），基本上和 STM32 性能相匹配，甚至于还要强于 STM32。</li><li><strong>低功耗</strong>：支持深度休眠，等等这个性能没有去测试过，但确实，从目前物联网设备的使用程度中，许多 Wi-Fi 芯片都采用了乐鑫科技出品的芯片，也证实了其可靠性，低功耗。</li><li><strong>易用性</strong>：上手快，可以采用 Arduino 快速上手，如果使用的开发板，那么上手的速度甚至比 Arduino uno 还要快，也是比较便宜的 Arduino 类型的产品了。</li><li><strong>可移植性强</strong>：这一点指的还是采用了 Arduino 的特点，所以比较方便在 ESP8266 中使用也同样应用于 ESP32（在不启用一些特殊的功能的情况下）</li><li><strong>RISC_V 架构</strong>：可以说是和 k210 一起推动了 RISC_V 生态的建设吧，也算是独立创新的一个努力。</li><li><strong>成本低</strong>：没有像 STM32 一样在芯片的涨价潮中，突飞猛进。仍然保持一个较为合理的价格。因为无论是拿来做一个通信模块或协处理器，性价都比较高。</li><li><strong>发展趋势良好</strong>：ESP32 系列芯片基本都支持 FreeRTOS，而且是官方的支持，同样官方也提供了 IDF 的开发套件，但是 emm 就好比 c 和 python 的区别类似，前期可以不需要去掌握 IDF。</li></ul><p>开发环境：建议采用 VScode 进行开发，同时使用 Platform 进行开发，方便快捷，而且易于编译和下载。</p><p><img src="/2022/01/09/ESP32/Untitled.png" alt="Untitled"></p><p>一些常用的相关软件：</p><p><a href="CP2102驱动For+WIN7+X64.rar">CP2102驱动For+WIN7+X64.rar</a></p><p><a href="esp_wroom_32_datasheet_cn.pdf">esp_wroom_32_datasheet_cn.pdf</a></p><p>下面的仓库中由一些比较有意思和可供参考的内容</p><p><a href="https://github.com/Homepea7/ESP32_Code" target="_blank" rel="noopener">https://github.com/Homepea7/ESP32_Code</a></p><p>在该仓库的Pinset中，有不少是可以直接拿来使用的。比如0.ESP32_Pinout.xlsx，就可以在实际的开发中，将其拷贝到工程下，当作一个Cubemx进行使用，来表明自己已经使用了哪些引脚，而且可以快速的查看他们之间是不是有冲突。</p><p><a href="https://github.com/Homepea7/ESP32_Code/tree/main/1.PinSet" target="_blank" rel="noopener">ESP32_Code/1.PinSet at main · Homepea7/ESP32_Code</a></p><p><a href="0.ESP32_Pinout.xlsx">0.ESP32_Pinout.xlsx</a></p><p><a href="1.ESP32_Touch.xlsx">1.ESP32_Touch.xlsx</a></p><p><a href="2.ESP32_Timer_PWM.xlsx">2.ESP32_Timer_PWM.xlsx</a></p><p><a href="0.ESP32_Pinout.pdf">0.ESP32_Pinout.pdf</a></p><p>在使用 ESP32的过程中需要注意 </p><ul><li>如果开机启用了Wi-Fi功能，那么需要注意其供电，启动时ESP32所需电流较大，需要保障电压，电流的稳定性。</li><li>在使用Platform进行 ESP32 nodemcu（好像是这个型号） 烧录过程中，如果无法进行一键烧录，可以尝试在烧录前/中，按下boot按键，稍等2，3s，待进度条走动时，松手即可。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期，多次使用了 ESP32 系列的模组，发现 ESP32 的一些优良特性，后期打算继续将其作为网络节点，特此介绍 ESP32 的可用性以及其特点。&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="ESP32" scheme="https://jefine.github.io/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>mmWave环境配置与硬件搭配</title>
    <link href="https://jefine.github.io/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/"/>
    <id>https://jefine.github.io/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/</id>
    <published>2021-10-23T13:50:27.000Z</published>
    <updated>2021-10-23T13:56:43.968Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 joybien 公司的b201 VSD毫米波雷达和树莓派配合中，出现的一些安装问题以及如何安装：<br>  <a id="more"></a></p><p>官方文档 Github 地址：</p><p><a href="https://github.com/bigheadG/mmWave/tree/master/VSD" target="_blank" rel="noopener">mmWave/VSD at master · bigheadG/mmWave</a></p><p>在购买后，应收到如下图所示的组件：</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled.png" alt="Untitled"></p><p>左侧是毫米波雷达收发信号采集元器件，也是核心部件；</p><p>中间是转接板，负责数据处理与转发。包括蓝牙和 Wifi 模块</p><p>右边是固定转接板的螺丝等可以将其更稳定的放置。</p><h3 id="组装硬件"><a href="#组装硬件" class="headerlink" title="组装硬件"></a>组装硬件</h3><p>将转接板插入树莓派，将其覆盖在树莓派上面（不要让他出去了）</p><p>然后将排针插进去，这个理论上不会插反，因为有防呆设计。其中收发模块对准USB供电处。</p><p>注意：</p><p>其中有一个排针并不是断在里面了，而是防呆措施，这样是我们不会插反。</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 1.png" alt="[Untitled]"></p><p>将他们拼装好了之后，我们一般选择的是串口，树莓派的模式，一般如下图（J9中的左两个是原始数据的输出，右侧两个是关键数据输出）。</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 2.png" alt="[Untitled]"></p><p>该硬件的供电通过树莓派的USB口就可以供电。</p><h2 id="配置树莓派软件环境"><a href="#配置树莓派软件环境" class="headerlink" title="配置树莓派软件环境"></a>配置树莓派软件环境</h2><p>为了使用USB转TTL 由于采用的是树莓派4B，而其支持的是树莓派2/3 ，所以我们需要进行一些设置上的更改。</p><ol><li>修改  /boot/config.txt</li></ol><p>在最下方新增以下内容：</p><pre><code class="hljs c">dtoverlay=pi3-miniuart-btcore-freq=<span class="hljs-number">250</span>enable_uart=<span class="hljs-number">1</span></code></pre><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 3.png" alt="[Untitled]"></p><ol><li><p>更改  \boot\cmdline.txt </p><p> 将 quiet splash 删掉，有的里面没有quiet，就不用删了。</p><p> <img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 4.png" alt="[Untitled]"></p><p> <img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 5.png" alt="[Untitled]"></p><p> 上图这个就不用删了。</p></li></ol><h3 id="打开树莓派-UART串口功能"><a href="#打开树莓派-UART串口功能" class="headerlink" title="打开树莓派 UART串口功能"></a>打开树莓派 UART串口功能</h3><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 6.png" alt="[Untitled]"></p><p>同时，需要到 raspi-config 去开启：</p><p>在Interface → Serial → 先no → 然后yes</p><p>否则就会出现毫米波雷达调整到Raw模式后，使得树莓派断网。</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 7.png" alt="[Untitled]"></p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 8.png" alt="[Untitled]"></p><h2 id="运行官方样例来测试能否正常运行"><a href="#运行官方样例来测试能否正常运行" class="headerlink" title="运行官方样例来测试能否正常运行"></a>运行官方样例来测试能否正常运行</h2><p>建议使用 Python3</p><pre><code class="hljs c">#安装使用此命令sudo pip3 install mmWave#升级使用下面的命令sudo pip3 install mmWave -U</code></pre><p>通过 git 或者手动下载下面的官方库</p><pre><code class="hljs c">git clone https:<span class="hljs-comment">//github.com/bigheadG/mmWave.git</span></code></pre><p><a href="https://github.com/bigheadG/mmWave" target="_blank" rel="noopener">GitHub - bigheadG/mmWave: mmWave SDK examples based on Batman Kit mmWave Sensor module</a></p><p>接着到下图的地方打开样例，后缀 KV 的是Key Value 模式</p><p>运行的时候会出现port没有定义，我们树莓派的话，就是用ttyAMA0串口即可，样例中一般都有注释。</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 9.png" alt="[Untitled]"></p><p>当然，由于缺乏 Python3 的一些包，会出现一些问题，会一一进行安装。</p><p>比如运行 pyqtgraph_vsd_ex3.py 是出现了没有相关组件。</p><p>就需要我们去安装了。</p><pre><code class="hljs c">pip3 install pyqtgraph==<span class="hljs-number">0.11</span><span class="hljs-number">.1</span></code></pre><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 10.png" alt="[Untitled]"></p><p>当然安装完成之后，还会出现pyqt5缺失的问题。</p><p>pyqt5的安装需要比较特殊：</p><p>安装过程中出现 continue？等的提示输入 y 或者 yes 即可</p><pre><code class="hljs c">sudo apt-<span class="hljs-built_in">get</span> install python3-pyqt5</code></pre><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 11.png" alt="[Untitled]"></p><p>当然，还有问题出现：</p><p>(1)———-libf77blas.so.3————————————————————-<br>  from scipy.linalg import _fblas<br>  ImportError: libf77blas.so.3: cannot open shared object file: No such file or directory</p><p>  problem solved这样解决就可以了:<br>  First of all, for libf77blas.so.3, you have to install ATLAS, something like sudo apt-get install libatlas-base-dev</p><pre><code class="hljs cs">sudo apt-<span class="hljs-keyword">get</span> install libatlas-<span class="hljs-keyword">base</span>-dev</code></pre><p>当然，还有模块没有安装完成。</p><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 12.png" alt="[Untitled]"></p><p>可能出现的问题：</p><ul><li><p>插上并启动毫米波雷达板子之后出现树莓派断网</p><p>  解决方案：跳帽没有配置好</p></li><li><p>出现 Permission Denied ‘/dev/ttyAMA0’</p></li></ul><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 13.png" alt="[Untitled]"></p><pre><code>  解决方法：赋予其权限。即可</code></pre><pre><code class="hljs c">sudo chmod <span class="hljs-number">666</span> /dev/ttyAMA0</code></pre><ul><li>port 有问题就进去 更改port就好。</li></ul><p><img src="/2021/10/23/mmWave%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%90%AD%E9%85%8D/Untitled 14.png" alt="[Untitled]"></p><ul><li>如果直接安装 pyqtgraph 可能会出现qt版本号不对的情况。重新安装 pyqtgraph 的0.11.1版本。</li></ul><p>当然，比如运行 pyqtgraph_vsd_ex3.py 时，我们要首先将key模式转换为raw模式，也就是将转换板上的跳帽，调整至左侧，并通过重启毫米波雷达来 进行有效切换（可以按毫米波雷达上的Reset键，也可以拔掉转接板电源，再通电）</p><p>参考：</p><p><a href="https://www.slideshare.net/raspberrypi-tw/mmwave-sensor-evaluation-solution-kit" target="_blank" rel="noopener">mmWave Sensor Evaluation Solution Kit 簡介</a></p><p><a href="https://github.com/bigheadG/mmWave" target="_blank" rel="noopener">GitHub - bigheadG/mmWave: mmWave SDK examples based on Batman Kit mmWave Sensor module</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍了 joybien 公司的b201 VSD毫米波雷达和树莓派配合中，出现的一些安装问题以及如何安装：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="mmwave" scheme="https://jefine.github.io/tags/mmwave/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266快速上手及常见问题</title>
    <link href="https://jefine.github.io/2021/09/12/ESP8266%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://jefine.github.io/2021/09/12/ESP8266%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-12T01:58:27.000Z</published>
    <updated>2022-01-08T13:37:59.077Z</updated>
    
    <content type="html"><![CDATA[<p>ESP8266 是乐鑫公司所打造的一款低价，高性能的WiFI通信模块。</p><p>下列常见问题及解决方案均在 Win10 环境下</p>  <a id="more"></a><h2 id="配置基本环境与文档"><a href="#配置基本环境与文档" class="headerlink" title="配置基本环境与文档"></a>配置基本环境与文档</h2><p>后续也许会补充。目前可以通过网络搜索快速获取。</p><h2 id="如何烧录8266？"><a href="#如何烧录8266？" class="headerlink" title="如何烧录8266？"></a>如何烧录8266？</h2><p>对于 NodeMCU，可以直接通过 USB 数据端口进行下载。</p><p>建议采用 arduino 环境开发（用 vscode 编辑），而不是使用 at 开发，今后使用 RTOS 之后再考虑其他事情。</p><h3 id="ESP8266-在使用过程中非常烫手？"><a href="#ESP8266-在使用过程中非常烫手？" class="headerlink" title="ESP8266 在使用过程中非常烫手？"></a>ESP8266 在使用过程中非常烫手？</h3><p>正常</p><h3 id="感觉代码没有问题，但数据传输时有时无，经常无效？"><a href="#感觉代码没有问题，但数据传输时有时无，经常无效？" class="headerlink" title="感觉代码没有问题，但数据传输时有时无，经常无效？"></a>感觉代码没有问题，但数据传输时有时无，经常无效？</h3><p><strong>晃动或换良好的杜邦线！</strong></p><h2 id="为何不显示端口号（连接后无反应）？"><a href="#为何不显示端口号（连接后无反应）？" class="headerlink" title="为何不显示端口号（连接后无反应）？"></a>为何不显示端口号（连接后无反应）？</h2><p><strong>换一根良好的数据线！</strong></p><p>大多数的数据线都是不支持的，只能用来供电</p><h2 id="如何解决使用-vscode-开发时出现的问题"><a href="#如何解决使用-vscode-开发时出现的问题" class="headerlink" title="如何解决使用 vscode 开发时出现的问题"></a>如何解决使用 vscode 开发时出现的问题</h2><h3 id="为什么出现很多红色波浪线？"><a href="#为什么出现很多红色波浪线？" class="headerlink" title="为什么出现很多红色波浪线？"></a>为什么出现很多红色波浪线？</h3><p>解决方案：</p><p>自己在配置 VS Code Arduino 开发环境中遇到的问题，类似这种，错误显示未定义标识符。关于 VS Code 配置 Arduino 开发环境<br>主要问题是头文件索引丢失，intellisense不能自动找到需要的头文件路径。需要在用户设置中强制intellisense使用Tag Parser,递归方式检索头文件。</p><p>在设置中添加如下代码：</p><pre><code class="hljs bash">“C_Cpp.intelliSenseEngineFallback”: “Disabled”,“C_Cpp.intelliSenseEngine”: “Tag Parser”,</code></pre><h3 id="为什么在编译时出现乱码？"><a href="#为什么在编译时出现乱码？" class="headerlink" title="为什么在编译时出现乱码？"></a>为什么在编译时出现乱码？</h3><p>打开文件：</p><p>C:\Users\userName.vscode\extensions\vsciot-vscode.vscode-arduino-0.4.0\out\src\common\util.js</p><p><img src="/2021/09/12/ESP8266%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Untitled.png" alt="Untitled"></p><p>参考链接：</p><p><a href="https://blog.csdn.net/q1694222672/article/details/89214807" target="_blank" rel="noopener">NodeMCUArunino 方式</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ESP8266 是乐鑫公司所打造的一款低价，高性能的WiFI通信模块。&lt;/p&gt;
&lt;p&gt;下列常见问题及解决方案均在 Win10 环境下&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="ESP8266" scheme="https://jefine.github.io/tags/ESP8266/"/>
    
  </entry>
  
  <entry>
    <title>4GES600S开发</title>
    <link href="https://jefine.github.io/2021/08/24/4GES600SEVB/"/>
    <id>https://jefine.github.io/2021/08/24/4GES600SEVB/</id>
    <published>2021-08-24T13:43:14.000Z</published>
    <updated>2021-08-24T15:00:47.964Z</updated>
    
    <content type="html"><![CDATA[<p>移远通信 ES600S开发板的Demo和一些基础的操作指南</p>  <a id="more"></a><h1 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h1><h2 id="配置环境与基本认识文档："><a href="#配置环境与基本认识文档：" class="headerlink" title="配置环境与基本认识文档："></a>配置环境与基本认识文档：</h2><p><a href="https://python.quectel.com/doc/doc/Quick_start/zh/index.html" target="_blank" rel="noopener">QuecPython</a></p><p><a href="固件下载与脚本下载图解.pdf">固件下载与脚本下载图解.pdf</a></p><h3 id="开发板使用几大步骤："><a href="#开发板使用几大步骤：" class="headerlink" title="开发板使用几大步骤："></a>开发板使用几大步骤：</h3><p>1.插上模组；</p><p>2.模组开机（具体步骤：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.1章节）；</a></p><p>3.驱动安装（注意事项：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.2章节）；</a></p><p>4.烧录QuecPython固件</p><p>注意事项见：<a href="https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节" target="_blank" rel="noopener">https://python.quectel.com/doc/doc/Quick_start/zh/Quick_start.html的4.3章节</a></p><p>具体步骤的视频连接：<a href="https://www.bilibili.com/video/BV1ci4y1w7g8/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ci4y1w7g8/</a></p><p>5.下载Demo程序（官网的下载专区<a href="https://python.quectel.com/download有个Demo的文件夹）" target="_blank" rel="noopener">https://python.quectel.com/download有个Demo的文件夹）</a></p><p>6.例程无法跑通请先自查并参考官网wiki（<a href="https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库" target="_blank" rel="noopener">https://python.quectel.com/wiki/#/），wiki里面包含demo里面涉及的所有API库</a></p><h3 id="开发板需要注意的地方："><a href="#开发板需要注意的地方：" class="headerlink" title="开发板需要注意的地方："></a>开发板需要注意的地方：</h3><p><a href="Quectel_EC600x-CN兼容性设计讲稿_-0506.pdf">Quectel_EC600x-CN(_QuecOpen)兼容性设计讲稿_-0506.pdf</a></p><p>Page24</p><p>EC600N-CN/EC600S-CN (QuecOpen)接喇叭则需增加外部PA设计（放大听<br>筒信号）</p><p>EC600N-CN/EC600S-CN QuecOpen 复用键盘引脚（PIN 48~57）也可以复用成<br>GPIO功能使用，在不用键盘情况下可使用<br>复用成GPIO口时要注意开机默认状态和电源域，具体参考Quectel_EC600x-CN<br>QuecOpen_GPIO配置表_V1.0</p><p>EC600S-CN/EC600N-CN QuecOpen 开机默认是PU，用于控灯、电机和外部电源<br>使能之类要注意模块上电时有上拉动作</p><p>天线设计</p><p><a href="Quectel_天线设计指导_V3.2.pdf">Quectel_天线设计指导_V3.2.pdf</a></p><h1 id="小实验："><a href="#小实验：" class="headerlink" title="小实验："></a>小实验：</h1><h2 id="如何将软硬件结合？"><a href="#如何将软硬件结合？" class="headerlink" title="如何将软硬件结合？"></a>如何将软硬件结合？</h2><p>另外在查询开发板上的GPIO的号码时，可以看看板子中间的引脚介绍，可以解决不少问题，查找不到的可以按照下面的方法进行查找。</p><p>即如何查找软件 GPIO 或 ADC 等接口与物理开发板接口的位置</p><p>下面以查找KEY2所对应的GPIO号为例：</p><p>首先打开 <a href="EC600X_QuecPython_EVB_V1.3_SCH.pdf">EC600X_QuecPython_EVB_V1.3_SCH.pdf</a> 文件</p><p>然后根据需要切换到第六GPIO+UART这一页也是最经常查找的</p><p><img src="/2021/08/24/4GES600SEVB/Untitled.png" alt="p"></p><p> 可以看到左下角的S4,S5即是我们所要寻找的，找到引脚号PIN60后</p><p>即可根据<a href="https://python.quectel.com/wiki/#/zh-cn/api/QuecPythonClasslib?id=pin" target="_blank" rel="noopener">API</a>查询到相关的GPIO号码，如图12 即为所求。</p><p>有部分不易寻找到内容可以采取多种类似说法，大小写，简要内容的搜索来查找。</p><p><img src="/2021/08/24/4GES600SEVB/Untitled 1.png" alt="p"></p><h2 id="简单的外设Demo"><a href="#简单的外设Demo" class="headerlink" title="简单的外设Demo"></a>简单的外设Demo</h2><p><a href="https://python.quectel.com/doc/doc/little_demo/zh/QuecPythonTest/QuecPythonLED.html" target="_blank" rel="noopener">QuecPython</a></p><h3 id="UART串口："><a href="#UART串口：" class="headerlink" title="UART串口："></a>UART串口：</h3><p><img src="/2021/08/24/4GES600SEVB/Untitled 2.png" alt="p1"></p><p><img src="/2021/08/24/4GES600SEVB/Untitled 3.png" alt="p"></p><h3 id="External-interrupt外部中断"><a href="#External-interrupt外部中断" class="headerlink" title="External_interrupt外部中断"></a>External_interrupt外部中断</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> ExtInt<span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<span class="hljs-comment"># 参考自 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=extint</span>state = <span class="hljs-number">2</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callBack</span><span class="hljs-params">(args)</span>:</span>    <span class="hljs-keyword">global</span> state    print(<span class="hljs-string">'### interrupt  &#123;&#125; ###'</span>.format(args))    <span class="hljs-comment">#传入的应该是一个List，[GPIOX,X] ,第二个参数不清楚</span>    state = state - <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 映射GPIO12的下降沿触发回调函数</span>    <span class="hljs-comment"># GPIO12即key2</span>    extint = ExtInt(ExtInt.GPIO12, ExtInt.IRQ_FALLING, ExtInt.PULL_PU, callBack)    <span class="hljs-comment"># 等待按键按下，触发</span>    <span class="hljs-keyword">while</span> state:        time.sleep_ms(<span class="hljs-number">10</span>)        <span class="hljs-keyword">pass</span>    <span class="hljs-comment"># 停止映射外部中断</span>    extint.disable()    print(<span class="hljs-string">"The main function has exited"</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><h3 id="WatchDog-看门狗"><a href="#WatchDog-看门狗" class="headerlink" title="WatchDog 看门狗"></a>WatchDog 看门狗</h3><p>看门狗的复位指的是<strong>重启机器</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 实验1：独立看门狗实验</span><span class="hljs-comment"># API资料参考连接：  https://python.quectel.com/wiki/#/zh-cn/api/?id=wdt</span><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> WDT<span class="hljs-keyword">import</span> utimewdt = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 定义全部变量</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Watchdog</span><span class="hljs-params">()</span>:</span>  <span class="hljs-comment"># 2秒钟内调用喂狗函数，否则系统复位</span>    <span class="hljs-keyword">global</span> wdt  <span class="hljs-comment"># 声明全部变量</span>    <span class="hljs-keyword">if</span> wdt <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        wdt = WDT(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 启动看门狗，间隔时长 单位 秒</span>    wdt.feed()  <span class="hljs-comment"># 喂狗</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_1</span><span class="hljs-params">()</span>:</span>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span>    print(<span class="hljs-string">'功能函数 1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_2</span><span class="hljs-params">()</span>:</span>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span>    print(<span class="hljs-string">'功能函数 2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_3</span><span class="hljs-params">()</span>:</span>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span>    print(<span class="hljs-string">'功能函数 3'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    utime.sleep_ms(<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 延时1秒</span>    print(<span class="hljs-string">'功能函数 3_2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_4</span><span class="hljs-params">()</span>:</span>    utime.sleep_ms(<span class="hljs-number">1000</span>)    print(<span class="hljs-string">'功能函数 4'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    print(<span class="hljs-string">'尝试在5s后喂狗'</span>)    utime.sleep_ms(<span class="hljs-number">5000</span>)  <span class="hljs-comment"># 延时5秒</span>    Watchdog()    print(<span class="hljs-string">'来不及喂狗，系统已经复位'</span>)<span class="hljs-comment">#此行代码不会显示因为机器已经重启了</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'喂狗'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    func_1()  <span class="hljs-comment"># 用户程序</span>    print(<span class="hljs-string">'喂狗'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    func_2()  <span class="hljs-comment"># 用户程序</span>    print(<span class="hljs-string">'喂狗'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    func_3()  <span class="hljs-comment"># 用户程序</span>    print(<span class="hljs-string">'喂狗'</span>)    Watchdog()  <span class="hljs-comment"># 2秒钟内调用喂狗函数</span>    func_4()  <span class="hljs-comment"># 用户程序</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><h3 id="温湿度检测"><a href="#温湿度检测" class="headerlink" title="温湿度检测"></a>温湿度检测</h3><p>测得不准，勉强能看</p><pre><code class="hljs python"><span class="hljs-string">'''File: i2c_aht10.pyProject: i2cFile Created: Monday, 28th December 2020 5:17:28 pmAuthor: chengzhu.zhou-----Last Modified: Tuesday, 29th December 2020 9:01:35 pmModified By: chengzhu.zhou-----Copyright 2020 - 2020 quectel'''</span><span class="hljs-keyword">import</span> log<span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> I2C<span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<span class="hljs-string">"""1. calibration2. Trigger measurement3. read data"""</span><span class="hljs-comment"># API  手册 http://qpy.quectel.com/wiki/#/zh-cn/api/?id=i2c</span><span class="hljs-comment"># AHT10 说明书</span><span class="hljs-comment">#  https://server4.eca.ir/eshop/AHT10/Aosong_AHT10_en_draft_0c.pdf</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aht10class</span><span class="hljs-params">()</span>:</span>    i2c_log = <span class="hljs-literal">None</span>    i2c_dev = <span class="hljs-literal">None</span>    i2c_addre = <span class="hljs-literal">None</span>    <span class="hljs-comment"># Initialization command</span>    AHT10_CALIBRATION_CMD = <span class="hljs-number">0xE1</span>    <span class="hljs-comment"># Trigger measurement</span>    AHT10_START_MEASURMENT_CMD = <span class="hljs-number">0xAC</span>    <span class="hljs-comment"># reset</span>    AHT10_RESET_CMD = <span class="hljs-number">0xBA</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_data</span><span class="hljs-params">(self, data)</span>:</span>        self.i2c_dev.write(self.i2c_addre,                           bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,                           bytearray(data), len(data))        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data</span><span class="hljs-params">(self, length)</span>:</span>        r_data = [<span class="hljs-number">0x00</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length)]        r_data = bytearray(r_data)        self.i2c_dev.read(self.i2c_addre,                          bytearray(<span class="hljs-number">0x00</span>), <span class="hljs-number">0</span>,                          r_data, length,                          <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> list(r_data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_init</span><span class="hljs-params">(self, addre=<span class="hljs-number">0x38</span>, Alise=<span class="hljs-string">"Ath10"</span>)</span>:</span>        self.i2c_log = log.getLogger(Alise)        self.i2c_dev = I2C(I2C.I2C1, I2C.STANDARD_MODE)  <span class="hljs-comment"># 返回i2c对象</span>        self.i2c_addre = addre        self.sensor_init()        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aht10_transformation_temperature</span><span class="hljs-params">(self, data)</span>:</span>        r_data = data        <span class="hljs-comment">#　根据数据手册的描述来转化温度</span>        humidity = (r_data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">12</span>) | (            r_data[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">4</span>) | ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>)        humidity = (humidity/(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) * <span class="hljs-number">100.0</span>        print(<span class="hljs-string">"current humidity is &#123;0&#125;%"</span>.format(humidity))        temperature = ((r_data[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0xf</span>) &lt;&lt; <span class="hljs-number">16</span>) | (            r_data[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | r_data[<span class="hljs-number">4</span>]        temperature = (temperature * <span class="hljs-number">200.0</span> / (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>)) - <span class="hljs-number">50</span>        print(<span class="hljs-string">"current temperature is &#123;0&#125;°C"</span>.format(temperature))            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sensor_init</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment"># calibration</span>        self.write_data([self.AHT10_CALIBRATION_CMD, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>])        time.sleep_ms(<span class="hljs-number">300</span>)  <span class="hljs-comment"># at last 300ms</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ath10_reset</span><span class="hljs-params">(self)</span>:</span>        self.write_data([self.AHT10_RESET_CMD])        time.sleep_ms(<span class="hljs-number">20</span>)  <span class="hljs-comment"># at last 20ms</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Trigger_measurement</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment"># Trigger data conversion</span>        self.write_data([self.AHT10_START_MEASURMENT_CMD, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>])        time.sleep_ms(<span class="hljs-number">200</span>)  <span class="hljs-comment"># at last delay 75ms</span>        <span class="hljs-comment"># check has success</span>        r_data = self.read_data(<span class="hljs-number">6</span>)        <span class="hljs-comment"># check bit7</span>        <span class="hljs-keyword">if</span> (r_data[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">7</span>) != <span class="hljs-number">0x0</span>:            print(<span class="hljs-string">"Conversion has error"</span>)        <span class="hljs-keyword">else</span>:            self.aht10_transformation_temperature(r_data[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">i2c_aht10_test</span><span class="hljs-params">()</span>:</span>    ath_dev = aht10class()    ath_dev.aht10_init()    <span class="hljs-comment"># 测试十次</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):        ath_dev.Trigger_measurement()        time.sleep(<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    i2c_aht10_test()</code></pre><h3 id="Photoresistor-光敏电阻"><a href="#Photoresistor-光敏电阻" class="headerlink" title="Photoresistor 光敏电阻"></a>Photoresistor 光敏电阻</h3><p>得到的数值为ADC电压值</p><p><img src="/2021/08/24/4GES600SEVB/Untitled 4.png" alt="p"></p><pre><code class="hljs python"><span class="hljs-string">'''File: Photoresistor.pyProject: adcFile Created: Thursday, 24th December 2020 5:44:08 pmAuthor: chengzhu.zhou-----Last Modified: Wednesday, 30th December 2020 10:10:33 amModified By: chengzhu.zhou-----Copyright 2020 - 2020 quectel'''</span><span class="hljs-keyword">from</span> misc <span class="hljs-keyword">import</span> ADC<span class="hljs-keyword">import</span> utime <span class="hljs-keyword">as</span> time<span class="hljs-keyword">import</span> _thread<span class="hljs-comment"># unit as Ω</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Voltage_to_Resistance</span><span class="hljs-params">(Volt)</span>:</span>    <span class="hljs-comment">#</span>    Va = <span class="hljs-number">2</span> * Volt    resistance = (<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * <span class="hljs-number">40200</span> * Va)/(<span class="hljs-number">2</span> * <span class="hljs-number">4700</span> * (<span class="hljs-number">3300</span> - Va) - (<span class="hljs-number">40200</span> * Va))    <span class="hljs-keyword">return</span> resistance<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Photoresistor_thread</span><span class="hljs-params">(delay, retryCount)</span>:</span>    <span class="hljs-comment"># creat a adc device</span>    AdcDevice = ADC()    <span class="hljs-keyword">while</span> retryCount:        retryCount = retryCount - <span class="hljs-number">1</span>        <span class="hljs-comment"># get ADC.ADC0 value</span>        adcvalue = AdcDevice.read(ADC.ADC0)        print(<span class="hljs-string">"get ADC.ADC0 Voltage value as &#123;0&#125;mv"</span>.format(adcvalue))        <span class="hljs-comment"># Converted to resistance</span>        resistance = Voltage_to_Resistance(adcvalue)        print(<span class="hljs-string">"Photoresistor  resistance as  &#123;0&#125;Ω"</span>.format(resistance))        time.sleep(delay)    <span class="hljs-keyword">pass</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    <span class="hljs-comment"># creat a thread Convert ADC to Voltage</span>    _thread.start_new_thread(Photoresistor_thread, (<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))    print(<span class="hljs-string">"creent main thread has exit"</span>)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;移远通信 ES600S开发板的Demo和一些基础的操作指南&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="ES600S" scheme="https://jefine.github.io/tags/ES600S/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙模块HC05的双设备简单配对通信</title>
    <link href="https://jefine.github.io/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/"/>
    <id>https://jefine.github.io/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-09T08:01:45.000Z</published>
    <updated>2021-10-16T07:17:33.172Z</updated>
    
    <content type="html"><![CDATA[<p>HC05采用的是AT指令进行配置， 采用串口通信进行数据传输。</p><p><a href="https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf" target="_blank" rel="noopener">指令集文档</a>可以任意在互联网中查找到。</p>  <a id="more"></a><h2 id="如何完成手机蓝牙和模块通信"><a href="#如何完成手机蓝牙和模块通信" class="headerlink" title="如何完成手机蓝牙和模块通信"></a>如何完成手机蓝牙和模块通信</h2><p>电源是5V，同时采用CL/LF</p><p>连接之后，先通过</p><p>AT+ROLE=0</p><p>将其设置为从模式（slave），即可匹配(1234)</p><p><strong>注意</strong>：</p><ol><li>HC05，VCC接入3.3V可能没有反应，应连到5V</li><li>模块和电源相连时刻，有两种方法进入AT指令状态：<ol><li>提前一直按下HC-05上的按键，直到其灯闪烁为缓慢亮起，即可松开</li><li>将EN引脚置高（3.3V即可），但需要注意EN为高电平是HC05不能正常工作，只有将EN调为低电平，HC05恢复</li></ol></li><li>波特率需要一致，建议统一38400</li><li>模块所有AT指令需要加上换行符号否则无效（即选择CR/LF），且尽量大写</li></ol><p><a href="https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html" target="_blank" rel="noopener">https://combofish.github.io/2020/02/08/how-to-use-hc-05-bluetooth-module.html</a></p><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SoftwareSerial</span>.</span></span>h&gt;<span class="hljs-comment">// Pin3为RX，接HC05的TXD</span><span class="hljs-comment">// Pin2为TX，接HC05的RXD</span>SoftwareSerial <span class="hljs-constructor">BT(10, 11)</span>;<span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span>;<span class="hljs-built_in">int</span> ledPin=<span class="hljs-number">13</span>;void setup<span class="hljs-literal">()</span> &#123;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>println(<span class="hljs-string">"BT is ready!"</span>);  <span class="hljs-comment">// HC-05默认，38400</span>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span><span class="hljs-keyword">begin</span>(<span class="hljs-number">38400</span>);  pin<span class="hljs-constructor">Mode(<span class="hljs-params">ledPin</span>, OUTPUT)</span>;  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;  delay(<span class="hljs-number">500</span>);  digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;&#125;void loop<span class="hljs-literal">()</span> &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>read<span class="hljs-literal">()</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>print(<span class="hljs-keyword">val</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>available<span class="hljs-literal">()</span>) &#123;    <span class="hljs-keyword">val</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BT</span>.</span></span>read<span class="hljs-literal">()</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>print(<span class="hljs-keyword">val</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'1'</span>)      &#123;    <span class="hljs-comment">// 返回到手机调试程序上</span>    <span class="hljs-comment">// 此时的蓝牙状态应该正常模式，而不是调试模式</span>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--high\n"</span>);    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, HIGH)</span>;      &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-character">'2'</span>)      &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Serial</span>.</span></span>write(<span class="hljs-string">"Serial--ledPin--low\n"</span>);    digital<span class="hljs-constructor">Write(<span class="hljs-params">ledPin</span>, LOW)</span>;      &#125;  &#125;&#125;</code></pre><h3 id="双蓝牙模块连接（主从模式）"><a href="#双蓝牙模块连接（主从模式）" class="headerlink" title="双蓝牙模块连接（主从模式）"></a>双蓝牙模块连接（主从模式）</h3><p>一个通过连接PC由串口通信（模拟一个设备的指令操作）</p><p>另一个采用Arduino进行点灯来作为从设备的响应动作</p><p>首先需要将其配置</p><p>这里首先采用较为安全的固定地址相连接：</p><ol><li><p>将主设备调试（测试能否正常工作）</p><p>AT</p><p>如果不能，可能是串口波特率问题</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled.png" alt="Untitled"></p><ol><li><p>调整设备通信波特率</p><p>查看波特率：</p><p>AT+UART?</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 1.png" alt="Untitled 1"></p><pre><code class="hljs angelscript">发现波特率不一致为<span class="hljs-number">9600</span>时进行更改，默认状态下就是两个波特率，正常模式下就是<span class="hljs-number">9600</span>，这里我们将其更改为<span class="hljs-number">38400</span>方便调试，当然也可能会带来一定的问题。</code></pre><p>更改波特率：</p><p>AT+UART=38400,0,0</p><ol><li><p>调整主从设备模式</p><p>AT+ROLE=1</p></li><li><p>调整连接模式：</p><p>AT+CMODE=0</p></li><li><p>绑定从机：</p><p>在获取到从机的address之后（查询从机地址指令AT+ADDR?），我们进行绑定：</p></li></ol><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 2.png" alt="Untitled 2"></p><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 3.png" alt="Untitled 3"></p><p><strong>注意</strong>：此处将冒号，替换成了逗号（英文状态下的逗号）</p><p>最后，（<del>莫名</del>）成功了，刚开始连接上后，无法正常通信，重启了就好了。</p><p><img src="/2021/08/09/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC05%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8/Untitled 5.png" alt="Untitled 5"></p><p>从机代码较为简单：</p><p>在对芯片作简要的波特率修正和查询addr之后采用Arduino 编程即可,代码同上不用修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本次的实验中，我们通过PC端连接一个蓝牙模块作为主设备（master）来通过串口发送数据，通过另一个 HC-05 传递数据，进而使得另一边的Arduino设备实现点灯功能。</p><p>主要涉及了串口收发以及对多串口应用的理解，在Arduino和PC通信（下载线）的同时又通过另一个串口和HC05通信，两串口间的数据传递以及在PC屏幕上的数据呈现，要求了我们对于不同串口的特点的理解：即该串口Print将会到何处，该串口Receive将会收到谁的，我们如何呈现到PC（即将PC和设备相连的串口进行发送或者说转发），从而进一步熟悉了数据的流动特点。 </p><p>串口的首发，乃至于说数据包的收发，可以参考另一个<a href="https://github.com/jefine/51MCU_course_design" target="_blank" rel="noopener">WiFi项目的串口收发</a>，也可看出串口通信在实际的物联网通信应用中十分广泛。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HC05采用的是AT指令进行配置， 采用串口通信进行数据传输。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;指令集文档&lt;/a&gt;可以任意在互联网中查找到。&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
    <category term="HC05" scheme="https://jefine.github.io/tags/HC05/"/>
    
  </entry>
  
  <entry>
    <title>L298N驱动电机</title>
    <link href="https://jefine.github.io/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/"/>
    <id>https://jefine.github.io/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/</id>
    <published>2021-07-08T02:59:07.000Z</published>
    <updated>2021-08-09T08:34:56.257Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍了L298N的接线方式，驱动原理及相关简要代码</p>  <a id="more"></a><h2 id="引脚介绍"><a href="#引脚介绍" class="headerlink" title="引脚介绍"></a>引脚介绍</h2><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298N.png" alt="L298N"></p><h2 id="需要注意事项："><a href="#需要注意事项：" class="headerlink" title="需要注意事项："></a>需要注意事项：</h2><p>L298N的+12V需要电压在 +7VDC to +35VDC.如果使用的电源超过了12V那么请将跳帽拔掉。</p><p>同时需要 mcu 和 L298N 供地。</p><p>H桥中，四个input对应四个output(Terminal)</p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/1.png" alt="1"></p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/2.png" alt="2"></p><p>通过对于IN的控制就可以控制out，促使其连接到的电机正转或着反转（并可以控制速度，PWM？）</p><h2 id="具体操作逻辑："><a href="#具体操作逻辑：" class="headerlink" title="具体操作逻辑："></a>具体操作逻辑：</h2><h3 id="对于普通的马达电机："><a href="#对于普通的马达电机：" class="headerlink" title="对于普通的马达电机："></a>对于普通的马达电机：</h3><p>那么只需要将其正负连接至out1，out2，通过in1，in2来控制正负就可以驱动了。</p><p>对于Arduino 来说更为简单。</p><p>其中ena非必需（采用跳帽，也可达到效果）</p><pre><code class="hljs c"><span class="hljs-comment">//Motor Connections</span><span class="hljs-comment">//Change this if you wish to use another diagram</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnA 10</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EnB 5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In1 9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In2 8</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In3 7</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> In4 6</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// All motor control pins are outputs</span>  <span class="hljs-built_in">pinMode</span>(EnA, <span class="hljs-literal">OUTPUT</span>);  <span class="hljs-built_in">pinMode</span>(EnB, <span class="hljs-literal">OUTPUT</span>);  <span class="hljs-built_in">pinMode</span>(In1, <span class="hljs-literal">OUTPUT</span>);  <span class="hljs-built_in">pinMode</span>(In2, <span class="hljs-literal">OUTPUT</span>);  <span class="hljs-built_in">pinMode</span>(In3, <span class="hljs-literal">OUTPUT</span>);  <span class="hljs-built_in">pinMode</span>(In4, <span class="hljs-literal">OUTPUT</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goStraight</span><span class="hljs-params">()</span>   <span class="hljs-comment">//run both motors in the same direction</span></span>&#123;  <span class="hljs-comment">// turn on motor A</span>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">HIGH</span>);  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);  <span class="hljs-comment">// set speed to 150 out 255</span>  <span class="hljs-built_in">analogWrite</span>(EnA, <span class="hljs-number">200</span>);  <span class="hljs-comment">// turn on motor B</span>  <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">HIGH</span>);  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);  <span class="hljs-comment">// set speed to 150 out 255</span>  <span class="hljs-built_in">analogWrite</span>(EnB, <span class="hljs-number">200</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// now turn off motors</span>  <span class="hljs-built_in">digitalWrite</span>(In1, <span class="hljs-literal">LOW</span>);  <span class="hljs-built_in">digitalWrite</span>(In2, <span class="hljs-literal">LOW</span>);    <span class="hljs-built_in">digitalWrite</span>(In3, <span class="hljs-literal">LOW</span>);  <span class="hljs-built_in">digitalWrite</span>(In4, <span class="hljs-literal">LOW</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>&#123;  goStraight();  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);&#125;</code></pre><h3 id="驱动Step-moto-28BYJ-48"><a href="#驱动Step-moto-28BYJ-48" class="headerlink" title="驱动Step moto 28BYJ-48"></a>驱动Step moto 28BYJ-48</h3><p>该继步马达一共拥有五根线，则如果需要采用L298N来驱动，一个L298N那么只能驱动一个继步电机。</p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n1.png" alt="1"></p><p><img src="/2021/07/08/L298N%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA/L298n2.png" alt="2"></p><pre><code class="hljs c"><span class="hljs-comment">/* Example sketch to control a stepper motor with L298N motor driver, Arduino UNO and Stepper.h library. More info: &lt;https://www.makerguides.com&gt; */</span><span class="hljs-comment">// Include the Stepper library:</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Stepper.h&gt;</span></span><span class="hljs-comment">// Define number of steps per revolution:</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> stepsPerRevolution = <span class="hljs-number">200</span>;<span class="hljs-comment">// Initialize the stepper library on pins 8 through 11:</span><span class="hljs-built_in">Stepper</span> myStepper = <span class="hljs-built_in">Stepper</span>(stepsPerRevolution, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>);<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Set the motor speed (RPMs):</span>  myStepper.<span class="hljs-built_in">setSpeed</span>(<span class="hljs-number">100</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Step one revolution in one direction:</span>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">500</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// Step on revolution in the other direction:</span>  myStepper.<span class="hljs-built_in">step</span>(<span class="hljs-number">-500</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">2000</span>);&#125;</code></pre><p>参考连接：</p><p><a href="https://www.makerguides.com/l298n-stepper-motor-arduino-tutorial/" target="_blank" rel="noopener">Stepper Motor with L298N and Arduino Tutorial (4 Examples)</a></p><p><a href="https://www.teachmemicro.com/use-l298n-motor-driver/" target="_blank" rel="noopener">How to Use L298N Motor Driver | Microcontroller Tutorials</a></p><p><a href="https://rjdlee.com/arduino-wemos-with-l298n-controller-and-28byj-48-stepper-motor/" target="_blank" rel="noopener">Arduino WeMos with L298N Controller and 28BYJ-48 Stepper Motor</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简要介绍了L298N的接线方式，驱动原理及相关简要代码&lt;/p&gt;</summary>
    
    
    
    <category term="IOT" scheme="https://jefine.github.io/categories/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>new_EE</title>
    <link href="https://jefine.github.io/2021/06/03/new-EE/"/>
    <id>https://jefine.github.io/2021/06/03/new-EE/</id>
    <published>2021-06-03T12:34:00.000Z</published>
    <updated>2021-06-03T12:40:28.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新坑IOT方向"><a href="#新坑IOT方向" class="headerlink" title="新坑IOT方向"></a>新坑IOT方向</h2><p>陆陆续续的进行了一些相关方向的内容，今后会多分享一些项目的总结和技术分享。</p><p>加油！</p><p>!&lt;—more—&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新坑IOT方向&quot;&gt;&lt;a href=&quot;#新坑IOT方向&quot; class=&quot;headerlink&quot; title=&quot;新坑IOT方向&quot;&gt;&lt;/a&gt;新坑IOT方向&lt;/h2&gt;&lt;p&gt;陆陆续续的进行了一些相关方向的内容，今后会多分享一些项目的总结和技术分享。&lt;/p&gt;
&lt;p&gt;加油！&lt;/</summary>
      
    
    
    
    <category term="EE" scheme="https://jefine.github.io/categories/EE/"/>
    
    
  </entry>
  
  <entry>
    <title>2021</title>
    <link href="https://jefine.github.io/2021/01/01/2021/"/>
    <id>https://jefine.github.io/2021/01/01/2021/</id>
    <published>2021-01-01T12:45:37.000Z</published>
    <updated>2021-01-24T11:26:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                    <strong>[[2020]]</strong>—-&gt;<strong>[[2021]]</strong></p><p><strong>活着</strong></p><p><img src="/2021/01/01/2021/2021.jpg" alt="2021-2020"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​                                                                    &lt;strong&gt;[[2020]]&lt;/strong&gt;—-&amp;gt;&lt;strong&gt;[[2021]]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="record" scheme="https://jefine.github.io/categories/record/"/>
    
    
    <category term="newyear" scheme="https://jefine.github.io/tags/newyear/"/>
    
  </entry>
  
  <entry>
    <title>atabc173c C - H and V</title>
    <link href="https://jefine.github.io/2020/07/23/atabc173c/"/>
    <id>https://jefine.github.io/2020/07/23/atabc173c/</id>
    <published>2020-07-23T13:21:46.000Z</published>
    <updated>2020-08-10T04:07:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>此题目主要包括了全排列，二进制的相关知识</p>  <a id="more"></a><p><a href="https://atcoder.jp/contests/abc173/tasks/abc173_c" target="_blank" rel="noopener">C - H and V</a>(单击题目可进入下图链接)</p><p><img src="/2020/07/23/atabc173c/Screenshot_2020-07-23 C - H and V.png" alt="2020-07-23 C - H and V"></p><p>题意：第一次看的时候，看的有点呆。</p><p>给定一个矩阵，每个点都被标记为白色或者黑色，然后使你开始刷漆（红漆），一次可以涂一行或者一列，任意涂刷n次（可以是0）求有多少种方案可以使得最终黑色的砖块的数量为所给的数量。</p><p>当时思考：</p><p>opps，不会吧，难道是要暴力？这个怎么暴力？这不可能暴力吧，这么复杂呢。第一行可刷可不刷，第一列可刷可不刷。那么岂不是有很多的情况么，怎么处理呢。当场傻掉。</p><p>题解：</p><p>暴力~~~（逃不过）</p><p>但是采用了和二进制映射map的操作，也就是说 对于每一行我们有两个状态，涂刷或者不涂刷，那么一共有 h 行，w列。行的变化之间是互不关联的，所以说一共有 $2^h$ 种可能，同理 列也有 $2^w$ 种可能的情况，他们都是独立的，所以该涂刷方案一共有 $2^h * 2^w = 2^{(h+w)}$ 种可能的涂刷方案2333.</p><p>注意到数据的范围： 1≤H,W≤6 所以 如果采暴力的方法我们也不过是 $2^{12} = 4096$ 次操作，并不会从boom，是一个相对计算机而言很小的一个数据大小。</p><p>那么如何去储存一个 4096（最大） 种情况呢（其中每一种情况要表示：一共要涂刷的行或者列），我们采用了二进制状态映射的方法（<a href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/">回想之前全排列的二进制方法</a>） 同样这次我们对于 矩阵的行 而言，一共有h行，那么一共有 $2^h$ 种行的不同状态（即不同的涂刷方式）我们就采取二进制的方法记录，这种对于单个单位（如 此处的行）只有两种状态的数据的存储。例如：0b001 可以表示第一行第二行不刷红色，第三行刷红。</p><p>我们采用 0 表示不涂刷，或者表示涂刷都是可以的，无伤大雅（毕竟有一个不刷的状态就会有刷的情况与之对应，我们将全部情况都列出来了 了 了）。所以 十进制下的 $0-(h-1)$ 就可以将  $2^h$ 种状态全部表示出来了。</p><p>如果我们采用的是其他（比如，采用了 用一个矩阵来保存一种可能性的结果的话，那么就需要4000多个矩阵来表示，但想想一个矩阵我们采用一个二维数组emm 过于复杂咯，更何况每个矩阵依旧是需要依次遍历循环 判断黑色个数）</p><p>同理，我们也可以将列的表示如上方式，这样我们就实现了：<strong>采用一个十进制的数字（其实需要的是它所对应的二进制），来表示一行或者一列的涂刷情况了</strong>。</p><p>接着，我们就要判断出该行列状态下的黑砖的数量是不是和题目要求的一致，一致就cnt++。</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> H, W, K;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;H, &amp;W, &amp;K);<span class="hljs-keyword">char</span> c[H][W];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H; ++i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; W; ++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c[i][j]);&#125;<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; H); ++i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; W); ++j) &#123;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// above is the every situation that we may face</span><span class="hljs-comment">// for each block c[k][l]</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; H; ++k) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; W; ++l) &#123;<span class="hljs-comment">//i , j = 0b0101 </span><span class="hljs-keyword">if</span> (!(i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) &amp;&amp; !(j &amp; (<span class="hljs-number">1</span> &lt;&lt; l)) &amp;&amp; c[k][l] == <span class="hljs-string">'#'</span>) ++cnt;<span class="hljs-comment">//1 red, 0 not red</span><span class="hljs-comment">//if ((i &amp; (1 &lt;&lt; k)) &amp;&amp; (j &amp; (1 &lt;&lt; l)) &amp;&amp; c[k][l] == '#') ++cnt;//0 red, 1 not red</span>&#125;&#125;<span class="hljs-keyword">if</span> (cnt == K) ++ans;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;此题目主要包括了全排列，二进制的相关知识&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="atcoder 二进制" scheme="https://jefine.github.io/tags/atcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hdu1240Asteroids</title>
    <link href="https://jefine.github.io/2020/07/18/hdu1240Asteroids/"/>
    <id>https://jefine.github.io/2020/07/18/hdu1240Asteroids/</id>
    <published>2020-07-18T08:30:07.000Z</published>
    <updated>2021-01-24T11:23:32.366Z</updated>
    
    <content type="html"><![CDATA[<p>Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。</p>  <a id="more"></a><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 7201  Accepted Submission(s): 4454<br>**</strong></p><p>Problem Description</p><p>You’re in space.<br>You want to get home.<br>There are asteroids.<br>You don’t want to hit them.</p><p>Input</p><p>Input to this problem will consist of a (non-empty) series of up to 100 data  sets. Each data set will be formatted according to the following  description, and there will be no blank lines separating data sets.</p><p>A single data set has 5 components:</p><p>Start line - A single line, “START N”, where 1 &lt;= N &lt;= 10.</p><p>Slice list - A series of N slices. Each slice is an N x N matrix representing a horizontal slice through the asteroid field. Each position in the  matrix will be one of two values:</p><p>‘O’ - (the letter “oh”) Empty space</p><p>‘X’ - (upper-case) Asteroid present</p><p>Starting Position - A single line, “A B C”, denoting the <A,B,C>  coordinates of your craft’s starting position. The coordinate values  will be integers separated by individual spaces.</A,B,C></p><p>Target Position - A single line, “D E F”, denoting the <D,E,F> coordinates of your  target’s position. The coordinate values will be integers separated by  individual spaces.</D,E,F></p><p>End line - A single line, “END”</p><p>The  origin of the coordinate system is <0,0,0>. Therefore, each  component of each coordinate vector will be an integer between 0 and  N-1, inclusive.</0,0,0></p><p>The first coordinate in a set indicates the column. Left column = 0.</p><p>The second coordinate in a set indicates the row. Top row = 0.</p><p>The third coordinate in a set indicates the slice. First slice = 0.</p><p>Both the Starting Position and the Target Position will be in empty space.</p><p>Output</p><p>For each data set, there will be exactly one output set, and there will be no blank lines separating output sets.</p><p>A single output set consists of a single line. If a route exists, the  line will be in the format “X Y”, where X is the same as N from the  corresponding input data set and Y is the least number of moves  necessary to get your ship from the starting position to the target  position. If there is no route from the starting position to the target  position, the line will be “NO ROUTE” instead.</p><p>A move can only be in one of the six basic directions: up, down, left, right, forward,  back. Phrased more precisely, a move will either increment or decrement a single component of your current position vector by 1.</p><p>Sample Input</p><pre><code class="hljs angelscript">START <span class="hljs-number">1</span>O<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>ENDSTART <span class="hljs-number">3</span>XXXXXXXXXOOOOOOOOOXXXXXXXXX<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>ENDSTART <span class="hljs-number">5</span>OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXXXXXXXXXXXXXXXXXXXXXXXXXOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>END</code></pre><p>Sample Output</p><pre><code class="hljs yaml"><span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-literal">NO</span> <span class="hljs-string">ROUTE</span></code></pre><p>Source</p><p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=South+Central+USA+2001&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> South Central USA 2001 </a> </p><p>poj2225 亦为此题</p><h2 id="题意及要求"><a href="#题意及要求" class="headerlink" title="题意及要求"></a>题意及要求</h2><p>先来说说真实的题意吧：</p><p>题目给出一个三维的图，使得从一个三维的点，从起点到终点最短距离以及能否走到。多次输出题目。</p><p>看似是一道很简单的[[bfs]]题目，其实他就是一道很简单的bfs题目。</p><p>不信你看，本题目其中的bfs的内容就是这样正常。</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> ((!q.empty()))    &#123;        node front = q.front();        q.pop();        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">return</span>;        &#125;        front.cnt++;        node next = front;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;            next.x = front.x + move[i][<span class="hljs-number">0</span>];            next.y = front.y + move[i][<span class="hljs-number">1</span>];            next.z = front.z + move[i][<span class="hljs-number">2</span>];          <span class="hljs-comment">//  cout&lt;&lt;"x,y,z is  "&lt;&lt;next.x&lt;&lt;" "&lt;&lt;next.y&lt;&lt;" "&lt;&lt;next.z&lt;&lt;"  val is "&lt;&lt;val[next.x][next.y][next.z]&lt;&lt;" CHECK is "&lt;&lt;CHECK(next.x,next.y,next.z)&lt;&lt;endl;</span>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;                q.push(next);            &#125;        &#125;    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</code></pre><p><strong>但是</strong></p><p>问题来了，这道题还是对我造成了很大的困扰的，因为在数据的输入和存储这一块吃了大亏。</p><p>第一次看完题目，感觉像是给出是一个坐标点，然后所给的数据分成了多层，层与层是可以互通的，就想着把他当作二维的来做。写的时候还感到奇怪，为什么有六种动作呢，不就是只有四种（前后左右）么？还沾沾自喜，感觉自己找到了捷径。。。。。。</p><p>后来吧，总是wa，看了别人的讨论才发现原来题看错了，理解错误（英语还需增强啊，<del>太尬了</del>~~~）</p><p>这个时候的心情再回首回去当时，就感觉当时的自己仿佛是低维空间的生物在理解着三维世界的神奇（并且是失败的那种），科幻的感觉啊啊。</p><p>接着在写正确的三维的版本的时候，仍是接连不断的错误喷涌而来，通过长久的层层的debug（数小时）发现是在输入和储存方面出现了错误，题目给定的是一个接着一个二维图数据，所以需要自己去转化，但是，当时自己只想到了第一层，把高度使用行号/n来判断，他的高度，但是忘记给行号更改了，导致自己出现了错误，许多点没有标记上。（属于坐标错误吧，矩阵储存失败。。。）</p><p>导致了本应很顺利的题目，搞了很久，另外，题目给定的顺序是 列 行，而不是行列，所有还需要自己翻一下。</p><pre><code class="hljs cpp"><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(x,y,z) (x&gt;=0&amp;&amp;x<span class="hljs-meta-string">&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;z&gt;=0&amp;&amp;z&lt;n&amp;&amp;!(vis[x][y][z])&amp;&amp;val[x][y][z])</span></span><span class="hljs-comment">//val bug</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> x,y,z,cnt;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> move[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;    <span class="hljs-keyword">bool</span> vis[n][n][n];      <span class="hljs-keyword">bool</span> val[n][n][n];    CLR(vis,<span class="hljs-literal">false</span>);    CLR(val,<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> A,B,C,D,E,F;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n*n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'O'</span>)val[i%n][j][i/n]=<span class="hljs-number">1</span>;        &#125;        getchar();    &#125;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d %d %d %d\n"</span>, &amp;B,&amp;A,&amp;C,&amp;E,&amp;D,&amp;F);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"END\n"</span>);    <span class="hljs-built_in">queue</span>&lt;node&gt; q;    node t;    t.x = A;t.y= B;t.z =C;t.cnt=<span class="hljs-number">0</span>;    q.push(t);    vis[A][B][C]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> ((!q.empty()))    &#123;        node front = q.front();        q.pop();        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">return</span>;        &#125;        front.cnt++;        node next = front;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;            next.x = front.x + move[i][<span class="hljs-number">0</span>];            next.y = front.y + move[i][<span class="hljs-number">1</span>];            next.z = front.z + move[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;                q.push(next);            &#125;        &#125;    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"START %d\n"</span>,&amp;n))&#123;        bfs(n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>poj3414Pots</title>
    <link href="https://jefine.github.io/2020/07/16/poj3414Pots/"/>
    <id>https://jefine.github.io/2020/07/16/poj3414Pots/</id>
    <published>2020-07-16T11:25:05.000Z</published>
    <updated>2021-01-24T11:23:42.629Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。</p><p>此题目：细心，冷静，多思考。</p><p>当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。</p>  <a id="more"></a><hr><h4 id="Pots"><a href="#Pots" class="headerlink" title="Pots"></a>Pots</h4><div class="table-container"><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th><th></th><th></th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 31113</td><td></td><td><strong>Accepted:</strong> 12915</td><td></td><td>Special Judge</td></tr></tbody></table></div><p>Description</p><p>You are given two pots, having the volume of <strong>A</strong> and <strong>B</strong> liters respectively. The following operations can be performed:</p><ol><li>FILL(i)    fill the pot <strong>i</strong> (1 ≤ <strong>i</strong> ≤ 2) from the tap;</li><li>DROP(i)   empty the pot <strong>i</strong> to the drain;</li><li>POUR(i,j)  pour from pot <strong>i</strong> to pot <strong>j</strong>; after this operation either the pot <strong>j</strong> is full (and there may be some water left in the pot <strong>i</strong>), or the pot <strong>i</strong> is empty (and all its contents have been moved to the pot <strong>j</strong>).</li></ol><p>Write a program to find the shortest possible sequence of these operations that will yield exactly <strong>C</strong> liters of water in one of the pots.</p><p>Input</p><p>On the first and only line are the numbers <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).</p><p>Output</p><p>The first line of the output must contain the length of the sequence of operations <strong>K</strong>. The following <strong>K</strong> lines must each describe one operation. If there are several sequences  of minimal length, output any one of them. If the desired result can’t  be achieved, the first and only line of the file must contain the word ‘<strong>impossible</strong>’.</p><p>Sample Input</p><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span></code></pre><p>Sample Output</p><pre><code class="hljs stylus"><span class="hljs-number">6</span><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span></code></pre><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2002" target="_blank" rel="noopener">Northeastern Europe 2002</a>, Western Subregion</p><hr><p>题目的中文大约是：给定两个容积为a，b的水壶，初始状态为空；再给一个水量c。每次操作可以如下进行：</p><ol><li>将壶1或者壶2填满；</li><li>将壶1或者壶2全部倒掉；</li><li>将一个壶中的水导入另一个壶中（能倒入多少就倒入多少，当然其中一个壶不能是空的，另一个不能是满的）</li></ol><p>输入abc，需要你输出当其中一个水壶的水量达到c时所用的次数与倾倒步骤打印出来；当然如果永远达不到c的话，输出impossible即可。</p><p>tips：多组输入，c符合规范。</p><p>emm，不妨以此题目为例，梳理一下[[bfs]]的做法好了。</p><p>首先我们要判断这道题目是[[bfs]]，从题目中可以清楚看出，求最短路径，每次的操作是固定的那么基本上就可以用bfs去解决。先看一般，再看特殊的地方需要什么东西来解决（比如题目所求的cnt，步骤）</p><ol><li><p><strong>确定一个状态包括了什么</strong>：比如，有的题目仅仅需要该点的位置，有的题目还需要其他的东西；只能具体问题具体分析了。在此题目中，我们可以看到一个状态就是我们的a，b两个水壶的储水量。</p><p>那么我们将其设定为一个struct node即可包括 两个int 代表两个水壶的储水量。</p><p>特别是考虑到本题目需要cnt和倒水的步骤，那么我们在每个状态里的的步骤都是不一样的，就用string 储存吧，然后每一个步骤添加的时候记得加上换行符号”\n”;</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">int</span> cnt;&#125;;</code></pre></li></ol><ol><li><p><strong>寻找vis范围</strong>，确定了总的范围我们才可以利用vis来判断我们是否踩过这个点，这也是最有效的方法来避免死循环,也是迫使队列结束的好方法。有题目给出的“These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).”所以我们知道a有100种可能，b也是。（小提示，如果你发现有题目似乎用不到vis那么大概也许<strong>可能</strong>他不一定需要使用bfs来解题）</p><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];</code></pre><p>对了，记住此题目是多行输入，意味着如果你的vis不及时初始化就会fc</p><p>在这里初始化 vis 可以使用memset，常见用法是这样。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span>CLR(vis,<span class="hljs-literal">false</span>);</code></pre></li><li><p>找到起点和终点的状态。终点顾名思义其中有一个水壶的储水量是c的时候就代表了end，而开始我们发现他给定的是两个空的水壶，所以我们给定一个node 初始化全0,记得标记vis是1，然后将其推到队列里作为起始点。</p><pre><code class="hljs cpp">  <span class="hljs-built_in">queue</span>&lt;node&gt; q;      node t;   t.cnt=<span class="hljs-number">0</span>;   t.x=<span class="hljs-number">0</span>;   t.y=<span class="hljs-number">0</span>;   t.s=<span class="hljs-string">""</span>;vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;   q.push(t);</code></pre><p>但，不难发现，第一步的走法其实只有给两个壶其中之一填满。所以我们也可以是将其设为两个初始点，添加到队列其中去，但是记得更改相关的数值，参考下code。</p><pre><code class="hljs cpp">node t;   t.cnt =<span class="hljs-number">1</span>;   t.x = a;   t.y = <span class="hljs-number">0</span>;   t.s = <span class="hljs-string">"FILL(1)\n"</span>;   q.push(t);      vis[a][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;   t.cnt =<span class="hljs-number">1</span>;   t.x = <span class="hljs-number">0</span>;   t.y = b;   t.s = <span class="hljs-string">"FILL(2)\n"</span>;   vis[<span class="hljs-number">0</span>][b] = <span class="hljs-number">1</span>;   q.push(t);</code></pre><p>当然，两者的区别并不是很大，选择前者更容易理解一些，也更加符合一般的bfs的要求。</p></li><li><p>下面就要进入queue队列的循环中去咯~</p><p>进入循环当然先把front给从队列中打捞出来。</p><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.empty())&#123;        node front  = q.front();        q.pop();        t = front;</code></pre><p>这里的t 是借用了上面的t实际上,我们往往是重新node next  的做法往往更普遍一些。</p><p>有了 此次开头的中心点，我们就要赶紧确定什么时候能结束了，万一我们直接就出去了呢哈哈。</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;            cnt = t.cnt;            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;            <span class="hljs-keyword">break</span>;        &#125;</code></pre><p>这里有一丝丝的玄机，因为这里采用了break，所以我们在最后bfs返回的是cnt的值，所以我们要将cnt给赋值了，才能return 回去。虽然我们在这里就输出了cnt，但返回的cnt是用来判断我们是否是impossible，如果我们一直没有找到使得题目成立条件，而队列走走完了，那我们就一直没有给cnt赋过值，所以我们自然是返回的是0 那么，就可在main函数中做出特判。</p></li><li><p>接下来就是几种动作的出现，其实就是6种</p><p> FILL(1),FILL(2),DROP(1),DROP(2),POUR(1,2),POUR(2,1) </p><p>我们在对其分别进行情况的判定，然后一一进行就可以了。当然这个过程是艰苦的，如果在一些相似的地方没有思考清楚而是cv的话，容易由于没有看清而出现许多问题。所以奥里给，这一部分需要认真一些。</p><p>对了，我们在前面看到我们既然进行到了这一步，一定是出不去了所以front.cnt++；</p><pre><code class="hljs cpp">front.cnt ++;        <span class="hljs-comment">//fill</span>         t = front;        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// </span>            t.x = a;            t.y = front.y;            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;                        q.push(t);            vis[a][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;            t.x = front.x;            t.y = b;            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;                        q.push(t);            vis[t.x][b] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//pour</span>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;                t.y = b;                t.x = front.x - (b-front.y);            &#125;            <span class="hljs-keyword">else</span> &#123;                t.y = front.y + front.x;                t.x = <span class="hljs-number">0</span>;               &#125;                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])                q.push(t);                vis[t.x][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;                t.y = front.y -(a - front.x);                 t.x = a;            &#125;            <span class="hljs-keyword">else</span> &#123;                t.x = front.x+ front.y;                t.y = <span class="hljs-number">0</span>;            &#125;                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])                                q.push(t);                vis[t.x][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//drop</span>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;            t.x = <span class="hljs-number">0</span>;            t.y = front.y;            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;                        q.push(t);        &#125;        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span>            t.y = <span class="hljs-number">0</span>;            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                    q.push(t);        &#125;         &#125;</code></pre></li></ol><p>最后return cnt;就可以结束这个bfs了。小心，因为代码过长，一处很小的错误可能就会gg。</p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>对，你没有看错，两套代码，中英双文嘿嘿，两种代码其实在一些小的方面有所不同，参考第一个即可，第二个是他人代码（出处已不可寻）</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><span class="hljs-keyword">int</span> a,b,c;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">int</span> cnt;&#125;;<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">0</span>;    CLR(vis,<span class="hljs-literal">false</span>);    <span class="hljs-built_in">queue</span>&lt;node&gt; q;    node t;    t.cnt=<span class="hljs-number">0</span>;    t.x=<span class="hljs-number">0</span>;    t.y=<span class="hljs-number">0</span>;    t.s=<span class="hljs-string">""</span>;    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;    q.push(t);    <span class="hljs-keyword">while</span>(!q.empty())&#123;        node front  = q.front();        q.pop();        t = front;        <span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;            cnt = t.cnt;            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;            <span class="hljs-keyword">break</span>;        &#125;        front.cnt ++;        <span class="hljs-comment">//fill</span>         t = front;        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// &lt;?</span>            t.x = a;            t.y = front.y;            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;                        q.push(t);            vis[a][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;            t.x = front.x;            t.y = b;            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;                        q.push(t);            vis[t.x][b] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//pour</span>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;                t.y = b;                t.x = front.x - (b-front.y);            &#125;            <span class="hljs-keyword">else</span> &#123;                t.y = front.y + front.x;                t.x = <span class="hljs-number">0</span>;               &#125;                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])                q.push(t);                vis[t.x][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;                t.y = front.y -(a - front.x);                 t.x = a;            &#125;            <span class="hljs-keyword">else</span> &#123;                t.x = front.x+ front.y;                t.y = <span class="hljs-number">0</span>;            &#125;                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])                                q.push(t);                vis[t.x][t.y] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//drop</span>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;            t.x = <span class="hljs-number">0</span>;            t.y = front.y;            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;                        q.push(t);        &#125;        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span>            t.y = <span class="hljs-number">0</span>;            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                    q.push(t);        &#125;         &#125;    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c))    &#123;        <span class="hljs-keyword">if</span>(bfs()==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"impossible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//personal code.</span><span class="hljs-comment">/*#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;#define CLR(arr,val) memset(arr,val,sizeof(arr))int n , m , x;bool vis[200][200];//图上所有点的取值区域可用 a，b的不同的水量状态表示！struct nodes&#123;int x, y;string step;int cnt;&#125;; int bfs() &#123;int cnt = 0;CLR(vis, 0);//initqueue&lt;nodes&gt; q;nodes nd1;nd1.x = 0;//(init)nd1.y = 0;nd1.cnt = 0;    nd1.step = "";q.push(nd1);vis[0][0]=1;while(!q.empty()) &#123;nodes nd = q.front();q.pop();if (nd.x == x || nd.y == x) &#123;// endcnt = nd.cnt;cout&lt;&lt;cnt&lt;&lt;"\n";// it looks like nothing at all. However this cnt is connect to the return value!                            //there is one possible thing is that we could at the last step that we find the right idea!cout&lt;&lt;nd.step;break;&#125;++nd.cnt;// every time the nd will be renew one as front;nodes nd2;//as nextnd2.cnt = nd.cnt; if (nd.x &lt; n &amp;&amp; !vis[n][nd.y]) &#123;//if fronter is not full&amp;&amp; not visit the status when it is fullnd2.x = n;nd2.y = nd.y;nd2.step = nd.step + "FILL(1)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;if (nd.y &lt; m &amp;&amp; !vis[nd.x][m]) &#123;nd2.x = nd.x;nd2.y = m;nd2.step = nd.step + "FILL(2)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;if (nd.x &gt; 0 &amp;&amp; nd.y != m) &#123;//when a is not a empty one &amp;&amp; b is not fullif (nd.x &gt;= (m - nd.y) &amp;&amp; nd.x != 0) &#123;//if a couldn't pour it's all to bnd2.x = (nd.x - (m - nd.y));// a will pour as more as it could nd2.y = m;&#125;             else &#123;//a could pour all to bnd2.y = (nd.x + nd.y);nd2.x = 0;&#125;if (!vis[nd2.x][nd2.y]) &#123;nd2.step = nd.step + "POUR(1,2)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;&#125;if (nd.y &gt; 0 &amp;&amp; nd.x != n) &#123;//pour b to aif (nd.y &gt;= (n - nd.x) &amp;&amp; nd.y != 0) &#123;nd2.y = (nd.y - (n - nd.x));nd2.x = n;&#125; else &#123;nd2.x = (nd.y + nd.x);nd2.y = 0;&#125;if (!vis[nd2.x][nd2.y]) &#123;nd2.step = nd.step + "POUR(2,1)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;&#125;if (nd.x &gt; 0 &amp;&amp; !vis[0][nd.y]) &#123;//a is not emptynd2.x = 0;nd2.y = nd.y;nd2.step = nd.step + "DROP(1)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;if (nd.y &gt; 0 &amp;&amp; !vis[nd.x][0]) &#123;nd2.x = nd.x;nd2.y = 0;nd2.step = nd.step + "DROP(2)\n";q.push(nd2);vis[nd2.x][nd2.y] = 1;&#125;&#125;return cnt;&#125; int main()&#123;while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;x) &#123;if (bfs() == 0) &#123;cout&lt;&lt;"impossible"&lt;&lt;endl;&#125; &#125;&#125;*/</span></code></pre><p>当然，这道题目还见到有用其他方法去配合bfs进行解题的，</p><p><a href="https://blog.csdn.net/qq_34374664/article/details/53170539" target="_blank" rel="noopener">其他方法之一</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。&lt;/p&gt;
&lt;p&gt;此题目：细心，冷静，多思考。&lt;/p&gt;
&lt;p&gt;当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="poj bfs" scheme="https://jefine.github.io/tags/poj-bfs/"/>
    
  </entry>
  
  <entry>
    <title>BFS小结</title>
    <link href="https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/"/>
    <id>https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/</id>
    <published>2020-07-15T07:52:04.000Z</published>
    <updated>2021-01-24T11:22:14.986Z</updated>
    
    <content type="html"><![CDATA[<p>BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.</p><p>todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）</p>  <a id="more"></a><h2 id="BFS是什么"><a href="#BFS是什么" class="headerlink" title="BFS是什么?"></a>BFS是什么?</h2><blockquote><p> <strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href="https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">图形搜索算法</a>。简单的说，BFS是从<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">根节点</a>开始，沿着树的宽度遍历树的<a href="https://zh.wikipedia.org/wiki/节点" target="_blank" rel="noopener">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。  (<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">链接</a>)</p></blockquote><h2 id="BFS流程是"><a href="#BFS流程是" class="headerlink" title="BFS流程是?"></a>BFS流程是?</h2><p>从起点出发,将到终点之间将所有的路几乎全部走一遍。</p><p>一般用来寻找最短路程.</p><p>思想上来说是穷举所有的情况,踩遍所有的可能点或找到终点。</p><p>我们通常是这样做的:</p><p>需要: </p><ul><li><p>一个状态所需要的内容作为一个节点。（比如坐标等）</p></li><li><p>一个足够大的位置集合,来表示我们是否来过(可能是二维数组甚至更高维度，也可能是其他的形式，要看具体状态的要求).</p><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[max];</code></pre></li><li><p>一个队列,表示我们即将将队列中的每一个元素作为一个新的起点去重新出发.(queue).</p></li><li><p>一个起点,一个终点.</p></li><li><p>可能需要: 一个记录步数的数组(或其他形式),用来记录是第几步向外，一般放在节点结构里.int step[];</p></li></ul><h4 id="什么时候开始"><a href="#什么时候开始" class="headerlink" title="什么时候开始?"></a>什么时候开始?</h4><p>我们常常从起点开始<del>(废话)</del>, 起点仅仅只有一个点, 我们先将其标记一下,表示我们来过了,然后我们将其加入队列.</p><p>我们将从起点开始的每一个可能可以去的位置,都进行遍历,然后将它们添加到队列中去.</p><p>上面的步骤可以说是每一道题目的必需步骤了,然后我们就要依据题目的条件进行分析咯~</p><h4 id="我们什么时候结束"><a href="#我们什么时候结束" class="headerlink" title="我们什么时候结束?"></a>我们什么时候结束?</h4><p><strong>当队列为空的时候</strong>,何时队列为空呢——当我们踩扁所有的点的时候(不能踩的当然就算了).</p><p>我们依据题目,在地图上的点,并不是每个点都可以踩的,<del>要不然还这么辛苦干么.</del></p><p>那我们就要总结出来: 什么是往下一个点的规律(可以往那里移动?),什么点是不能踩的,约束条件是什么.</p><p>所以,我们往往判断一个点可不可以踩的时候我们要对他有很多的约束条件.</p><p>例如，在二维的地图上，不能越界，不能进入禁止的点，没有来过此点等等。</p><p>例如,小老鼠走迷宫的问题:那么我们就可以根据题目,得到我们小老鼠不能碰的那些点,每次小老鼠可以怎样走动呢?上下左右都可以走,我们就还要判断他们是否出界.进行挑选出那些<strong>从一点可以到该点所能触及的所有不违反规则的点</strong>,别忘了,我们还要判断他们是不是我们要寻找的终点.</p><p>在一层一层的脱离过程中我们会发现还要根据题目要求记下一些东西,往往是所走的路程是多少,那么刚刚提及的最后一个记录步数的数组就可以起效了,我们往往这样使用:</p><pre><code class="hljs cpp">step[next] = step[front]+<span class="hljs-number">1</span>;</code></pre><p>因为我们从一点出发往往会经过许许多多的点,然而这些点都是我们一步可以走到的点.不能将他们累加起来作为我们的实际步数.</p><p>宏观上看,我们其实更像是一个池塘中的波纹,每一个波纹有小及大的向外扩散.那么看起来与BFS的算法思想是极为相似的,我们也是从一点抛下一颗小石子,然后等波纹自己寻找到终点(水中的另外一颗小石头的位置).可以想象到我们如果碰触到终点后不停止,那么水波将不断的向远处扩散,知道池塘全部被波及.但我们往往不需要那样做,那样通常是最坏的情况了(也意味着我们要踩所有的可能点呢).</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h4><ol><li>首先将根节点放入队列中。</li><li>从队列中取出第一个节点，并检验它是否为目标。 <ul><li>如果找到目标，则结束搜索并回传结果。</li><li>否则将它所有尚未检验过的直接子节点加入队列中。</li></ul></li><li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li><li>重复步骤2。</li></ol><p>其中重要 的就是我们需要限制的约束条件和下一个位置的可能点.</p><p>当然[[bfs]]是一个思想并不拘泥于为某道题目而服务,所以我们往往需要多加练习,在面对求最短路径的时候,才能从容不迫的写出题解.</p><h3 id="需要注意的几个小点点："><a href="#需要注意的几个小点点：" class="headerlink" title="需要注意的几个小点点："></a>需要注意的几个小点点：</h3><ol><li><p>vis是为了防止我们将踩过的点再次踩入</p><p>想象一下，我们水花的方向是四周的一圈，那么也一定会有的向着我们已经走过的路的水波方向，我们要做好辨别工作，那么就给他们加上一个vis的判断。他们的范围就是所有的可能涉及的区域集合。可能通常是数组。</p><p>这样，我们不必花费过多的时间去判断该行为是否会造成逆流，我们只需要进行有效的标注即可！</p><p>杜绝了同样的状态二次出现！</p></li><li><p>我们通常会遇到需要记录层数的时刻，那么最好是使用一个node 里面放上cnt来记录当前节点的层数。</p></li><li><p>我们在对于一个节点进行多个动作时候，需要注意，我们要将其恢复为front的状态，或者更方便一些的，我们直接将其 cnt++；在循环的过程中，我们一直采用front来判断条件或者是对即将入队的节点进行赋值。</p><p>eg：在洛谷1135的题目中我们在队列的循环过程中的front进行变动的做法：而不是对t进行改动。在其他的题目中也经常适用，不要改变t，除非即将入队，判断采用front的+-等进行操作即可。</p><pre><code class="hljs cpp">t.cnt = front.cnt+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(CHECK((front.h+high[front.h])))&#123;    t.h = front.h+high[front.h];    vis[t.h] = <span class="hljs-number">1</span>;    q.push(t);&#125;</code></pre></li><li><p>我们如果需要记录可以达到多少个点，那么我们在队列中，只要 !vis 我们就可以给他count++；一般是放在动作里面的。如上面的代码情况就放在vis[t.h]=1 下面一行即可。</p></li><li><p>如果我们需要遍历出到每一个点的最短步数，如洛谷p1443，我们最暴力的想法就是给定每一点作为终点，不断地去跑bfs，然而这样是复杂度很高的，完全没有必要这样做，我们既然目标是所有的点，那么我们再 声明一个和vis的范围相同的一个ans数组来记录一个queue的每个点（！vis）的时候的步数即可，未记录的即为无法达到，通过遍历ans数组即可获得相关内容。</p></li><li><p>遇到三维的状态（hdu1204）时，只需要注意输入，接着按照正常的bfs动作流程即可。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.&lt;/p&gt;
&lt;p&gt;todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>输出全组合二进制</title>
    <link href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/</id>
    <published>2020-07-04T11:48:29.000Z</published>
    <updated>2020-08-10T04:08:57.143Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。</p>  <a id="more"></a><p>首先：辨析一下排列和组合的区别。</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列： </p><script type="math/tex; mode=display">\frac{n!}{(n-k)!}</script><p>组合：</p><script type="math/tex; mode=display">\frac{n!}{(n-k)!*k!}</script><p>可以看出排列的数目<strong>大于等于</strong>组合的数目，以及他们的计算方式如上图。公式来源详见<a href="https://zhuanlan.zhihu.com/p/41855459" target="_blank" rel="noopener">解析链接</a>，这很快帮助你回忆如何计算。</p><hr><p>回归题目：</p><p>n个元素的子集一共有 $2^n$个（从下面的对应关系中的二进制数也可看出的确是$2^n$)</p><p>那么他们此间的对应关系是这样的：</p><script type="math/tex; mode=display">\begin{Vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{Vmatrix}</script><p>这个神奇的的排列规律是我们进行下面编程的理论（可以从二进制看子集与十进制）</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-number">3</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//解释一下1&lt;&lt;n是位运算，结果是2^n</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">if</span>(i&amp; (<span class="hljs-number">1</span>&lt;&lt;j))<span class="hljs-comment">//其中i只在第一次空集的时发挥作用。</span>                        <span class="hljs-comment">//这里巧妙地运用了二进制的知识，并且运用位运算的性质，得到结果</span>                        <span class="hljs-built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">" "</span>;        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs basic"><span class="hljs-number">0</span><span class="hljs-number">1</span><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span></code></pre><p>刚开始，觉得这个输出很神奇，直接输出了n个数字的所有集合（还按照一定的顺序），代码还十分简洁。</p><p>其中两个for循环中的if判断可谓是亮点了。</p><p>那么究竟是什么意思呢，记住这里还要会回顾一下那个表格了：</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><pre><code class="hljs lisp">if (<span class="hljs-name">i</span> &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )</code></pre><p>首先明确一下 <strong>“&amp;”：<em>与</em>， 即在二进制中 </strong>同一为一（取每一位二进制的数字，两者均为1时为1）：</p><p>例如 0001 &amp; 0011为 1；</p><p>​        0010 &amp;  0001为0。</p><p>此行代码中的’ i ‘指的是二进制数中1的个数，可以发现在二进制中第一次i==0，而二进制数中不含1的只有空集，与结果相对应；</p><p>接着我们分析<strong>i==1</strong>时刻，判断条件其实可以替换为（0001 &amp; ( i&lt;&lt;j )),这是说明只有二进制数最后一位为1的才能呵前面$1_{(10)}$或者说$0001_{(2)}$相 “与&amp;” 为真。那么我们可以看出只有1 3  5 7这样的奇数才满足尾数为1，才能使得条件成立。BUT我们分析一下判断条件里的另一个变量1&lt;&lt;j，代表的是$2^n$，也就是说只有j==0的时候，才成立，这也就是第二行结果“0”的来历；</p><p>同理我们可以分析出<strong>i==2</strong>，即二进制的0010的时候只有j==1的时候才成立；</p><p><strong>i==3</strong>的时候，即左边为$0011_{(2)}$的时候这个时候只要是 在最后一位为一或者倒数第二位数字是一的二进制数即可，也就是说 十进制的0，1，3，5，7都可成立。但是 要注意的是 （i&lt;&lt;j)只能为十进制的$2^n$,所含的奇数只有1。所以除0，1外的j均不成立。</p><p>经过上面的分析我们<del>不得不</del>对代码的正确性给予了肯定，但好像还是不太清楚为什么能够这样做。</p><p>那我们不妨回首二进制。</p><p>不难发现，我们最终并没有用到3，4，5，6，7这样的十进制数字（尽管他们在上表中有所对应，但那也不过是各种情况的编号罢了，），只是用了0，1，2这恰好是[0,n)的范围内的数字。大胆推测 只有当i的数字越大那么在j中二进制中的1 出现的概率越大，（tips，$0111_{(2)}$恰好是7，二进制中的1的个数是（2+1）个1 emm~）。例如$7_{(10)}$ 对应$0111_{(2)}$那么他就可以有三个数字的集合成立了（果然是012）</p><p><del>上面一段有点饶头，仔细想想，都是对的，但似乎没什么用~可以无视</del>~~</p><p>自己在不断探索的过程中，仍能够不断的发现二进制的奇妙用途，和神奇1 的对应。此题还需慢慢回味。</p><hr><p>​    数日后，再次回顾此代码，发现有着许多的新的感悟：之前不太明白的地方都一一揭开：</p><p>首先就是</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制(i)&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><p>哈哈，这个和上图的有什么区别呢？<del>并没有</del>，只是多了一个标识i</p><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )</code></pre><p>回顾代码：不难看出其实对于作者的行为我<del>们</del>是有一些困惑的。为什么要这样做？</p><p>那我们不妨解释一下i和j的作用好了</p><p><strong>i</strong>  :其实对应的是上表中的对应的十进制：也就是说，我们将i循环了$n^2$次，其实就是恰好我们将这n个子集打印出来。</p><p><strong>j</strong>  :其实是二进制的从低到高位依次赋值1，并判断是否&amp;，1&lt;&lt;j 其实就是 $2^j$ 次方wow，当j为0时其实就是二进制的最后一位为1，j=1时判断倒数第二位是否为1。那么判断的另一个对象是谁呢？当然是i。</p><p>每一个i的二进制都不相同，我们就可以依次利用j来判断该位上是否有数字有的话就把j输出出去，j是[0,n)所以可以利用二进制完美地实现所有子集的输出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>负数二进制（码制与数制）</title>
    <link href="https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/"/>
    <id>https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/</id>
    <published>2020-06-28T06:56:31.000Z</published>
    <updated>2021-01-24T11:21:02.340Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和<strong>应用</strong>，后者为重点）</p>  <a id="more"></a><h2 id="二进制的计算"><a href="#二进制的计算" class="headerlink" title="二进制的计算"></a>二进制的计算</h2><p>在此次的课程中在开始便讲述了二进制的计算：</p><p>但其均为正数的时候，计算较为简单和一般的十进制的计算无异（竖式）</p><p>但是当其为负数的时候我们就要多加一个步骤了</p><p>在这里，先补充以下编码：</p><p><strong>编码：</strong></p><p>我们常常将信息通过编码储存起来。</p><blockquote><p>信息编码（Information Coding）是为了方便信息的存储、检索和使用，在进行信息处理时赋予信息元素以代码的过程。即用不同的代码与各种信息中的基本单位组成部分建立一一对应的关系。信息编码必须标准、系统化，设计合理的编码系统是关系信息管理系统生命力的重要因素。</p><p>信息编码的目的　信息编码的目的在于为计算机中的数据与实际处理的信息之间建立联系，提高信息处理的效率。</p></blockquote><p>我们在小学（可能，大雾）的时候，就已经学过如何将十进制和二进制进行相互的转化。</p><p>但是，在当时，出于年纪小，我们并没有学会如何实现负数的运算。</p><p>那么，首先我们康一下：<strong>负数二进制是如何表示的</strong>。</p><p>有人说：在最前添加一bit（一位）：1代表负数，0代表正数。</p><p>那么在计算的时候我们是不是就可以直接去计算了呢？</p><p>并不是这样的我们这样去计算的话就犯下一个错误：</p><p>将<strong>数制和码制混淆。</strong></p><p><strong>数制：</strong>即<strong>计数制，数数的方法。</strong>是指十进制二进制，八进制此类的进制。</p><p><strong>码制</strong>（用编码的方式表示信息<strong>,即用不同数码表示不同事物时遵循的规则。</strong>例如：学号，身份证号，车牌号）:与前者不同的是，码制表示的并不真的只是一个数字，而是一个信息。人们通过编码的方式将他们转化为数字（不同进制均可）。这就涉及到了 信息→数字 的转换。同样不同的编码方式，所得出的结果自然是不同的。所以也可以用来加密。常用的有：BCD，ASCII等。</p><p>目前，数字电路中都采用二进制。</p><ol><li><p>表示数量时称二进制</p></li><li><p>表示事物时称<strong>二值逻辑</strong></p><p>好了，回归正题~</p><hr></li></ol><p>其实按照我们正常的思路我们自己是希望能够按照十进制的方式（竖式）去进行计算的。</p><p>在有了前面的基础之后，我们自己对于码制和数制有了一定的了解。那么我们是不是可以计算负数二进制了呢?</p><p>并不是，首先我们要将负数的二进制标识出来吧。</p><p>假设我们向上面所说的添加一个负号，</p><p>那么是不是我们可以推出呢:</p><script type="math/tex; mode=display">-13_{(10)} = -1101_{(2)}</script><p>To be honest:</p><p>我们很想让它成为这样的但是并不可行。</p><p>这里可以去随意尝试一个例子即可（例如 -13+10）</p><p>我们会发现计算的结果转化为10进制之后是错的。</p><p>为什么呢，<strong>就是码制和数制之间，我们搞混了</strong>。负数的二进制的第一个1是码制，代表的是一个含义：负数，而我们在计算的时候将其作为一个数值进行了计算，自然错误。那么有解决的方法么？</p><p>当然，那么我们应该在哪里修改呢？</p><p>在二级制的负数表达上进行修改！</p><p>事实上，如果我们去计算器（高级计算器）上实行进制转换。我们会发现-13，并不是单纯的将13的二进制前一位添加了一个1，而是添加在最前1之后，将13的<strong>二进制取反，然后将这个二进制+1.</strong></p><p>那么我们怎么去理解这个二进制的意思呢？</p><p>举个例子： </p><script type="math/tex; mode=display">-13_{(10)} = 10011_{(2)}</script><p>是指 第一个数字作为 负数，其余仍为正数：</p><script type="math/tex; mode=display">\begin{array}{cc} 1&0&0& 1& 1 \\ -16*1&8*0&4*0&2*1&1*1\\\end{array}</script><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>二进制的负数的运算既在我们的意料之中，又在我们的意料之外。惊喜连连~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和&lt;strong&gt;应用&lt;/strong&gt;，后者为重点）&lt;/p&gt;</summary>
    
    
    
    <category term="数字电路" scheme="https://jefine.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
</feed>
