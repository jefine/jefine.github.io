<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jefine</title>
  
  <subtitle>小小的梦呓</subtitle>
  <link href="https://jefine.github.io/atom.xml" rel="self"/>
  
  <link href="https://jefine.github.io/"/>
  <updated>2021-01-02T09:45:29.765Z</updated>
  <id>https://jefine.github.io/</id>
  
  <author>
    <name>jefine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021</title>
    <link href="https://jefine.github.io/2021/01/01/2021/"/>
    <id>https://jefine.github.io/2021/01/01/2021/</id>
    <published>2021-01-01T12:45:37.000Z</published>
    <updated>2021-01-02T09:45:29.765Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                    <strong>2020—-&gt;2021</strong></p><p><strong>活着</strong></p><p><img src="/2021/01/01/2021/2021.jpg" alt="2021-2020"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​                                                                    &lt;strong&gt;2020—-&amp;gt;2021&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;活着&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="record" scheme="https://jefine.github.io/categories/record/"/>
    
    
    <category term="newyear" scheme="https://jefine.github.io/tags/newyear/"/>
    
  </entry>
  
  <entry>
    <title>atabc173c C - H and V</title>
    <link href="https://jefine.github.io/2020/07/23/atabc173c/"/>
    <id>https://jefine.github.io/2020/07/23/atabc173c/</id>
    <published>2020-07-23T13:21:46.000Z</published>
    <updated>2020-08-10T04:07:02.879Z</updated>
    
    <content type="html"><![CDATA[<p>此题目主要包括了全排列，二进制的相关知识</p>  <a id="more"></a><p><a href="https://atcoder.jp/contests/abc173/tasks/abc173_c" target="_blank" rel="noopener">C - H and V</a>(单击题目可进入下图链接)</p><p><img src="/2020/07/23/atabc173c/Screenshot_2020-07-23 C - H and V.png" alt="2020-07-23 C - H and V"></p><p>题意：第一次看的时候，看的有点呆。</p><p>给定一个矩阵，每个点都被标记为白色或者黑色，然后使你开始刷漆（红漆），一次可以涂一行或者一列，任意涂刷n次（可以是0）求有多少种方案可以使得最终黑色的砖块的数量为所给的数量。</p><p>当时思考：</p><p>opps，不会吧，难道是要暴力？这个怎么暴力？这不可能暴力吧，这么复杂呢。第一行可刷可不刷，第一列可刷可不刷。那么岂不是有很多的情况么，怎么处理呢。当场傻掉。</p><p>题解：</p><p>暴力~~~（逃不过）</p><p>但是采用了和二进制映射map的操作，也就是说 对于每一行我们有两个状态，涂刷或者不涂刷，那么一共有 h 行，w列。行的变化之间是互不关联的，所以说一共有 $2^h$ 种可能，同理 列也有 $2^w$ 种可能的情况，他们都是独立的，所以该涂刷方案一共有 $2^h * 2^w = 2^{(h+w)}$ 种可能的涂刷方案2333.</p><p>注意到数据的范围： 1≤H,W≤6 所以 如果采暴力的方法我们也不过是 $2^{12} = 4096$ 次操作，并不会从boom，是一个相对计算机而言很小的一个数据大小。</p><p>那么如何去储存一个 4096（最大） 种情况呢（其中每一种情况要表示：一共要涂刷的行或者列），我们采用了二进制状态映射的方法（<a href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/">回想之前全排列的二进制方法</a>） 同样这次我们对于 矩阵的行 而言，一共有h行，那么一共有 $2^h$ 种行的不同状态（即不同的涂刷方式）我们就采取二进制的方法记录，这种对于单个单位（如 此处的行）只有两种状态的数据的存储。例如：0b001 可以表示第一行第二行不刷红色，第三行刷红。</p><p>我们采用 0 表示不涂刷，或者表示涂刷都是可以的，无伤大雅（毕竟有一个不刷的状态就会有刷的情况与之对应，我们将全部情况都列出来了 了 了）。所以 十进制下的 $0-(h-1)$ 就可以将  $2^h$ 种状态全部表示出来了。</p><p>如果我们采用的是其他（比如，采用了 用一个矩阵来保存一种可能性的结果的话，那么就需要4000多个矩阵来表示，但想想一个矩阵我们采用一个二维数组emm 过于复杂咯，更何况每个矩阵依旧是需要依次遍历循环 判断黑色个数）</p><p>同理，我们也可以将列的表示如上方式，这样我们就实现了：<strong>采用一个十进制的数字（其实需要的是它所对应的二进制），来表示一行或者一列的涂刷情况了</strong>。</p><p>接着，我们就要判断出该行列状态下的黑砖的数量是不是和题目要求的一致，一致就cnt++。</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> H, W, K;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;H, &amp;W, &amp;K);<br><span class="hljs-keyword">char</span> c[H][W];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; W; ++j) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c[i][j]);<br>&#125;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; H); ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; W); ++j) &#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// above is the every situation that we may face</span><br><br><span class="hljs-comment">// for each block c[k][l]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; H; ++k) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; W; ++l) &#123;<br><span class="hljs-comment">//i , j = 0b0101 </span><br><span class="hljs-keyword">if</span> (!(i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) &amp;&amp; !(j &amp; (<span class="hljs-number">1</span> &lt;&lt; l)) &amp;&amp; c[k][l] == <span class="hljs-string">'#'</span>) ++cnt;<span class="hljs-comment">//1 red, 0 not red</span><br><br><span class="hljs-comment">//if ((i &amp; (1 &lt;&lt; k)) &amp;&amp; (j &amp; (1 &lt;&lt; l)) &amp;&amp; c[k][l] == '#') ++cnt;//0 red, 1 not red</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (cnt == K) ++ans;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;此题目主要包括了全排列，二进制的相关知识&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="atcoder 二进制" scheme="https://jefine.github.io/tags/atcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hdu1240Asteroids</title>
    <link href="https://jefine.github.io/2020/07/18/hdu1240Asteroids/"/>
    <id>https://jefine.github.io/2020/07/18/hdu1240Asteroids/</id>
    <published>2020-07-18T08:30:07.000Z</published>
    <updated>2020-08-10T04:10:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。</p>  <a id="more"></a><p><strong><em>\</em>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 7201  Accepted Submission(s): 4454<br>**</strong></p><p>Problem Description</p><p>You’re in space.<br>You want to get home.<br>There are asteroids.<br>You don’t want to hit them.</p><p>Input</p><p>Input to this problem will consist of a (non-empty) series of up to 100 data  sets. Each data set will be formatted according to the following  description, and there will be no blank lines separating data sets.</p><p>A single data set has 5 components:</p><p>Start line - A single line, “START N”, where 1 &lt;= N &lt;= 10.</p><p>Slice list - A series of N slices. Each slice is an N x N matrix representing a horizontal slice through the asteroid field. Each position in the  matrix will be one of two values:</p><p>‘O’ - (the letter “oh”) Empty space</p><p>‘X’ - (upper-case) Asteroid present</p><p>Starting Position - A single line, “A B C”, denoting the <A,B,C>  coordinates of your craft’s starting position. The coordinate values  will be integers separated by individual spaces.</A,B,C></p><p>Target Position - A single line, “D E F”, denoting the <D,E,F> coordinates of your  target’s position. The coordinate values will be integers separated by  individual spaces.</D,E,F></p><p>End line - A single line, “END”</p><p>The  origin of the coordinate system is <0,0,0>. Therefore, each  component of each coordinate vector will be an integer between 0 and  N-1, inclusive.</0,0,0></p><p>The first coordinate in a set indicates the column. Left column = 0.</p><p>The second coordinate in a set indicates the row. Top row = 0.</p><p>The third coordinate in a set indicates the slice. First slice = 0.</p><p>Both the Starting Position and the Target Position will be in empty space.</p><p>Output</p><p>For each data set, there will be exactly one output set, and there will be no blank lines separating output sets.</p><p>A single output set consists of a single line. If a route exists, the  line will be in the format “X Y”, where X is the same as N from the  corresponding input data set and Y is the least number of moves  necessary to get your ship from the starting position to the target  position. If there is no route from the starting position to the target  position, the line will be “NO ROUTE” instead.</p><p>A move can only be in one of the six basic directions: up, down, left, right, forward,  back. Phrased more precisely, a move will either increment or decrement a single component of your current position vector by 1.</p><p>Sample Input</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">START <span class="hljs-number">1</span><br>O<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br>END<br>START <span class="hljs-number">3</span><br>XXX<br>XXX<br>XXX<br>OOO<br>OOO<br>OOO<br>XXX<br>XXX<br>XXX<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>END<br>START <span class="hljs-number">5</span><br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>XXXXX<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br>OOOOO<br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>END<br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-literal">NO</span> <span class="hljs-string">ROUTE</span><br></code></pre></td></tr></table></figure><p>Source</p><p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=South+Central+USA+2001&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> South Central USA 2001 </a> </p><p>poj2225 亦为此题</p><h2 id="题意及要求"><a href="#题意及要求" class="headerlink" title="题意及要求"></a>题意及要求</h2><p>先来说说真实的题意吧：</p><p>题目给出一个三维的图，使得从一个三维的点，从起点到终点最短距离以及能否走到。多次输出题目。</p><p>看似是一道很简单的bfs题目，其实他就是一道很简单的bfs题目。</p><p>不信你看，本题目其中的bfs的内容就是这样正常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>          <span class="hljs-comment">//  cout&lt;&lt;"x,y,z is  "&lt;&lt;next.x&lt;&lt;" "&lt;&lt;next.y&lt;&lt;" "&lt;&lt;next.z&lt;&lt;"  val is "&lt;&lt;val[next.x][next.y][next.z]&lt;&lt;" CHECK is "&lt;&lt;CHECK(next.x,next.y,next.z)&lt;&lt;endl;</span><br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p><strong>但是</strong></p><p>问题来了，这道题还是对我造成了很大的困扰的，因为在数据的输入和存储这一块吃了大亏。</p><p>第一次看完题目，感觉像是给出是一个坐标点，然后所给的数据分成了多层，层与层是可以互通的，就想着把他当作二维的来做。写的时候还感到奇怪，为什么有六种动作呢，不就是只有四种（前后左右）么？还沾沾自喜，感觉自己找到了捷径。。。。。。</p><p>后来吧，总是wa，看了别人的讨论才发现原来题看错了，理解错误（英语还需增强啊，<del>太尬了</del>~~~）</p><p>这个时候的心情再回首回去当时，就感觉当时的自己仿佛是低维空间的生物在理解着三维世界的神奇（并且是失败的那种），科幻的感觉啊啊。</p><p>接着在写正确的三维的版本的时候，仍是接连不断的错误喷涌而来，通过长久的层层的debug（数小时）发现是在输入和储存方面出现了错误，题目给定的是一个接着一个二维图数据，所以需要自己去转化，但是，当时自己只想到了第一层，把高度使用行号/n来判断，他的高度，但是忘记给行号更改了，导致自己出现了错误，许多点没有标记上。（属于坐标错误吧，矩阵储存失败。。。）</p><p>导致了本应很顺利的题目，搞了很久，另外，题目给定的顺序是 列 行，而不是行列，所有还需要自己翻一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// #include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(x,y,z) (x&gt;=0&amp;&amp;x<span class="hljs-meta-string">&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;z&gt;=0&amp;&amp;z&lt;n&amp;&amp;!(vis[x][y][z])&amp;&amp;val[x][y][z])</span></span><br><span class="hljs-comment">//val bug</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,z,cnt;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> move[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;<br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;<br>&#125;;<br>    <span class="hljs-keyword">bool</span> vis[n][n][n];  <br>    <span class="hljs-keyword">bool</span> val[n][n][n];<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    CLR(val,<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">int</span> A,B,C,D,E,F;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n*n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;c);<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'O'</span>)val[i%n][j][i/n]=<span class="hljs-number">1</span>;<br>        &#125;<br>        getchar();<br>    &#125;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d %d %d %d\n"</span>, &amp;B,&amp;A,&amp;C,&amp;E,&amp;D,&amp;F);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"END\n"</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>    node t;<br>    t.x = A;t.y= B;t.z =C;t.cnt=<span class="hljs-number">0</span>;<br>    q.push(t);<br>    vis[A][B][C]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((!q.empty()))<br>    &#123;<br>        node front = q.front();<br>        q.pop();<br><br>        <span class="hljs-keyword">if</span>((front.x== D)&amp;&amp;(front.y== E)&amp;&amp;(front.z== F))&#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;front.cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front.cnt++;<br>        node next = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            next.x = front.x + move[i][<span class="hljs-number">0</span>];<br>            next.y = front.y + move[i][<span class="hljs-number">1</span>];<br>            next.z = front.z + move[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(CHECK(next.x,next.y,next.z))&#123;<br>                vis[next.x][next.y][next.z]=<span class="hljs-number">1</span>;<br>                q.push(next);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO ROUTE"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"START %d\n"</span>,&amp;n))&#123;<br>        bfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Asteroids是一道坐标点三维的bfs题目，尤其是在三维坐标的输入存储的过程中，需要注意。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>poj3414Pots</title>
    <link href="https://jefine.github.io/2020/07/16/poj3414Pots/"/>
    <id>https://jefine.github.io/2020/07/16/poj3414Pots/</id>
    <published>2020-07-16T11:25:05.000Z</published>
    <updated>2020-08-10T04:10:20.466Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。</p><p>此题目：细心，冷静，多思考。</p><p>当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。</p>  <a id="more"></a><hr><h4 id="Pots"><a href="#Pots" class="headerlink" title="Pots"></a>Pots</h4><div class="table-container"><table><thead><tr><th><strong>Time Limit:</strong> 1000MS</th><th></th><th><strong>Memory Limit:</strong> 65536K</th><th></th><th></th></tr></thead><tbody><tr><td><strong>Total Submissions:</strong> 31113</td><td></td><td><strong>Accepted:</strong> 12915</td><td></td><td>Special Judge</td></tr></tbody></table></div><p>Description</p><p>You are given two pots, having the volume of <strong>A</strong> and <strong>B</strong> liters respectively. The following operations can be performed:</p><ol><li>FILL(i)    fill the pot <strong>i</strong> (1 ≤ <strong>i</strong> ≤ 2) from the tap;</li><li>DROP(i)   empty the pot <strong>i</strong> to the drain;</li><li>POUR(i,j)  pour from pot <strong>i</strong> to pot <strong>j</strong>; after this operation either the pot <strong>j</strong> is full (and there may be some water left in the pot <strong>i</strong>), or the pot <strong>i</strong> is empty (and all its contents have been moved to the pot <strong>j</strong>).</li></ol><p>Write a program to find the shortest possible sequence of these operations that will yield exactly <strong>C</strong> liters of water in one of the pots.</p><p>Input</p><p>On the first and only line are the numbers <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).</p><p>Output</p><p>The first line of the output must contain the length of the sequence of operations <strong>K</strong>. The following <strong>K</strong> lines must each describe one operation. If there are several sequences  of minimal length, output any one of them. If the desired result can’t  be achieved, the first and only line of the file must contain the word ‘<strong>impossible</strong>’.</p><p>Sample Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure><p>Source</p><p><a href="http://poj.org/searchproblem?field=source&amp;key=Northeastern+Europe+2002" target="_blank" rel="noopener">Northeastern Europe 2002</a>, Western Subregion</p><hr><p>题目的中文大约是：给定两个容积为a，b的水壶，初始状态为空；再给一个水量c。每次操作可以如下进行：</p><ol><li>将壶1或者壶2填满；</li><li>将壶1或者壶2全部倒掉；</li><li>将一个壶中的水导入另一个壶中（能倒入多少就倒入多少，当然其中一个壶不能是空的，另一个不能是满的）</li></ol><p>输入abc，需要你输出当其中一个水壶的水量达到c时所用的次数与倾倒步骤打印出来；当然如果永远达不到c的话，输出impossible即可。</p><p>tips：多组输入，c符合规范。</p><p>emm，不妨以此题目为例，梳理一下bfs的做法好了。</p><p>首先我们要判断这道题目是bfs，从题目中可以清楚看出，求最短路径，每次的操作是固定的那么基本上就可以用bfs去解决。先看一般，再看特殊的地方需要什么东西来解决（比如题目所求的cnt，步骤）</p><ol><li><p><strong>确定一个状态包括了什么</strong>：比如，有的题目仅仅需要该点的位置，有的题目还需要其他的东西；只能具体问题具体分析了。在此题目中，我们可以看到一个状态就是我们的a，b两个水壶的储水量。</p><p>那么我们将其设定为一个struct node即可包括 两个int 代表两个水壶的储水量。</p><p>特别是考虑到本题目需要cnt和倒水的步骤，那么我们在每个状态里的的步骤都是不一样的，就用string 储存吧，然后每一个步骤添加的时候记得加上换行符号”\n”;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p><strong>寻找vis范围</strong>，确定了总的范围我们才可以利用vis来判断我们是否踩过这个点，这也是最有效的方法来避免死循环,也是迫使队列结束的好方法。有题目给出的“These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).”所以我们知道a有100种可能，b也是。（小提示，如果你发现有题目似乎用不到vis那么大概也许<strong>可能</strong>他不一定需要使用bfs来解题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br></code></pre></td></tr></table></figure><p>对了，记住此题目是多行输入，意味着如果你的vis不及时初始化就会fc</p><p>在这里初始化 vis 可以使用memset，常见用法是这样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br>CLR(vis,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li><li><p>找到起点和终点的状态。终点顾名思义其中有一个水壶的储水量是c的时候就代表了end，而开始我们发现他给定的是两个空的水壶，所以我们给定一个node 初始化全0,记得标记vis是1，然后将其推到队列里作为起始点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br>   <br>   node t;<br>   t.cnt=<span class="hljs-number">0</span>;<br>   t.x=<span class="hljs-number">0</span>;<br>   t.y=<span class="hljs-number">0</span>;<br>   t.s=<span class="hljs-string">""</span>;<br>vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure><p>但，不难发现，第一步的走法其实只有给两个壶其中之一填满。所以我们也可以是将其设为两个初始点，添加到队列其中去，但是记得更改相关的数值，参考下code。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node t;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = a;<br>   t.y = <span class="hljs-number">0</span>;<br>   t.s = <span class="hljs-string">"FILL(1)\n"</span>;<br>   q.push(t);<br>   <br>   vis[a][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>   t.cnt =<span class="hljs-number">1</span>;<br>   t.x = <span class="hljs-number">0</span>;<br>   t.y = b;<br>   t.s = <span class="hljs-string">"FILL(2)\n"</span>;<br>   vis[<span class="hljs-number">0</span>][b] = <span class="hljs-number">1</span>;<br>   q.push(t);<br></code></pre></td></tr></table></figure><p>当然，两者的区别并不是很大，选择前者更容易理解一些，也更加符合一般的bfs的要求。</p></li><li><p>下面就要进入queue队列的循环中去咯~</p><p>进入循环当然先把front给从队列中打捞出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br></code></pre></td></tr></table></figure><p>这里的t 是借用了上面的t实际上,我们往往是重新node next  的做法往往更普遍一些。</p><p>有了 此次开头的中心点，我们就要赶紧确定什么时候能结束了，万一我们直接就出去了呢哈哈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里有一丝丝的玄机，因为这里采用了break，所以我们在最后bfs返回的是cnt的值，所以我们要将cnt给赋值了，才能return 回去。虽然我们在这里就输出了cnt，但返回的cnt是用来判断我们是否是impossible，如果我们一直没有找到使得题目成立条件，而队列走走完了，那我们就一直没有给cnt赋过值，所以我们自然是返回的是0 那么，就可在main函数中做出特判。</p></li><li><p>接下来就是几种动作的出现，其实就是6种</p><p> FILL(1),FILL(2),DROP(1),DROP(2),POUR(1,2),POUR(2,1) </p><p>我们在对其分别进行情况的判定，然后一一进行就可以了。当然这个过程是艰苦的，如果在一些相似的地方没有思考清楚而是cv的话，容易由于没有看清而出现许多问题。所以奥里给，这一部分需要认真一些。</p><p>对了，我们在前面看到我们既然进行到了这一步，一定是出不去了所以front.cnt++；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp">front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// </span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>最后return cnt;就可以结束这个bfs了。小心，因为代码过长，一处很小的错误可能就会gg。</p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>对，你没有看错，两套代码，中英双文嘿嘿，两种代码其实在一些小的方面有所不同，参考第一个即可，第二个是他人代码（出处已不可寻）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLR(x,y) memset(x,y,sizeof(x))</span><br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> cnt;<br>&#125;;<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">0</span>;<br>    CLR(vis,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; q;<br><br>    node t;<br>    t.cnt=<span class="hljs-number">0</span>;<br>    t.x=<span class="hljs-number">0</span>;<br>    t.y=<span class="hljs-number">0</span>;<br>    t.s=<span class="hljs-string">""</span>;<br>    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front  = q.front();<br>        q.pop();<br>        t = front;<br>        <span class="hljs-keyword">if</span>(front.x ==c||front.y ==c)&#123;<br>            cnt = t.cnt;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-string">"\n"</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;front.s;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        front.cnt ++;<br>        <span class="hljs-comment">//fill</span><br>         t = front;<br>        <span class="hljs-keyword">if</span>((front.x!=a) &amp;&amp; (!vis[a][front.y]))&#123;<span class="hljs-comment">// &lt;?</span><br>            t.x = a;<br>            t.y = front.y;<br>            t.s =front.s + <span class="hljs-string">"FILL(1)\n"</span>;<br>            <br>            q.push(t);<br>            vis[a][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y!=b) &amp;&amp;(!vis[front.x][b]))&#123;<br>            t.x = front.x;<br>            t.y = b;<br>            t.s =front.s + <span class="hljs-string">"FILL(2)\n"</span>;<br>            <br>            q.push(t);<br>            vis[t.x][b] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//pour</span><br>        <span class="hljs-keyword">if</span>((front.x) &amp;&amp; (front.y!=b))&#123;<span class="hljs-comment">//因为我们pour有两种情况，b被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.x&gt;=(b-front.y)&amp;&amp;front.x)&#123;<br>                t.y = b;<br>                t.x = front.x - (b-front.y);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.y = front.y + front.x;<br>                t.x = <span class="hljs-number">0</span>;   <br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(1,2)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y) &amp;&amp; (front.x!=a))&#123;<span class="hljs-comment">//因为我们pour有两种情况，a被倒满或倒不满，所以我们最好放到里面去判断vis</span><br>            <span class="hljs-keyword">if</span>(front.y&gt;=(a-front.x) &amp;&amp; front.y)&#123;<br>                t.y = front.y -(a - front.x); <br>                t.x = a;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                t.x = front.x+ front.y;<br>                t.y = <span class="hljs-number">0</span>;<br>            &#125;<br>                t.s = front.s + <span class="hljs-string">"POUR(2,1)\n"</span>;<br>                <span class="hljs-keyword">if</span>(!vis[t.x][t.y])<br>                <br>                q.push(t);<br>                vis[t.x][t.y] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//drop</span><br>        <span class="hljs-keyword">if</span>((front.x)&amp;&amp;(!vis[<span class="hljs-number">0</span>][front.y]))&#123;<br>            t.x = <span class="hljs-number">0</span>;<br>            t.y = front.y;<br>            t.s = front.s + <span class="hljs-string">"DROP(1)\n"</span>;<br>            vis[<span class="hljs-number">0</span>][t.y] = <span class="hljs-number">1</span>;<br>            <br>            q.push(t);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((front.y)&amp;&amp;(!vis[front.x][<span class="hljs-number">0</span>]))&#123;<br>            t.x = front.x;<span class="hljs-comment">//cv makes me forget it!!!</span><br>            t.y = <span class="hljs-number">0</span>;<br>            t.s = front.s + <span class="hljs-string">"DROP(2)\n"</span>;<br>            vis[t.x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <br>            q.push(t);<br>        &#125;     <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(bfs()==<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"impossible"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//personal code.</span><br><br><span class="hljs-comment">/*<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;math.h&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;map&gt;<br>#include&lt;set&gt;<br>#include&lt;queue&gt;<br>#include&lt;string&gt;<br>#include&lt;iostream&gt;<br>using namespace std;<br>#define CLR(arr,val) memset(arr,val,sizeof(arr))<br><br>int n , m , x;<br>bool vis[200][200];<br>//图上所有点的取值区域可用 a，b的不同的水量状态表示！<br>struct nodes&#123;<br>int x, y;<br>string step;<br>int cnt;<br>&#125;;<br> <br>int bfs() &#123;<br>int cnt = 0;<br>CLR(vis, 0);//init<br>queue&lt;nodes&gt; q;<br>nodes nd1;<br><br>nd1.x = 0;//(init)<br>nd1.y = 0;<br>nd1.cnt = 0;<br>    nd1.step = "";<br>q.push(nd1);<br>vis[0][0]=1;<br><br>while(!q.empty()) &#123;<br>nodes nd = q.front();<br>q.pop();<br>if (nd.x == x || nd.y == x) &#123;// end<br>cnt = nd.cnt;<br>cout&lt;&lt;cnt&lt;&lt;"\n";// it looks like nothing at all. However this cnt is connect to the return value!<br>                            //there is one possible thing is that we could at the last step that we find the right idea!<br>cout&lt;&lt;nd.step;<br>break;<br>&#125;<br>++nd.cnt;// every time the nd will be renew one as front;<br>nodes nd2;//as next<br>nd2.cnt = nd.cnt; <br>if (nd.x &lt; n &amp;&amp; !vis[n][nd.y]) &#123;//if fronter is not full&amp;&amp; not visit the status when it is full<br>nd2.x = n;<br>nd2.y = nd.y;<br>nd2.step = nd.step + "FILL(1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>if (nd.y &lt; m &amp;&amp; !vis[nd.x][m]) &#123;<br>nd2.x = nd.x;<br>nd2.y = m;<br>nd2.step = nd.step + "FILL(2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>if (nd.x &gt; 0 &amp;&amp; nd.y != m) &#123;//when a is not a empty one &amp;&amp; b is not full<br>if (nd.x &gt;= (m - nd.y) &amp;&amp; nd.x != 0) &#123;//if a couldn't pour it's all to b<br>nd2.x = (nd.x - (m - nd.y));// a will pour as more as it could <br>nd2.y = m;<br>&#125; <br>            else &#123;//a could pour all to b<br>nd2.y = (nd.x + nd.y);<br>nd2.x = 0;<br>&#125;<br><br>if (!vis[nd2.x][nd2.y]) &#123;<br>nd2.step = nd.step + "POUR(1,2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>&#125;<br><br>if (nd.y &gt; 0 &amp;&amp; nd.x != n) &#123;//pour b to a<br>if (nd.y &gt;= (n - nd.x) &amp;&amp; nd.y != 0) &#123;<br>nd2.y = (nd.y - (n - nd.x));<br>nd2.x = n;<br>&#125; else &#123;<br><br>nd2.x = (nd.y + nd.x);<br>nd2.y = 0;<br>&#125;<br>if (!vis[nd2.x][nd2.y]) &#123;<br>nd2.step = nd.step + "POUR(2,1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>&#125;<br><br>if (nd.x &gt; 0 &amp;&amp; !vis[0][nd.y]) &#123;//a is not empty<br>nd2.x = 0;<br>nd2.y = nd.y;<br>nd2.step = nd.step + "DROP(1)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br>if (nd.y &gt; 0 &amp;&amp; !vis[nd.x][0]) &#123;<br>nd2.x = nd.x;<br>nd2.y = 0;<br>nd2.step = nd.step + "DROP(2)\n";<br>q.push(nd2);<br>vis[nd2.x][nd2.y] = 1;<br>&#125;<br><br>&#125;<br>return cnt;<br>&#125;<br> <br>int main()<br>&#123;<br>while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;x) &#123;<br>if (bfs() == 0) &#123;<br>cout&lt;&lt;"impossible"&lt;&lt;endl;<br>&#125; <br>&#125;<br>&#125;<br>*/</span><br></code></pre></td></tr></table></figure><p>当然，这道题目还见到有用其他方法去配合bfs进行解题的，</p><p><a href="https://blog.csdn.net/qq_34374664/article/details/53170539" target="_blank" rel="noopener">其他方法之一</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道对于初学BFS而言较复杂的题目，虽然整体上，bfs的方法没有太大的变化，但的确如果想要在初学阶段将其理解，并做出一定的总结，一定会使得这道题目发挥出超其本身的价值和内容。&lt;/p&gt;
&lt;p&gt;此题目：细心，冷静，多思考。&lt;/p&gt;
&lt;p&gt;当然，由于我比较菜，各种错误和疏忽不断出现，所以此题花费了较长的时间，约5h，并在最后的两个小时内参考了他人的代码。。。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="poj bfs" scheme="https://jefine.github.io/tags/poj-bfs/"/>
    
  </entry>
  
  <entry>
    <title>BFS小结</title>
    <link href="https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/"/>
    <id>https://jefine.github.io/2020/07/15/BFS%E5%B0%8F%E7%BB%93/</id>
    <published>2020-07-15T07:52:04.000Z</published>
    <updated>2020-08-10T04:10:40.032Z</updated>
    
    <content type="html"><![CDATA[<p>BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.</p><p>todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）</p>  <a id="more"></a><h2 id="BFS是什么"><a href="#BFS是什么" class="headerlink" title="BFS是什么?"></a>BFS是什么?</h2><blockquote><p> <strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href="https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">图形搜索算法</a>。简单的说，BFS是从<a href="https://zh.wikipedia.org/w/index.php?title=根節點&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">根节点</a>开始，沿着树的宽度遍历树的<a href="https://zh.wikipedia.org/wiki/节点" target="_blank" rel="noopener">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。  (<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">链接</a>)</p></blockquote><h2 id="BFS流程是"><a href="#BFS流程是" class="headerlink" title="BFS流程是?"></a>BFS流程是?</h2><p>从起点出发,将到终点之间将所有的路几乎全部走一遍。</p><p>一般用来寻找最短路程.</p><p>思想上来说是穷举所有的情况,踩遍所有的可能点或找到终点。</p><p>我们通常是这样做的:</p><p>需要: </p><ul><li><p>一个状态所需要的内容作为一个节点。（比如坐标等）</p></li><li><p>一个足够大的位置集合,来表示我们是否来过(可能是二维数组甚至更高维度，也可能是其他的形式，要看具体状态的要求).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> vis[max];<br></code></pre></td></tr></table></figure></li><li><p>一个队列,表示我们即将将队列中的每一个元素作为一个新的起点去重新出发.(queue).</p></li><li><p>一个起点,一个终点.</p></li><li><p>可能需要: 一个记录步数的数组(或其他形式),用来记录是第几步向外，一般放在节点结构里.int step[];</p></li></ul><h4 id="什么时候开始"><a href="#什么时候开始" class="headerlink" title="什么时候开始?"></a>什么时候开始?</h4><p>我们常常从起点开始<del>(废话)</del>, 起点仅仅只有一个点, 我们先将其标记一下,表示我们来过了,然后我们将其加入队列.</p><p>我们将从起点开始的每一个可能可以去的位置,都进行遍历,然后将它们添加到队列中去.</p><p>上面的步骤可以说是每一道题目的必需步骤了,然后我们就要依据题目的条件进行分析咯~</p><h4 id="我们什么时候结束"><a href="#我们什么时候结束" class="headerlink" title="我们什么时候结束?"></a>我们什么时候结束?</h4><p><strong>当队列为空的时候</strong>,何时队列为空呢——当我们踩扁所有的点的时候(不能踩的当然就算了).</p><p>我们依据题目,在地图上的点,并不是每个点都可以踩的,<del>要不然还这么辛苦干么.</del></p><p>那我们就要总结出来: 什么是往下一个点的规律(可以往那里移动?),什么点是不能踩的,约束条件是什么.</p><p>所以,我们往往判断一个点可不可以踩的时候我们要对他有很多的约束条件.</p><p>例如，在二维的地图上，不能越界，不能进入禁止的点，没有来过此点等等。</p><p>例如,小老鼠走迷宫的问题:那么我们就可以根据题目,得到我们小老鼠不能碰的那些点,每次小老鼠可以怎样走动呢?上下左右都可以走,我们就还要判断他们是否出界.进行挑选出那些<strong>从一点可以到该点所能触及的所有不违反规则的点</strong>,别忘了,我们还要判断他们是不是我们要寻找的终点.</p><p>在一层一层的脱离过程中我们会发现还要根据题目要求记下一些东西,往往是所走的路程是多少,那么刚刚提及的最后一个记录步数的数组就可以起效了,我们往往这样使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">step[next] = step[front]+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>因为我们从一点出发往往会经过许许多多的点,然而这些点都是我们一步可以走到的点.不能将他们累加起来作为我们的实际步数.</p><p>宏观上看,我们其实更像是一个池塘中的波纹,每一个波纹有小及大的向外扩散.那么看起来与BFS的算法思想是极为相似的,我们也是从一点抛下一颗小石子,然后等波纹自己寻找到终点(水中的另外一颗小石头的位置).可以想象到我们如果碰触到终点后不停止,那么水波将不断的向远处扩散,知道池塘全部被波及.但我们往往不需要那样做,那样通常是最坏的情况了(也意味着我们要踩所有的可能点呢).</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h4><ol><li>首先将根节点放入队列中。</li><li>从队列中取出第一个节点，并检验它是否为目标。 <ul><li>如果找到目标，则结束搜索并回传结果。</li><li>否则将它所有尚未检验过的直接子节点加入队列中。</li></ul></li><li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li><li>重复步骤2。</li></ol><p>其中重要 的就是我们需要限制的约束条件和下一个位置的可能点.</p><p>当然bfs是一个思想并不拘泥于为某道题目而服务,所以我们往往需要多加练习,在面对求最短路径的时候,才能从容不迫的写出题解.</p><h3 id="需要注意的几个小点点："><a href="#需要注意的几个小点点：" class="headerlink" title="需要注意的几个小点点："></a>需要注意的几个小点点：</h3><ol><li><p>vis是为了防止我们将踩过的点再次踩入</p><p>想象一下，我们水花的方向是四周的一圈，那么也一定会有的向着我们已经走过的路的水波方向，我们要做好辨别工作，那么就给他们加上一个vis的判断。他们的范围就是所有的可能涉及的区域集合。可能通常是数组。</p><p>这样，我们不必花费过多的时间去判断该行为是否会造成逆流，我们只需要进行有效的标注即可！</p><p>杜绝了同样的状态二次出现！</p></li><li><p>我们通常会遇到需要记录层数的时刻，那么最好是使用一个node 里面放上cnt来记录当前节点的层数。</p></li><li><p>我们在对于一个节点进行多个动作时候，需要注意，我们要将其恢复为front的状态，或者更方便一些的，我们直接将其 cnt++；在循环的过程中，我们一直采用front来判断条件或者是对即将入队的节点进行赋值。</p><p>eg：在洛谷1135的题目中我们在队列的循环过程中的front进行变动的做法：而不是对t进行改动。在其他的题目中也经常适用，不要改变t，除非即将入队，判断采用front的+-等进行操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t.cnt = front.cnt+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(CHECK((front.h+high[front.h])))&#123;<br>    t.h = front.h+high[front.h];<br>    vis[t.h] = <span class="hljs-number">1</span>;<br>    q.push(t);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们如果需要记录可以达到多少个点，那么我们在队列中，只要 !vis 我们就可以给他count++；一般是放在动作里面的。如上面的代码情况就放在vis[t.h]=1 下面一行即可。</p></li><li><p>如果我们需要遍历出到每一个点的最短步数，如洛谷p1443，我们最暴力的想法就是给定每一点作为终点，不断地去跑bfs，然而这样是复杂度很高的，完全没有必要这样做，我们既然目标是所有的点，那么我们再 声明一个和vis的范围相同的一个ans数组来记录一个queue的每个点（！vis）的时候的步数即可，未记录的即为无法达到，通过遍历ans数组即可获得相关内容。</p></li><li><p>遇到三维的状态（hdu1204）时，只需要注意输入，接着按照正常的bfs动作流程即可。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;BFS可以说是在搜索中十分常用的基础算法了，在这次的初学中，做一个小结，希望可以将其模块化，系统化，公式化。从而进一步提升对bfs的理解,加快自己的解题步骤, 当然,之后少不了DFS的相关文档咯.&lt;/p&gt;
&lt;p&gt;todo  ：：：：首先我们讨论的是一般的bfs并不考虑a*，贪心等（在后期会持续补充）&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="bfs" scheme="https://jefine.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>输出全组合二进制</title>
    <link href="https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>https://jefine.github.io/2020/07/04/%E8%BE%93%E5%87%BA%E5%85%A8%E7%BB%84%E5%90%88%E4%BA%8C%E8%BF%9B%E5%88%B6/</id>
    <published>2020-07-04T11:48:29.000Z</published>
    <updated>2020-08-10T04:08:57.143Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。</p>  <a id="more"></a><p>首先：辨析一下排列和组合的区别。</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列： </p><script type="math/tex; mode=display">\frac{n!}{(n-k)!}</script><p>组合：</p><script type="math/tex; mode=display">\frac{n!}{(n-k)!*k!}</script><p>可以看出排列的数目<strong>大于等于</strong>组合的数目，以及他们的计算方式如上图。公式来源详见<a href="https://zhuanlan.zhihu.com/p/41855459" target="_blank" rel="noopener">解析链接</a>，这很快帮助你回忆如何计算。</p><hr><p>回归题目：</p><p>n个元素的子集一共有 $2^n$个（从下面的对应关系中的二进制数也可看出的确是$2^n$)</p><p>那么他们此间的对应关系是这样的：</p><script type="math/tex; mode=display">\begin{Vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{Vmatrix}</script><p>这个神奇的的排列规律是我们进行下面编程的理论（可以从二进制看子集与十进制）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n=<span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//解释一下1&lt;&lt;n是位运算，结果是2^n</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&amp; (<span class="hljs-number">1</span>&lt;&lt;j))<span class="hljs-comment">//其中i只在第一次空集的时发挥作用。</span><br>            <br>            <span class="hljs-comment">//这里巧妙地运用了二进制的知识，并且运用位运算的性质，得到结果</span><br>            <br>            <span class="hljs-built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">" "</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>刚开始，觉得这个输出很神奇，直接输出了n个数字的所有集合（还按照一定的顺序），代码还十分简洁。</p><p>其中两个for循环中的if判断可谓是亮点了。</p><p>那么究竟是什么意思呢，记住这里还要会回顾一下那个表格了：</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (<span class="hljs-name">i</span> &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure><p>首先明确一下 <strong>“&amp;”：<em>与</em>， 即在二进制中 </strong>同一为一（取每一位二进制的数字，两者均为1时为1）：</p><p>例如 0001 &amp; 0011为 1；</p><p>​        0010 &amp;  0001为0。</p><p>此行代码中的’ i ‘指的是二进制数中1的个数，可以发现在二进制中第一次i==0，而二进制数中不含1的只有空集，与结果相对应；</p><p>接着我们分析<strong>i==1</strong>时刻，判断条件其实可以替换为（0001 &amp; ( i&lt;&lt;j )),这是说明只有二进制数最后一位为1的才能呵前面$1_{(10)}$或者说$0001_{(2)}$相 “与&amp;” 为真。那么我们可以看出只有1 3  5 7这样的奇数才满足尾数为1，才能使得条件成立。BUT我们分析一下判断条件里的另一个变量1&lt;&lt;j，代表的是$2^n$，也就是说只有j==0的时候，才成立，这也就是第二行结果“0”的来历；</p><p>同理我们可以分析出<strong>i==2</strong>，即二进制的0010的时候只有j==1的时候才成立；</p><p><strong>i==3</strong>的时候，即左边为$0011_{(2)}$的时候这个时候只要是 在最后一位为一或者倒数第二位数字是一的二进制数即可，也就是说 十进制的0，1，3，5，7都可成立。但是 要注意的是 （i&lt;&lt;j)只能为十进制的$2^n$,所含的奇数只有1。所以除0，1外的j均不成立。</p><p>经过上面的分析我们<del>不得不</del>对代码的正确性给予了肯定，但好像还是不太清楚为什么能够这样做。</p><p>那我们不妨回首二进制。</p><p>不难发现，我们最终并没有用到3，4，5，6，7这样的十进制数字（尽管他们在上表中有所对应，但那也不过是各种情况的编号罢了，），只是用了0，1，2这恰好是[0,n)的范围内的数字。大胆推测 只有当i的数字越大那么在j中二进制中的1 出现的概率越大，（tips，$0111_{(2)}$恰好是7，二进制中的1的个数是（2+1）个1 emm~）。例如$7_{(10)}$ 对应$0111_{(2)}$那么他就可以有三个数字的集合成立了（果然是012）</p><p><del>上面一段有点饶头，仔细想想，都是对的，但似乎没什么用~可以无视</del>~~</p><p>自己在不断探索的过程中，仍能够不断的发现二进制的奇妙用途，和神奇1 的对应。此题还需慢慢回味。</p><hr><p>​    数日后，再次回顾此代码，发现有着许多的新的感悟：之前不太明白的地方都一一揭开：</p><p>首先就是</p><script type="math/tex; mode=display">\begin{vmatrix}子集&\emptyset & a_0 & a_1  &a_1,a_0 &a_2 &a_2,a_0 & a_2,a_1 &a_2,a_1,a_0\\二进制数&000 & 001 & 010 & 011 & 100 & 101 & 110 & 111 \\对应的十进制(i)&0 & 1  & 2 & 3 & 4 & 5 & 6 & 7  \\\end{vmatrix}</script><p>哈哈，这个和上图的有什么区别呢？<del>并没有</del>，只是多了一个标识i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &amp; ( <span class="hljs-number">1</span>&lt;&lt;j ) )<br></code></pre></td></tr></table></figure><p>回顾代码：不难看出其实对于作者的行为我<del>们</del>是有一些困惑的。为什么要这样做？</p><p>那我们不妨解释一下i和j的作用好了</p><p><strong>i</strong>  :其实对应的是上表中的对应的十进制：也就是说，我们将i循环了$n^2$次，其实就是恰好我们将这n个子集打印出来。</p><p><strong>j</strong>  :其实是二进制的从低到高位依次赋值1，并判断是否&amp;，1&lt;&lt;j 其实就是 $2^j$ 次方wow，当j为0时其实就是二进制的最后一位为1，j=1时判断倒数第二位是否为1。那么判断的另一个对象是谁呢？当然是i。</p><p>每一个i的二进制都不相同，我们就可以依次利用j来判断该位上是否有数字有的话就把j输出出去，j是[0,n)所以可以利用二进制完美地实现所有子集的输出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一道挺有意思的利用二进制的性质进行打印n个数字（从0到n）的所有组合题目。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>负数二进制（码制与数制）</title>
    <link href="https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/"/>
    <id>https://jefine.github.io/2020/06/28/%E8%B4%9F%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E7%A0%81%E5%88%B6%E4%B8%8E%E6%95%B0%E5%88%B6%EF%BC%89/</id>
    <published>2020-06-28T06:56:31.000Z</published>
    <updated>2020-08-10T04:08:24.735Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和<strong>应用</strong>，后者为重点）</p>  <a id="more"></a><h2 id="二进制的计算"><a href="#二进制的计算" class="headerlink" title="二进制的计算"></a>二进制的计算</h2><p>在此次的课程中在开始便讲述了二进制的计算：</p><p>但其均为正数的时候，计算较为简单和一般的十进制的计算无异（竖式）</p><p>但是当其为负数的时候我们就要多加一个步骤了</p><p>在这里，先补充以下编码：</p><p><strong>编码：</strong></p><p>我们常常将信息通过编码储存起来。</p><blockquote><p>信息编码（Information Coding）是为了方便信息的存储、检索和使用，在进行信息处理时赋予信息元素以代码的过程。即用不同的代码与各种信息中的基本单位组成部分建立一一对应的关系。信息编码必须标准、系统化，设计合理的编码系统是关系信息管理系统生命力的重要因素。</p><p>信息编码的目的　信息编码的目的在于为计算机中的数据与实际处理的信息之间建立联系，提高信息处理的效率。</p></blockquote><p>我们在小学（可能，大雾）的时候，就已经学过如何将十进制和二进制进行相互的转化。</p><p>但是，在当时，出于年纪小，我们并没有学会如何实现负数的运算。</p><p>那么，首先我们康一下：<strong>负数二进制是如何表示的</strong>。</p><p>有人说：在最前添加一bit（一位）：1代表负数，0代表正数。</p><p>那么在计算的时候我们是不是就可以直接去计算了呢？</p><p>并不是这样的我们这样去计算的话就犯下一个错误：</p><p>将<strong>数制和码制混淆。</strong></p><p><strong>数制：</strong>即<strong>计数制，数数的方法。</strong>是指十进制二进制，八进制此类的进制。</p><p><strong>码制</strong>（用编码的方式表示信息<strong>,即用不同数码表示不同事物时遵循的规则。</strong>例如：学号，身份证号，车牌号）:与前者不同的是，码制表示的并不真的只是一个数字，而是一个信息。人们通过编码的方式将他们转化为数字（不同进制均可）。这就涉及到了 信息→数字 的转换。同样不同的编码方式，所得出的结果自然是不同的。所以也可以用来加密。常用的有：BCD，ASCII等。</p><p>目前，数字电路中都采用二进制。</p><ol><li><p>表示数量时称二进制</p></li><li><p>表示事物时称<strong>二值逻辑</strong></p><p>好了，回归正题~</p><hr></li></ol><p>其实按照我们正常的思路我们自己是希望能够按照十进制的方式（竖式）去进行计算的。</p><p>在有了前面的基础之后，我们自己对于码制和数制有了一定的了解。那么我们是不是可以计算负数二进制了呢?</p><p>并不是，首先我们要将负数的二进制标识出来吧。</p><p>假设我们向上面所说的添加一个负号，</p><p>那么是不是我们可以推出呢:</p><script type="math/tex; mode=display">-13_{(10)} = -1101_{(2)}</script><p>To be honest:</p><p>我们很想让它成为这样的但是并不可行。</p><p>这里可以去随意尝试一个例子即可（例如 -13+10）</p><p>我们会发现计算的结果转化为10进制之后是错的。</p><p>为什么呢，<strong>就是码制和数制之间，我们搞混了</strong>。负数的二进制的第一个1是码制，代表的是一个含义：负数，而我们在计算的时候将其作为一个数值进行了计算，自然错误。那么有解决的方法么？</p><p>当然，那么我们应该在哪里修改呢？</p><p>在二级制的负数表达上进行修改！</p><p>事实上，如果我们去计算器（高级计算器）上实行进制转换。我们会发现-13，并不是单纯的将13的二进制前一位添加了一个1，而是添加在最前1之后，将13的<strong>二进制取反，然后将这个二进制+1.</strong></p><p>那么我们怎么去理解这个二进制的意思呢？</p><p>举个例子： </p><script type="math/tex; mode=display">-13_{(10)} = 10011_{(2)}</script><p>是指 第一个数字作为 负数，其余仍为正数：</p><script type="math/tex; mode=display">\begin{array}{cc} 1&0&0& 1& 1 \\ -16*1&8*0&4*0&2*1&1*1\\\end{array}</script><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>二进制的负数的运算既在我们的意料之中，又在我们的意料之外。惊喜连连~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要讲述了模拟电路和数字电路的区别，以及数字电路的侧重点（分为电子元件的原理和&lt;strong&gt;应用&lt;/strong&gt;，后者为重点）&lt;/p&gt;</summary>
    
    
    
    <category term="数字电路" scheme="https://jefine.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="二进制" scheme="https://jefine.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hdu1237计算器</title>
    <link href="https://jefine.github.io/2020/06/07/hdu1237%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://jefine.github.io/2020/06/07/hdu1237%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2020-06-07T02:26:22.000Z</published>
    <updated>2020-08-10T04:10:45.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1237" target="_blank" rel="noopener">简单计算器</a></h1>  <a id="more"></a><p>Time Limit: 2000/1000 MS (Java/Others)  Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 36334  Accepted Submission(s): 13065</p><p>Problem Description</p><p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。</p><p>Input</p><p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p><p>Output</p><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><p>Sample Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>+ <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span>+ <span class="hljs-number">2</span> * <span class="hljs-number">5</span> - <span class="hljs-number">7</span> / <span class="hljs-number">11</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3.00</span><br><span class="hljs-number">13.36</span><br></code></pre></td></tr></table></figure><p>Source</p><p> <a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%D5%E3%B4%F3%BC%C6%CB%E3%BB%FA%D1%D0%BE%BF%C9%FA%B8%B4%CA%D4%C9%CF%BB%FA%BF%BC%CA%D4-2006%C4%EA&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 浙大计算机研究生复试上机考试-2006年 </a> </p><p>解题思路：</p><p>主要是采取了两个栈来保存操作符和运算数字。</p><p>另外：亮点在于P(c) &lt; P(op.top())这里的优先级比较：</p><p>我们可以发现通过表格或者其他的形式可以看出在运算优先级的问题上，我们只有采取这样的策略才是最好的。</p><p>当前的优先级高那么压入栈，当前优先级和栈顶（上次的）的优先级相同，或小于上次的话，自然时先算上次的，同时这样的模拟也是最符合我们自己的真实的运算过程的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Ans</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">char</span> c)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) <span class="hljs-keyword">return</span> x + y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> x - y;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'*'</span>)<span class="hljs-keyword">return</span> x*y;<br>    <span class="hljs-keyword">return</span> x / y;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))<br>    &#123;<br>        <span class="hljs-keyword">char</span> c = getchar();<br>        <span class="hljs-keyword">if</span> (c==<span class="hljs-string">'\n'</span>&amp;&amp;n == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; op;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">double</span>&gt;num;<br>        num.push(n);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<span class="hljs-comment">//开始一行的运算，之前已经获取了一个n，并压入num；</span><br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c %d"</span>, &amp;c, &amp;n);<br>            <span class="hljs-keyword">char</span> k = getchar();<br>            <span class="hljs-keyword">while</span> (!op.empty()&amp;&amp;P(c)&lt;=P(op.top()))<span class="hljs-comment">//第一次会跳过</span><br>            <span class="hljs-comment">//当操作符的栈不为空……且现在的操作符优先级小于或等于栈顶的的操作符的优先级时</span><br>            <span class="hljs-comment">//那么先将之前的进行计算</span><br>            &#123;<br>                <span class="hljs-keyword">char</span> t = op.top();<br>                op.pop();<br>                <span class="hljs-keyword">double</span> y = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> x = num.top();<br>                num.pop();<br>                <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>                num.push(ans);<br>            &#125;<br>            op.push(c);<br>            num.push(n);<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//这导致了上面还有压入的数字和操作符未被操作，便有了下面的判断op栈</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (!op.empty())<br>        &#123;<br>            <span class="hljs-keyword">char</span> t = op.top();<br>            op.pop();<br>            <span class="hljs-keyword">double</span> y = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> x = num.top();<br>            num.pop();<br>            <span class="hljs-keyword">double</span> ans = Ans(x, y, t);<br>            num.push(ans);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>, num.top());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简单计算器&quot;&gt;&lt;a href=&quot;#简单计算器&quot; class=&quot;headerlink&quot; title=&quot;简单计算器&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1237&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简单计算器&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="hdu 栈" scheme="https://jefine.github.io/tags/hdu-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>pta六度空间</title>
    <link href="https://jefine.github.io/2020/06/04/pta%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <id>https://jefine.github.io/2020/06/04/pta%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</id>
    <published>2020-06-04T13:32:34.000Z</published>
    <updated>2020-08-10T04:11:01.389Z</updated>
    
    <content type="html"><![CDATA[<p>“<a href="http://pta.patest.cn/pta/test/15/exam/4/question/715" target="_blank" rel="noopener">六度空间</a>”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。</p>  <a id="more"></a><p><img src="https://images.ptausercontent.com/35" alt="t"></p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><p><strong>输入格式说明：</strong></p><p>输入第1行给出两个正整数，分别表示社交网络图的结点数N （1&lt;N&lt;=104，表示人数）、边数M（&lt;=33*N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p><p><strong>输出格式说明：</strong></p><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>: <span class="hljs-number">70.00</span>%<br><span class="hljs-number">2</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">3</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">4</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">5</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">6</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">7</span>: <span class="hljs-number">100.00</span>%<br><span class="hljs-number">8</span>: <span class="hljs-number">90.00</span>%<br><span class="hljs-number">9</span>: <span class="hljs-number">80.00</span>%<br><span class="hljs-number">10</span>: <span class="hljs-number">70.00</span>%<br></code></pre></td></tr></table></figure><h3 id="一点理解："><a href="#一点理解：" class="headerlink" title="一点理解："></a>一点理解：</h3><p>时隔一个多月，再次做到此题目，发现并不会写了（<del>并不是</del>),甚至原来的题解，也不会写了，回想起来，自己还写过题解，特此更新。。。发现原来写的题解具有一定的局限性，并不是十分好理解，所以特此更新呢。</p><p>以下为原题解：</p><p>乍一看题目所求有些懵，其实所求的是每个节点相邻的6层之内的节点个数与总结点的比例；</p><p>那么我们只需要求出每个节点的相邻六层的节点的个数（bfs）</p><p>在bfs中我们还需要注意一下，我们在统计个数的时候还有记得数层数，够了层数就不再去数数了。</p><p>所以引申出来层数的判断，那么如何确定到那一层了呢？</p><p>采用的就是tail和last的不断更新（详见代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10005</span>;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[maxn];<br><span class="hljs-keyword">int</span> vertices, edges;<span class="hljs-comment">//所有的顶点数和边数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;i++)&#123;<br>        vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//init vis[]</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> tail;<br>    <span class="hljs-keyword">int</span> last = v;<span class="hljs-comment">//指的是每一圈的最后一个（每一个外圈的的每一个顶点都要入队，当该外圈的最后一个也出队了，那么这一层也循环完了</span><br>    <span class="hljs-keyword">int</span> count =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;<br>    vis[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    q.push(v);<br><br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        <span class="hljs-keyword">int</span> x = q.front();<span class="hljs-comment">//get the first每一圈的每一个顶点</span><br>        q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;g[x].size();j++)&#123;<span class="hljs-comment">//判断条件是与x相连的所有顶点的个数</span><br>            <span class="hljs-keyword">if</span>(!vis[g[x][j]])&#123;<br>                vis[g[x][j]] = <span class="hljs-literal">true</span>;<br>                q.push(g[x][j]);<br>                tail = g[x][j];<span class="hljs-comment">//每次都将替换更新，最后得到的是该节点的最后一个相连顶点</span><br>                count++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span>(x==last)&#123;<br>            <span class="hljs-comment">/*这里指的是我们将该层全部弹出时应所满足的条件<br>            注意第一次的时候是直接成立的<br>            而在第二圈（或更多）的时候，我们将<br>            第一个节点的最后一个遍历的节点作为tail<br>            然后他就成为了last即上一层的最后一个元素<br>            */</span><br>            last = tail;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(level==<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>         &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        g[x].push_back(y);<span class="hljs-comment">//建立两者之间边的关系</span><br>        g[y].push_back(x);<span class="hljs-comment">//认识是相互的，所以相互加关联</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>下面是一个月后经过了几道bfs题目熏陶后的想法:</p><p>首先读题，发现题目要求我们输出比例，显然总结点数已经给出，那么得到每一个节点的6层以内的节点数即可。</p><p>接着题目有给定了节点之间的关系，所以我们自己可以通过一个bool类型的rel(relative)的二维数组来确定两者的关系是否连通。（这一步可以在main函数中实现）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;vertices&gt;&gt;edges;<br>    <br>    <span class="hljs-built_in">memset</span>(ral,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(ral));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=edges;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>        ral[x][y]=<span class="hljs-number">1</span>;<br>        ral[y][x]=<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来，我们就要把他传入bfs中了，然后使得bfs返回该节点符合关系的节点数目即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=vertices;j++)&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: %.2f%%\n"</span>,j,BFS(j)*<span class="hljs-number">1.0</span>/vertices*<span class="hljs-number">100.0</span>);<br></code></pre></td></tr></table></figure><p>在bfs 的函数中，我们很显然，起点就是我们给定的j，j即为起始点，由<strong>他出发寻找到在六层内不同的节点的个数。</strong></p><p>从这个任务中我们也可得出一个状态的内容是它自身的节点名称（在此题目中是一个int值）还要有一个cnt来表示层数，方便我们作为层数的限制条件，这在其他的bfs题目中，层数亦十分有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> cnt;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure><p>哦，我们不能忘我们刚刚给的要求了，不同的节点，相同的节点找他干嘛。。。所以还要有一个vis的一维数组，范围是所有节点数量，表示他们是否被访问过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-comment">//是否被访问过</span><br><span class="hljs-keyword">bool</span> ral[maxn][maxn];<br></code></pre></td></tr></table></figure><p>那么bfs的结束条件是？队列结束或者达到节点6层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><br><span class="hljs-comment">//返回该顶点在6度空间里的能接触到的顶点个数</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>    <span class="hljs-built_in">queue</span>&lt;node&gt;q;<br>    vis[v]=<span class="hljs-number">1</span>;<br>    node t;<br>    t.cnt = <span class="hljs-number">1</span>;<br>    t.val = v;<br>    q.push(t);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        node front = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(front.cnt&gt;<span class="hljs-number">6</span>)<span class="hljs-keyword">break</span>;<br>        t.cnt = front.cnt+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=vertices;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ral[front.val][i]&amp;&amp;!vis[i])&#123;<br>                vis[i]=<span class="hljs-number">1</span>;<br>                count++;<br>                t.val = i; <br>                q.push(t);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>bfs里面的cnt&gt;或是&gt;=我是猜的，可以通过数据检验，稍微改改就凑上了。。省得麻烦考虑了，不过最好还是考虑周全。</p><p>在这里val的数据范围是[n] [n]或者说直接定义1001（因为题目给定的数据n&lt;=10^3)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“&lt;a href=&quot;http://pta.patest.cn/pta/test/15/exam/4/question/715&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;六度空间&lt;/a&gt;”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="pta" scheme="https://jefine.github.io/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>pta拯救007</title>
    <link href="https://jefine.github.io/2020/06/03/pta%E6%8B%AF%E6%95%91007/"/>
    <id>https://jefine.github.io/2020/06/03/pta%E6%8B%AF%E6%95%91007/</id>
    <published>2020-06-03T11:57:38.000Z</published>
    <updated>2020-08-10T04:11:47.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目详情："><a href="#题目详情：" class="headerlink" title="题目详情："></a>题目详情：</h2><p>在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）<br>设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。</p>  <a id="more"></a><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>首先第一行给出两个正整数：鳄鱼数量 N（≤100）和007一次能跳跃的最大距离 D。随后 N 行，每行给出一条鳄鱼的 (x,y) 坐标。注意：不会有两条鳄鱼待在同一个点上。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>如果007有可能逃脱，就在一行中输出”Yes”，否则输出”No”。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><p>14 20<br>25 -15<br>-25 28<br>8 49<br>29 15<br>-35 -2<br>5 28<br>27 -29<br>-8 -28<br>-20 -35<br>-25 -20<br>-13 29<br>-30 15<br>-35 40<br>12 12</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><p>Yes</p><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><p>4 13<br>-12 12<br>12 12<br>-12 -12<br>12 -12</p><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><p>No</p><h3 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h3><p>这道题目的解题中使用到了dfs和图的相关知识，</p><p>p[]是所输入的每个节点的数组（鳄鱼的集合）</p><p>vis[]是判断是否该节点被访问：</p><p>如果被访问过了，那么只有两种情况：1.找到出口，直接弹出（break）。2.没有出口~</p><p>所以如果节点被访问过，就意味着该节点不是出口。</p><p>另外注意我们还有对于第一次的中心岛的特殊判断，他的距离与其他的dfs过程不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,d;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>//定义节点（存储<span class="hljs-title">x</span>，<span class="hljs-title">y</span>坐标）<br>&#123;</span> <br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;p[<span class="hljs-number">110</span>];  <br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<br><span class="hljs-keyword">bool</span> flag =<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">first</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断该节点是否可以在第一次可以跳出中心岛（即判断该点是否在第一次跳出的半径内）</span><br>    <span class="hljs-keyword">return</span>(p[i].x*p[i].x+p[i].y*p[i].y &lt;= (d+<span class="hljs-number">7.5</span>)*(d+<span class="hljs-number">7.5</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">success</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//判断能否在该结点处一次直接跳出（d&gt;0），分别判断x，y是否可以跳出边界(即能否一步上岸)</span><br>    <span class="hljs-keyword">return</span> p[i].x-d&lt;=<span class="hljs-number">-50</span>||p[i].x+d&gt;=<span class="hljs-number">50</span>||p[i].y+d&gt;=<span class="hljs-number">50</span>||p[i].y-d&lt;=<span class="hljs-number">-50</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<span class="hljs-comment">//判断是否可以从一点跳到另一点</span><br>    <span class="hljs-keyword">return</span> (p[i].x*p[i].x+p[i].y*p[i].y)&lt;d*d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//递归，dfs判断是否可以找到出去的路</span><br>    vis[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//表示已经访问该节点</span><br>    <span class="hljs-keyword">if</span>(success(i))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-comment">//遍历寻找节点</span><br>        <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;isJump(i,j))<br>        &#123;<span class="hljs-comment">//如果该点访问过，那么此路就代表不通，应该放弃这个点；同时我们还要找到可以跳跃过去的点。</span><br>        <span class="hljs-keyword">if</span>(dfs(j))<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;d;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d&gt;=<span class="hljs-number">42.5</span>)flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//应该通过遍历找到符合条件的节点</span><br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;first(i))<span class="hljs-comment">//如果没有访问过这个节点，且在第一次跳出的半径内。</span><br>                <span class="hljs-keyword">if</span>(dfs(i))&#123;<br>                    flag =<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出并不再寻找</span><br>                &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"yes"</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"no"</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目详情：&quot;&gt;&lt;a href=&quot;#题目详情：&quot; class=&quot;headerlink&quot; title=&quot;题目详情：&quot;&gt;&lt;/a&gt;题目详情：&lt;/h2&gt;&lt;p&gt;在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）&lt;br&gt;设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="pta" scheme="https://jefine.github.io/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>阿里云-身份证识别调用</title>
    <link href="https://jefine.github.io/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/"/>
    <id>https://jefine.github.io/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-17T09:54:27.000Z</published>
    <updated>2020-08-10T04:07:57.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>首先，这里选用的sdk是java（支持本地上传版本）和python</p><p>阿里云的sdk最好是通过maven来导入，而且在<strong>使用maven的时候注意将镜像设置为阿里云</strong>，否则会很慢。</p>  <a id="more"></a><h4 id="AccessKey"><a href="#AccessKey" class="headerlink" title="AccessKey"></a>AccessKey</h4><p>记得在阿里云上申请（目前免费）accessKey 及密码。</p><p>并将其放在application. properties 处</p><h4 id="在线测试"><a href="#在线测试" class="headerlink" title="在线测试"></a><a href="https://help.aliyun.com/document_detail/151899.html?spm=a2c4g.11186623.6.603.46ba4dd3pI0g28" target="_blank" rel="noopener">在线测试</a></h4><p>发现可以在线测试呀！！！而且可以使用临时生成的accesskey自动进行，wow!</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/onlineTest.png" alt="onlineTest"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><del>并不会！（嘤嘤嘤）</del>（勉强会一点点的python（借助样例））</p><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><p>参考了一份（java嘿嘿）</p><p>主要需要编写的有：</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pic.png" alt="pic"></p><h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><p>首先需要使用 <code>pip install aliyun-python-sdk-core</code>  命令，安装阿里云SDK核心库 。</p><p>然后执行下载文字识别包：<code>pip install aliyun-python-sdk-ocr</code> </p><p>新建.py文件见下列代码cv，然后将自己的ak填入即可。之后在url的地方图片的链接（仅支持阿里云的oss，代码中给出了一个示例，可以使用）</p><p>下面的set_Side就是正反面</p><p>运行即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> aliyunsdkcore.client <span class="hljs-keyword">import</span> AcsClient<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ClientException<br><span class="hljs-keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="hljs-keyword">import</span> ServerException<br><span class="hljs-keyword">from</span> aliyunsdkocr.request.v20191230.RecognizeIdentityCardRequest <span class="hljs-keyword">import</span> RecognizeIdentityCardRequest<br><br>client = AcsClient(<span class="hljs-string">'&lt;accessKeyId&gt;'</span>, <span class="hljs-string">'&lt;accessSecret&gt;'</span>, <span class="hljs-string">'cn-shanghai'</span>)<br><br>request = RecognizeIdentityCardRequest()<br>request.set_accept_format(<span class="hljs-string">'json'</span>)<br><br>request.set_ImageURL(<span class="hljs-string">"http://explorer-image.oss-cn-shanghai.aliyuncs.com/1786373016143448/index.jpg?OSSAccessKeyId=LTAI4Fk9FstqSEYnqKJ5Dpeo&amp;Expires=1589709652&amp;Signature=wdCT6OMdBw2mvOdvVecgkDWtqcI%3D"</span>)<br>request.set_Side(<span class="hljs-string">"face"</span>)<br><br>response = client.do_action_with_exception(request)<br><span class="hljs-comment"># python2:  print(response) </span><br>print(str(response, encoding=<span class="hljs-string">'utf-8'</span>))<br></code></pre></td></tr></table></figure><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/pyresult.png" alt="pyresult"></p><p>上图是python的测试结果。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试图片（图源网络）</p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/images.jpg" alt="images"></p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/index.jpg" alt="index"></p><p><img src="/2020/05/17/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E8%B0%83%E7%94%A8/result.png" alt="result"></p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>基本符号要求。（总算成功了）</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>基于阿里云开放平台我们可以便捷使用的工具还有很多很多， 包括人脸人体、文字识别、商品理解、内容安全、图像识别、图像生产、分割抠图、视觉搜索、目标检测、图像分析处理、视频理解、视频生产、视频分割13个类目 ，日后便去完成！</p>]]></content>
    
    
    <summary type="html">&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h4&gt;&lt;p&gt;首先，这里选用的sdk是java（支持本地上传版本）和python&lt;/p&gt;
&lt;p&gt;阿里云的sdk最好是通过maven来导入，而且在&lt;strong&gt;使用maven的时候注意将镜像设置为阿里云&lt;/strong&gt;，否则会很慢。&lt;/p&gt;</summary>
    
    
    
    <category term="justForFun" scheme="https://jefine.github.io/categories/justForFun/"/>
    
    
    <category term="cloud" scheme="https://jefine.github.io/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>大数乘法</title>
    <link href="https://jefine.github.io/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>https://jefine.github.io/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/</id>
    <published>2020-04-30T10:07:52.000Z</published>
    <updated>2020-08-10T04:08:12.841Z</updated>
    
    <content type="html"><![CDATA[<p><em>使用java语言的int数组与StringBuffer来实现</em>。</p><p>日常中，我们使用java来计算两数乘法时，我们会在遇到一些比较大的数字计算时，便无可奈何(int不够大)，这时一般采用<strong>BigInteger</strong>的方法进行计算，但是该方法也有一定的限制，或者说，我们是可以去尝试去使用String来实现和表示大数乘法的效果。</p>  <a id="more"></a><h2 id="编程思路："><a href="#编程思路：" class="headerlink" title="编程思路："></a>编程思路：</h2><p>首先我们要确定使用字符串后我们如何去实现我们的乘法计算，不妨我们回归竖式计算，进行模拟然后得出结果。</p><p>例如：37*46的计算过程，我们也可以这样计算：如下图。</p><ol><li><p><strong>先不考虑进位的问题</strong>，将两个<strong>数字</strong>相乘的结果当作一个个位数（不去进行进位，最后再依次进位，方便计算机操作，当然，方法多样，并不局限于此）</p><p><img src="/2020/04/30/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/multiplyExample.png" alt></p></li><li><p>我们也可以发现上述规律a位数*b位数≤（a+b）位数</p><p>所以我们如果需要得到最后的位数的话，可以通过这个规律进行计算。</p></li></ol><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先，我们采用由俭入繁的理念：从简单的开始，再到复杂：</p><ol><li><p>我们考虑的是两个正整数的大数乘法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了，直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>好的计算成功，那么如果有负数存在呢？</p><p>我们只需要加上如下的判断符号的代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br></code></pre></td></tr></table></figure></li></ol><p>完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法(有符号）</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最后：bugs："><a href="#最后：bugs：" class="headerlink" title="最后：bugs："></a>最后：bugs：</h2><p>在初步形成之后，还是有一些bug的比如乘数中含有0，那么就会报错。</p><p>所以要排除这一情况。（在判断符号前加入一个判断0即可）</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//大数乘法</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String a = sc.nextLine();<br>String b = sc.nextLine();<br>System.out.print(a+<span class="hljs-string">" * "</span>+b+<span class="hljs-string">" = "</span>);<br><span class="hljs-comment">//判断0</span><br><span class="hljs-keyword">if</span>(a.equals(<span class="hljs-string">"0"</span>)||b.equals(<span class="hljs-string">"0"</span>))System.out.println(<span class="hljs-string">"0"</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//判断符号</span><br>Boolean flag = <span class="hljs-keyword">true</span>; <br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>)<br>&#123;<br>a = a.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">'-'</span>&amp;&amp;b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'-'</span>)<br>&#123;<br>b = b.substring(<span class="hljs-number">1</span>);<br>flag =  <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(!flag)System.out.print(<span class="hljs-string">"-"</span>);<br><br><span class="hljs-comment">//注意：这里直接将数字计算后的结果相加起来了直接得到最后一行</span><br><span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[b.length()+a.length()];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = a.length()-<span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br><span class="hljs-keyword">int</span> t = (b.charAt(i)-<span class="hljs-string">'0'</span>)*(a.charAt(k)-<span class="hljs-string">'0'</span>);<br>s[s.length-<span class="hljs-number">1</span>-(a.length()-<span class="hljs-number">1</span>-k+(b.length()-<span class="hljs-number">1</span>-i))] += t;<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位计算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>s[i-<span class="hljs-number">1</span>] +=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空前置零（int转向StringBuffer的时候可能会多0)，并使用字符串表示出答案</span><br>StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : s) &#123;<br>ans.append(i);<br>&#125;<br><span class="hljs-keyword">while</span>(ans.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">'0'</span>)&#123;<br>ans.deleteCharAt(<span class="hljs-number">0</span>);<br>&#125;<br>System.out.println(ans);<br>sc.close();<br>&#125;<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;使用java语言的int数组与StringBuffer来实现&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;日常中，我们使用java来计算两数乘法时，我们会在遇到一些比较大的数字计算时，便无可奈何(int不够大)，这时一般采用&lt;strong&gt;BigInteger&lt;/strong&gt;的方法进行计算，但是该方法也有一定的限制，或者说，我们是可以去尝试去使用String来实现和表示大数乘法的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
    <category term="编程" scheme="https://jefine.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java中各种类的跳转例题分析</title>
    <link href="https://jefine.github.io/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://jefine.github.io/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2020-04-01T08:46:55.000Z</published>
    <updated>2020-04-01T10:02:04.084Z</updated>
    
    <content type="html"><![CDATA[<p>在学习java的继承的过程中遇到这样的一个分析类题目，比较有意思，在这里做出简要分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请写出以下程序运行结果：</span><br><br><span class="hljs-keyword">package</span> test;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.show(<span class="hljs-keyword">new</span> Car()&#123;<br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">"test run"</span>);           <br>         &#125;<br>      &#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Car c)</span></span>&#123;<br>      c.run();<br>      c.show();<br>&#125;&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">"car run"</span>);     <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(getClass().getName());<br>&#125;&#125;<br></code></pre></td></tr></table></figure><p> 那么，我们可以通过断点的分析：</p><ol><li><p>首先。我们从main函数进入，发现他创建了Test类的一个对象t；</p><p>我们在test类中并没有寻找到Test类的构造函数，所以应该是系统默认的构造器，不进行任何的行为；</p></li><li><p>之后，我们注意一下这一步，首先是t.show（）方法，在Test的类中有这么一个方法，不过我们看到show方法是需要传入一个car类的对象，所以他new了一个car对象，离奇的是car对象后面接着一对大括号。</p></li><li><p>注意到：这里有一个匿名类，用来一次性使用的创建car对象。这样抽象类car才能被以匿名类中的内容实例化。这样，我们就完成了对car类的实例化，得到了一个car类的对象。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401173415543.png" alt="image-20200401173415543"></p></li><li><p>接着，我们以那个新new的对象作为参数，调用了Test类中的show方法。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174104233.png" alt="image-20200401174104233"></p><p>而show方法的第一条语句是c.show();注意到我们是通过匿名类创建的对象，而我们是通过匿名类中的重新写的run（）方法，所以他又跳回了第六行，输出“test run”；</p></li></ol><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174405627.png" alt="image-20200401174405627"></p><ol><li><p>好的，接下来我们又回到了show方法中，继续调用c.show(),这时，我们回头看匿名类，它里面竟然没有show的方法。。。所以他就只能调用car类的show（）方法。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174506855.png" alt="image-20200401174506855"></p></li></ol><ol><li><p>注意到了右侧返回的getName()是”test.Test$1”，好吧，test是包名，Test是类名，可以理解！</p><p>但是$1就使得不少同学迷惑了。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401174856777.png" alt="image-20200401174856777"> </p></li><li><p>好的，我们这次打开文件管理系统，找到我们编译的文件所在，发现.java编译后多出了Test$1.class的文件，这个.class是怎么来的呢？对了是匿名类！这里的Test$1这个类名是编译器给它的名字（匿名类没有名字，但是java编译器要给他起个名，才好分辨）而命名的格式就是第一个Test类下面的匿名类的话就叫$1,第二个就是$2。</p><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401175322331.png" alt="image-20200401175322331"></p></li></ol><p><img src="/2020/04/01/java%E4%B8%AD%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E8%B7%B3%E8%BD%AC%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/image-20200401180024806.png" alt="image-20200401175322331"></p><p>这样就可以了，程序就结束了！主要涉及了匿名成员类。大家有兴趣（最好可以了解一下）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习java的继承的过程中遇到这样的一个分析类题目，比较有意思，在这里做出简要分析：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
    <category term="class" scheme="https://jefine.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>一元多次多项式的加减</title>
    <link href="https://jefine.github.io/2020/03/26/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F/"/>
    <id>https://jefine.github.io/2020/03/26/%E4%B8%80%E5%85%83%E5%A4%9A%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F/</id>
    <published>2020-03-26T14:00:11.000Z</published>
    <updated>2020-08-10T04:09:17.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一元多项式的加减法"><a href="#一元多项式的加减法" class="headerlink" title="一元多项式的加减法"></a>一元多项式的加减法</h1><p>tips: 三月份写过这个题解，当时确实解决了当时问题，但是方法是错的，两个月后，又做类似的题目，只是将指数由大到小的排列便错了，那么我就不（敢）再误人子弟，便删去旧的题解，写新的题解。这一次经历了两天来研究指针的问题，可以说，过程比较令人头大，但是对指针的了解也更多了一些。功不唐捐！</p><p>在学习链表的过程中，了解到可以使用链表的方式来实现一元多项式的加减（还打算实现乘法和除法，但是技术有限，一时不一会写，哈哈，以后或许会悄悄更新吧）</p>  <a id="more"></a><h2 id="如何获取到两个一元多项式"><a href="#如何获取到两个一元多项式" class="headerlink" title="如何获取到两个一元多项式"></a>如何获取到两个一元多项式</h2><p>我们可以使用到首先明确一共有多少项，输入数据应该如下示例：<br>如果希望输入的多项式是：x+2x^2+3x^3<br>那么输入的数据应该是： 3 1 1 2 2 3 3<br>第一个输入一共多少项，之后我们可以依次输入每项的底数和次方。</p><h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><p>自然是使用链表咯！</p><h2 id="代码里面见分析！"><a href="#代码里面见分析！" class="headerlink" title="代码里面见分析！"></a>代码里面见分析！</h2><p>精华应该是在于对于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br><span class="hljs-keyword">int</span> coef;<br><span class="hljs-keyword">int</span> index;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;node;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">int</span> coef;<br><span class="hljs-keyword">int</span> index;<br>node* head1 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>node* headfirst = head1;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>head1-&gt;next = t;<br>head1 = head1-&gt;next;<br>&#125;<br>head1-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br>node* head2 = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>node* headsecond = head2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>node* t = (node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;coef;<br><span class="hljs-built_in">cin</span>&gt;&gt;t-&gt;index;<br>head2-&gt;next = t;<br>head2 = head2-&gt;next;<br>&#125;<br>head2-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><br><br><span class="hljs-comment">//start  </span><br>Node* tail = headfirst;<br>Node* p = headfirst-&gt;next;<br>Node* q = headsecond-&gt;next;<br>Node* t = headfirst;<span class="hljs-comment">//as the result</span><br><span class="hljs-keyword">while</span>(q&amp;&amp;p)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;index &gt; q-&gt;index)&#123;<br>tail = p;<br>p= p-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;index &lt; q-&gt;index)&#123;<br>tail-&gt;next = q;<br>tail = q;<br>q = q-&gt;next; <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;coef + q-&gt;coef==<span class="hljs-number">0</span>)&#123;<br>tail-&gt;next = p-&gt;next;<br>Node* temp = p;<br>p = p-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>temp = q;<br>q= q-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//coef之和不为0，index相等时 </span><br>p-&gt;coef = p-&gt;coef + q-&gt;coef;<br>tail -&gt;next = p;<br>p = p-&gt;next;<br>Node* temp = q;<br>q = q-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>&#125;<br>&#125;<br>&#125;<br>    t = t-&gt;next;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-keyword">if</span>(t!=headfirst-&gt;next&amp;&amp;t-&gt;coef&gt;<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"+"</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;t-&gt;coef&lt;&lt;<span class="hljs-string">"x"</span>;<br><span class="hljs-keyword">if</span>(t-&gt;index!=<span class="hljs-number">1</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"^"</span>&lt;&lt;t-&gt;index;<br>t = t-&gt;next;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一元多项式的加减法&quot;&gt;&lt;a href=&quot;#一元多项式的加减法&quot; class=&quot;headerlink&quot; title=&quot;一元多项式的加减法&quot;&gt;&lt;/a&gt;一元多项式的加减法&lt;/h1&gt;&lt;p&gt;tips: 三月份写过这个题解，当时确实解决了当时问题，但是方法是错的，两个月后，又做类似的题目，只是将指数由大到小的排列便错了，那么我就不（敢）再误人子弟，便删去旧的题解，写新的题解。这一次经历了两天来研究指针的问题，可以说，过程比较令人头大，但是对指针的了解也更多了一些。功不唐捐！&lt;/p&gt;
&lt;p&gt;在学习链表的过程中，了解到可以使用链表的方式来实现一元多项式的加减（还打算实现乘法和除法，但是技术有限，一时不一会写，哈哈，以后或许会悄悄更新吧）&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构基础" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="链表" scheme="https://jefine.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>p1086花生采摘</title>
    <link href="https://jefine.github.io/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/"/>
    <id>https://jefine.github.io/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/</id>
    <published>2020-03-21T08:58:48.000Z</published>
    <updated>2020-03-21T10:34:00.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。</p><p>鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图111）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”</p><p><img src="/2020/03/21/p1086%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98/1182.png" alt></p><p>我们假定多多在每个单位时间内，可以做下列四件事情中的一件：</p><ol><li>从路边跳到最靠近路边（即第一行）的某棵花生植株；</li><li>从一棵植株跳到前后左右与之相邻的另一棵植株</li><li>采摘一棵植株下的花生：</li><li>从最靠近路边（即第一行）的某棵花生植株跳回路边</li></ol><p>现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。</p><p>例如在图2所示的花生田里，只有位于(2,5),(3,7),(4,2),(5,4)的植株下长有花生，个数分别为13,7,15,9。沿着图示的路线，多多在21个单位时间内，最多可以采到37个花生。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括三个整数，M,N和K，用空格隔开；表示花生田的大小为MN（1≤M,N≤20），多多采花生的限定时间为K（0≤K≤1000）个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i+1行的第j个整数Pij（0≤Pij≤500）表示花生田里植株（i,j）下花生的数目，0表示该植株下没有花生。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即在限定时间内，多多最多可以采到花生的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong> </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">37</span><br></code></pre></td></tr></table></figure><p><strong>输入 #2</strong> </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">15</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出 #2</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>刚开始急匆匆地一看题目（然后就陷入了一阵思考：“如何在有限的时间内拿到最多的花生呢？”哎，每个花生的个数还不一样，也就是先后顺序什么的都要去更改哎，动态规划？<del>（可是其实我不会动态规划哈哈）</del>那么怎么办呢，哎呦，然后发现了一个问题，这是一道普及题目那么不会那么难的吧？！</p><p>又重新审题后，发现我原来看错题目了！在那段极长的唠叨中，<strong>它规定的摘取顺序是按照从大到小的顺序区去采摘，</strong>而不是向我之前所想的那样，这样一来就大大简化了自己的步骤。</p><p>之后一开始打算使用一个二维数组来储存但是发现不太对，想起来结构体于是；</p><p>有了思路，使用一个结构体来储存自己的x，y，和花生的个数；然后排序，从大到小但是要记住判断下一次是不是采摘完还能回去哈哈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hua</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> num;<br>&#125;h;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(h a,h b)</span></span>&#123;    <br>        <span class="hljs-keyword">return</span>  a.num &gt; b.num; <br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m,n,k,cnt=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>,real=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;k;<br>    h a[m*n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        a[cnt].x = i;<br>        a[cnt].y = j;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[cnt++].num; <br><span class="hljs-keyword">if</span>(a[cnt<span class="hljs-number">-1</span>].num!=<span class="hljs-number">0</span>)real++;  <br>        &#125;  <br>    &#125;<br>    sort(a,a+m*n,cmp);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    k--;<span class="hljs-comment">//跳入</span><br>    <span class="hljs-keyword">int</span> least = a[i].x*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cost = a[i].x+<span class="hljs-number">1</span>;<br>   <span class="hljs-comment">// cout&lt;&lt;real&lt;&lt;endl;</span><br>    <span class="hljs-comment">//cout&lt;&lt;"应该是：3，1"&lt;&lt;a[0].x&lt;&lt;"  "&lt;&lt;a[0].y&lt;&lt;endl;</span><br>    <span class="hljs-keyword">while</span>(k&gt;=least&amp;&amp;(i&lt;=real))&#123;<span class="hljs-comment">//省去了讨论最后一步跳出</span><br>        k-=cost;<span class="hljs-comment">//到达a[i]点所需要的步数，并加上挖出所需要的一步</span><br>       <span class="hljs-comment">// cout&lt;&lt;"least:"&lt;&lt;least&lt;&lt;"  cost:"&lt;&lt;cost;</span><br>       <span class="hljs-comment">// cout&lt;&lt;"   k:"&lt;&lt;k&lt;&lt;endl;</span><br>        ans+=a[i].num;<br>        least = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+a[i+<span class="hljs-number">1</span>].x+<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//假设能拿到下一个,且挖掘，并保证能够返回到第一行。</span><br>        cost = <span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].y-a[i].y)+<span class="hljs-built_in">abs</span>(a[i+<span class="hljs-number">1</span>].x-a[i].x)+<span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，这个故事告诉我们。。。审视好题目。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝</summary>
      
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="洛谷" scheme="https://jefine.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList链表</title>
    <link href="https://jefine.github.io/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/"/>
    <id>https://jefine.github.io/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-17T09:50:51.000Z</published>
    <updated>2020-03-21T11:04:48.029Z</updated>
    
    <content type="html"><![CDATA[<p>今天说说链表：说到链表就不得不提及数组，两者相爱相杀，但又都是极为重要的基本数据结构类型。</p><p>相对于链表，我们一般情况下更熟悉数组。</p><p>（<del>听说加上英文，会显得高端不少</del>）：</p><h2 id="先讲一个小故事（虽然讲的很烂2333）"><a href="#先讲一个小故事（虽然讲的很烂2333）" class="headerlink" title="先讲一个小故事（虽然讲的很烂2333）"></a>先讲一个小故事（虽然讲的很烂2333）</h2><p>从前，一群小朋友外出游玩，到酒店申请房间啊，他们呢，申请的是数组方式的房间（哈哈）那么他们的房间号就是相连的。他们很容易的相互串门，带队者也可以轻松的找到他们每个人的所在（带队者只用记住第一个小朋友的位置和学号就好）。但问题是，他们这样申请房间的话，有的小朋友如果申请更换房间，会比较麻烦，更有甚者，不小心生病了，需要退房，那么负责人就要重新给每个人好分配房间，大多数小朋友都需要更换自己的房间，就会很麻烦。这时候，酒店管理者想到，如果我们让学号相邻的小朋友的记住他（她）下一个学号的小朋友的房间号（就像一号记住二号的房间号，二号记住三号的房间号），那么负责人还是只用记住第一个小朋友的房间号就可以按照顺序依次找到每个小朋友。（<del>当然要是其中一个小朋友忘记后面小朋友的位置的话。。。我们就失去了一堆小朋友</del>）。酒店管理者发现这样的话，不仅可以使得他们的房间利用率得到大大的提升，并且可以方便住宿人员的调动。</p><p>好的，相信读完这个尴尬的小故事，我们大概对链表有了一个感性的认识，他是为了解决一些数组的不足而出现的。下面就是严谨的分析链表的优缺点。</p><p>作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。</p><p>初学链表，一般从单向链表开始：（本文也暂时只有单向链表）</p><h2 id="Advantages-优势"><a href="#Advantages-优势" class="headerlink" title="Advantages 优势"></a><strong>Advantages 优势</strong></h2><p><strong>1)</strong> Dynamic size（动态大小）</p><p><strong>2)</strong> Ease of insertion/deletion（方便插入和删除）</p><h2 id="Drawbacks-缺点"><a href="#Drawbacks-缺点" class="headerlink" title="Drawbacks 缺点"></a><strong>Drawbacks 缺点</strong></h2><p><strong>1)</strong> Random access is not allowed. We have to access elements sequentially starting from the first node. So we cannot do binary search with linked lists efficiently with its default implementation. </p><p>不允许随机访问。 我们必须从第一个节点开始顺序访问元素。 因此，我们无法使用其默认实现对链接列表进行有效的二分查找。</p><p><strong>2)</strong> Extra memory space for a pointer is required with each element of the list.</p><p>需要额外的空间去存放链表中下一个元素的位置。</p><p><strong>3)</strong> Not cache friendly. Since array elements are<br>contiguous locations, there is locality of reference which is not there<br>in case of linked lists.</p><p>不缓存友好。 由于数组元素是连续的位置，因此存在引用位置，而在链接列表的情况下则不存在。</p><p>（就是说不能写成a[6])</p><h2 id="Representation-表达（内容）"><a href="#Representation-表达（内容）" class="headerlink" title="Representation  表达（内容）"></a><strong>Representation  表达（内容）</strong></h2><p>首先，我们将一个链表中的每个元素称为一个节点（Node),特殊的第一个被叫做头节点，最后一个被叫做尾节点。（图中，abcd是四个节点，但注意a不是头节点哈哈，Head是头节点，他指向的a节点）一般来说，头节点Head不存放内容，尾节点没有下一个元素的位置。（以简单的单链表为例）</p><p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/Linkedlist.png" alt="linkedList/Linkedlist.png"></p><p>A linked list is represented by a pointer to the first node of the<br>linked list. The first node is called the head. If the linked list is<br>empty, then the value of the head is NULL.</p><p>链接列表由指向链接列表的第一个节点的指针表示。 第一个节点称为头。 如果链表为空，则head的值为NULL。（<del>好绕口</del>）<br>Each node in a list consists of at least two parts:</p><p>每一个节点至少包括两部分：<br>1) data 数据<br>2) Pointer (Or Reference) to the next node 指向下一个结点的指针（指向/引用）<br>In C, we can represent a node using structures. Below is an example of a linked list node with integer data.</p><p>在c语言中，我们使用结构体来表示，如下面的代码:</p><pre><code>struct Node {int data;struct Node* next;};</code></pre><p>In Java or C#, LinkedList can be represented as a class and a Node as a<br>separate class. The LinkedList class contains a reference of Node class<br>type.</p><p>而在java，c#中LinkedList可以表示为一个类，而Node可以表示为单独的类。 LinkedList类包含Node类类型的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> &#123;</span> <br>Node head; <span class="hljs-comment">// head of the list </span><br><br><span class="hljs-comment">/* Linked list Node*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-keyword">int</span> data; <br>Node next; <br><br><span class="hljs-comment">// Constructor to create a new node </span><br><span class="hljs-comment">// Next is by default initialized </span><br><span class="hljs-comment">// as null </span><br>Node(<span class="hljs-keyword">int</span> d) &#123; data = d; &#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写一下链表？"><a href="#写一下链表？" class="headerlink" title="写一下链表？"></a>写一下链表？</h2><h3 id="我们从c开始尝试：-现在只写到了增）"><a href="#我们从c开始尝试：-现在只写到了增）" class="headerlink" title="我们从c开始尝试：(现在只写到了增）"></a>我们从c开始尝试：(现在只写到了增）</h3><p>好的，在此之前，我们似乎好像可能看起来学会了如何使用，但是看懂了和会写出来中间还是有一定的差距的。</p><p>链表还有一下基础的知识需要去掌握：</p><p><a href="https://www.runoob.com/cprogramming/c-function-malloc.html" target="_blank" rel="noopener">malloc</a> ：用于申请一定的内存.</p><p>那么这句(struct Node*)malloc(sizeof(struct Node))是什么鬼呢？（<del>这也太长了吧</del>）</p><p>不急，我们仔细看看，他是申请了一个内存，多大呢？（struct Node）类型的所需要的储存空间；（就像房间的类型一样，偏要双人床的那种）</p><p>那么前面的那个（struct Node*）是？哦，他是说这一块申请来的内存要强制转化成struct Node类型的，就是说专门给节点使用的。<del>（自己辛辛苦苦申请来的，才不给别人用呢）。</del></p><p>对了，这句话是会返回一个地址的，就是指向自己申请内存的位置。</p><p><strong>注意：节点呀！只有Head和普通节点。我们说的头指针，尾指针一类的，都是仅仅声明，作用就像房卡一样，是可以换的，里面存放的是链表中节点的地址。</strong></p><p>好的，下面我们要耐住性子，认真的学习咯（后文的故事如果听不太懂，放心你不是一个人，多看看不是故事的内容会更好）；（下面是一个标准化的介绍）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program to introduce </span><br><span class="hljs-comment">// a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br><br><span class="hljs-comment">//这个结构体就是我们要用到的节点了，</span><br><span class="hljs-comment">//既然c语言里的基本类型没有，我们就自己造一个。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-keyword">int</span> data; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br><br><span class="hljs-comment">// Program to create a simple linkedlist with 3 nodes </span><br><span class="hljs-comment">//编程去建立一个有三个节点的链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br><span class="hljs-comment">//声明3个节点，注意了哈，这里是声明！！！</span><br><span class="hljs-comment">//并没用得到那三个节点，就像我们拿到了三个空门牌，但是房间还没造出来呢</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br><br><span class="hljs-comment">// allocate 3 nodes in the heap</span><br><span class="hljs-comment">//从堆中申请三个节点的内存（这会儿才得到房间了，并把房间号写在了门牌上） </span><br>head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br><br><span class="hljs-comment">/* Three blocks have been allocated dynamically. <br>We have pointers to these three blocks as head, <br>second and third <br>下面是灵魂的绘图（佩服佩服）来表示我们所申请的三个节点的储存状态，<br>他们是不相连的哦<br>head        second    third <br>|          |       | <br>|           |        |<br>+---+-----+ +----+----+ +----+----+ <br>| # | # |    | # | # |    | # | # | <br>+---+-----+ +----+----+ +----+----+ <br>#代表了随机值，一个是数据，一个是指针，<br>和我们的stuct node结构相同哦，<br>但是他们现在还是随机值，因为我们没有给他们赋值。<br><br># represents any random value. <br>Data is random because we haven’t assigned <br>anything yet */</span><br><br>head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>head-&gt;next = second; <br><span class="hljs-comment">// Link first node with the second node </span><br><span class="hljs-comment">// 我们给第一个节点赋值了，并且告诉了他下一个节点的位置</span><br><br><span class="hljs-comment">/* data has been assigned to the data part of the first <br>block (block pointed by the head). And next <br>pointer of first block points to second. <br>So they both are linked. <br>//那个代码由于复制可能会造成错位，木得办法，撮合着看把哈哈。<br>head second third <br>| | | <br>| | | <br>+---+---+ +----+----+ +-----+----+ <br>| 1 | o-----&gt;| # | # | | # | # | <br>+---+---+ +----+----+ +-----+----+ <br>*/</span><br><br><span class="hljs-comment">// assign data to second node </span><br>second-&gt;data = <span class="hljs-number">2</span>; <br><br><span class="hljs-comment">// Link second node with the third node </span><br>second-&gt;next = third; <br><br><span class="hljs-comment">//同上，给第二个赋值，并且告诉他下一个在哪里</span><br><span class="hljs-comment">/* data has been assigned to the data part of the second <br>block (block pointed by second). And next <br>pointer of the second block points to the third <br>block. So all three blocks are linked. <br><br>head second third <br>| | | <br>| | | <br>+---+---+ +---+---+ +----+----+ <br>| 1 | o-----&gt;| 2 | o-----&gt; | # | # | <br>+---+---+ +---+---+ +----+----+ */</span><br><br>third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>third-&gt;next = <span class="hljs-literal">NULL</span>; <br><br><span class="hljs-comment">//给第三个（也是最后一个）赋值，并告诉他，你后面没人了。</span><br><span class="hljs-comment">/* data has been assigned to data part of third <br>block (block pointed by third). And next pointer <br>of the third block is made NULL to indicate <br>that the linked list is terminated here. <br><br>We have the linked list ready. <br><br>head <br>| <br>| <br>+---+---+ +---+---+ +----+------+ <br>| 1 | o-----&gt;| 2 | o-----&gt; | 3 | NULL | <br>+---+---+ +---+---+ +----+------+</span><br></code></pre></td></tr></table></figure><p>​        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Note that only head is sufficient to represent <br>the whole <span class="hljs-built_in">list</span>. We can traverse the complete <br><span class="hljs-built_in">list</span> by following next pointers. */<br><br><span class="hljs-comment">//接下来一定要试试效果么！</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">n</span> = <span class="hljs-title">head</span>;</span><br><span class="hljs-comment">//新建立一个指针，让他去循环着跑</span><br><span class="hljs-comment">//并且哈，它指向了第一个有数据的节点</span><br><span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <span class="hljs-comment">//输出完后，他就有指向了下一个</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>这就完了？这就完了。</p><p>下面是一个简洁的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple C program for traversal of a linked list </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br>    <span class="hljs-keyword">int</span> data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span> <br>&#125;; <br>  <br><span class="hljs-comment">// This function prints contents of linked list starting from </span><br><span class="hljs-comment">// the given node </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(struct Node* n)</span> <br></span>&#123; <br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-literal">NULL</span>) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>, n-&gt;data); <br>        n = n-&gt;next; <br>    &#125; <br>&#125; <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <br></span>&#123; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">second</span> = <span class="hljs-title">NULL</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">third</span> = <span class="hljs-title">NULL</span>;</span> <br>  <br>    <span class="hljs-comment">// allocate 3 nodes in the heap </span><br>    head = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    second = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>    third = (struct Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node)); <br>  <br>    head-&gt;data = <span class="hljs-number">1</span>; <span class="hljs-comment">// assign data in first node </span><br>    head-&gt;next = second; <span class="hljs-comment">// Link first node with second </span><br>  <br>    second-&gt;data = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign data to second node </span><br>    second-&gt;next = third; <br>  <br>    third-&gt;data = <span class="hljs-number">3</span>; <span class="hljs-comment">// assign data to third node </span><br>    third-&gt;next = <span class="hljs-literal">NULL</span>; <br>  <br>    printList(head); <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>当然，当我自己上手之后，生活还是狠狠地把我按在地上摩擦。。。</p><p>不妨我们模块化的写一下一个链表吧（写了很久来理解链表的优秀）</p><p>我先分开讲解每个模块的作用和意义，之后放在一起来观看，效果<del>（可能）</del>更佳。</p><p>1 必不可少的这个结构体呀！</p><p>你看，这个stuct Node *多长呀，如果我们使用的是typedef的话我们就可以将l作为一个数据类型的名字，然后把l当作int这样的来使用就好了（我们还是可以使用struct Node的）。</p><p>其次，看第二行，这个调用就很有意思了，声明了一个l数据类型的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    l* next;<span class="hljs-comment">//等效 struct Node *next</span><br>&#125;l;<br></code></pre></td></tr></table></figure><p>2 我们要创建一个链表了。</p><p>我们在main函数里面声明了一个Head的指针，并且申请了一个内存空间，并把其地址放进了head。这个时候把他传过来。</p><p>或者说，我们要了一个房卡，并要了一个房间，这个房卡就是head，房卡对应的就是该房间。</p><p>第一步：</p><p>在creat函数里面：我们先是malloc 了一个l类型的空间，这个房间的地址赋值给了新声明的n指针上。【或者说我们向酒店索要了一间l类型的房间（房卡当然比房间要好拿到一些呀），同时把这个房间的门牌号输入到了门卡上。】</p><p>第二步：我们把指针n的内容（也就是新声明的节点的地址）赋值给head指针指向的next的位置【哈哈，有点懵吧，就是说，我们现在手里一共有两张房卡对吧，一张是head（head房卡可是能打开head房间的哦），另一张是n（n可是上面有房间号码的），然后我们打开head的房间，在里面的next区域放上n房卡的内容（就是刚刚申请的房间号/地址）（用这个例子<del>可能</del>好理解哈，指针总是很奇妙的）</p><p>第三步：将n赋值,并指向空【然后我们利用n房卡打开刚刚申请的房间哈，然后在内容区域放上内容，在下一个的区域放上空，说明后面没有房间了】</p><p>这就好了。想象一下我们拿着head房卡就可以了，先是到head的next区域找到下一个房间的位置，然后进去，就能看见第一个房间的内容区域还能看到下一个房间在哪里了，当然在此处我们没有下一个房间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<span class="hljs-comment">//这里做一下判断，如果内存不足，那么报错</span><br>head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><p>3那我们一定要再来一个房间呀</p><p>第一步：传入一个头节点，和一个值【拿上head门卡和要往新房间里放的东西】</p><p>第二步：声明一个新的节点p，并使其和head指向相同。【再要一张门卡，复制一下head门卡的内容】这样做可以保证head不被破环。</p><p>第三步：开始找最后一个房间了，如果指向的房间中的next区域还有值，就说明后面还有房间，我们就把这个门卡p指向本来房间里的下一个房间位置，就是我们将p门卡本来打开时的是这个房间，我们使他打开的是下一个房间，（当然，他无法再打开这个房间了）然后继续搜索。直到发现只是最后一个房间。</p><p>第四步：我们新索要一个房间，原来最后一个空房间的next区域要存放上这个房间的位置了。然后我们把我们的东西也就是一个值放在新的房间，这个新房间就成了最后一个房间了，我们就需要把他的next变为NUll空，记住哦，这些步骤一步也不能缺少，否则就会酿成大错。。。（<del>无限卡壳</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>p-&gt;next =t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>4赶紧巡查一遍房间吧：</p><p>我们只用拿着head门卡就好，每次巡查的时候记得再要一个门卡自己的门卡保存着第一个房间的位置，可不能乱改。然后搜查完成一间房间之后，房卡n就成了下一个房间的房卡，继续搜查。哈哈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;l;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(struct Node *head)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">n</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;val&lt;&lt;<span class="hljs-string">" "</span>;<br>        n = n-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">creat</span><span class="hljs-params">(l *head)</span></span>&#123;<br>    l *n = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error,malloc failed!"</span>;<br>head-&gt;next = n;<br>    n-&gt;val = <span class="hljs-number">6</span>;<br>    n-&gt;next = <span class="hljs-literal">NULL</span>;   <br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    l *Head;<br>    Head = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    <br>    creat(Head);<br>    add(Head,<span class="hljs-number">15</span>);<br>    disp(Head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只是写出一个链表就少了很多趣味，增改删查才是硬道理！</strong></p><p>当然了，在开始阶段，我们还是只以单链表为例：</p><h2 id="链表的增："><a href="#链表的增：" class="headerlink" title="链表的增："></a>链表的增：</h2><p><img src="/2020/03/17/LinkedList%E9%93%BE%E8%A1%A8/_2020031917124912SS.png" alt="linkedList/_2020031917124912SS.png"></p><p><strong>一、 在链表的末尾增加：</strong>（再重复的系统的讲一下哈）</p><p>这个方法我们在上面已经认识到了，具体的思路就是我们通过头节点找到最后一个节点，然后在她后面添加一个节点，链接上去就可以了。（我们手持一个head房卡，沿着房间不断地走下去，找到最后的房间，在新开一间房间，然后我们在原来的最后一个房间的next的空间里放上新开房间的位置就好了）</p><p>这里假设我们已经有了一个链表了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;   <br>    l* p = Head;<span class="hljs-comment">//设置临时的指针，用来指向不同的节点，实现在不影响head的情况下遍历等操作</span><br>    <span class="hljs-keyword">while</span>(p-&gt;next)p=p-&gt;next;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    p-&gt;next = t;<br>    t-&gt;val=val;<br>    t-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、在链表的头部增加：</strong></p><p>这个的做法似乎比上一个还要简单呢，毕竟我们不用去一一寻找到最后一个了。</p><p>既然我们需要添加一个值，那么新建一个节点（房间）是必不可少的了。然后将值放入，让其指向本来的第一个节点，在让head指向它就好。（不怕麻烦的话，也可以重新添加一个指针变量，作为中间值，来进行操作）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(l*Head,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    t-&gt;next = Head-&gt;next;<br>    Head -&gt;next = t;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三、在链表的中间插入：</strong></p><p>这个可以说是前两者的综合版本了。我们要先找到这个节点，然后对他进行插入。</p><p>这里就以给定一个值，作为目标值，在其后面添加一个节点吧。查找的方法是先检查一下它后面是否还有节点，如果有就判断他的值是否符合，如果不符合就使指针指向下一个节点。这样出来的结果只会有两种，一种是没有找到，也有可能是这个值就在最后一个节点里面。</p><p>这里做了两个版本的给定值寻找插入方法，一种是在其之前，另一种是在其后。（两者之间只需要一点点的代码改动就可以了，在不同的地方已经用//注释）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertBefore</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* pre  = Head;<span class="hljs-comment">//*</span><br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<span class="hljs-comment">//*</span><br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>    pre-&gt;next = t;<span class="hljs-comment">//*</span><br>    t-&gt;next = p; <span class="hljs-comment">//*</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    l*t = (l*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(l));<br>    t-&gt;val = val;<br>     t-&gt;next = p-&gt;next;<span class="hljs-comment">//*</span><br>     p-&gt;next = t;<span class="hljs-comment">//*</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的删"><a href="#对链表的删" class="headerlink" title="对链表的删"></a>对链表的删</h2><p>？？？如果前面的掌握了的话，那么对链表的某个节点进行删除自然不是问题。就直接放代码了（思路和上面的<strong>insertBefore</strong>相同哦）（<del>代码其实也是参考上面的</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target)</span></span>&#123;<span class="hljs-comment">//这里传入头节点和目标值就可以了</span><br>    l* pre  = Head;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>             pre = p;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>pre-&gt;next = p-&gt;next;<span class="hljs-comment">//是的，将insertAfter代码的最后几行更改为这一行就好了。</span><br><span class="hljs-comment">//（相当于将这个节点跳过去了）</span><br>  <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">//既然删除了这个节点，那么就把他释放掉，节约内存。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的改："><a href="#对链表的改：" class="headerlink" title="对链表的改："></a>对链表的改：</h2><p>？？？如果前面的掌握了的话，那么对链表的某个值进行更改自然不是问题。就直接放代码了（思路和上面的<strong>insertAfter</strong>相同哦）（<del>代码其实也是参考上面的</del>）<del>（人类的本质是复读机）</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(l* Head,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    l* p = Head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val==target)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val!=target)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"查找失败"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    p-&gt;val = val;<span class="hljs-comment">//其实就是把insertAfter()最后的几行代码改为这个（2333）</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对链表的查："><a href="#对链表的查：" class="headerlink" title="对链表的查："></a>对链表的查：</h2><p>我们不是一直在查找么？？？（<del>避免复读，</del>就不再赘述）</p><p>看到这里，首先是一份敬佩，敬佩您能够静下心来一步一步的去尝试，去探索，去思考。确实文章篇幅很长，需要一定的耐心去思考，并且链表理解起来确实不是很困难，但是如果是刚开始，去上手操作，自然还是漏洞百出，bug重重。但是只要我们多尝试，多敲代码，缕清关系，明确指针自身的所在。那么，我们的各个方面都会有一定的成长。</p><p>谢谢阅读，本文中仍有许多的不足之处，还望交流指正。</p><p>对于后期，大家还可以去了解其他的链表形式，来加强对链表的使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天说说链表：说到链表就不得不提及数组，两者相爱相杀，但又都是极为重要的基本数据结构类型。&lt;/p&gt;
&lt;p&gt;相对于链表，我们一般情况下更熟悉数组。&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;听说加上英文，会显得高端不少&lt;/del&gt;）：&lt;/p&gt;
&lt;h2 id=&quot;先讲一个小故事（虽然讲的很烂23</summary>
      
    
    
    
    <category term="数据结构" scheme="https://jefine.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="https://jefine.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>java中对象的创建，初始化与引用</title>
    <link href="https://jefine.github.io/2020/03/11/java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://jefine.github.io/2020/03/11/java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%BC%95%E7%94%A8/</id>
    <published>2020-03-11T10:01:40.000Z</published>
    <updated>2020-03-11T10:05:30.244Z</updated>
    
    <content type="html"><![CDATA[<p>在java的学习过程中，对于对象/基本数据类型是如何创建于初始化和引用的，在这一过程中发生了什么，为什么？下面就是有一定的讲解：</p><h2 id="java对象与引用："><a href="#java对象与引用：" class="headerlink" title="java对象与引用："></a>java对象与引用：</h2><p>A a1 = new A();</p><p>它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。</p><p><strong>在声明时：=符号并不表示赋值，而是引用，是一个传递地址的过程。</strong></p><p>再如：</p><p>A a2;</p><p>它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null;</p><p>再如：</p><p>a2 = a1;</p><p>它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址），使得a2和a1指向了同一对象。</p><p>综上所述，可以简单的记为，在初始化时，“=”语句左边的是引用，右边new出来的是对象。</p><p>在后面的左右都是引用的“=”语句时，左右的引用同时指向了右边引用所指向的对象。</p><h2 id="JAVA中对象创建和初始化过程"><a href="#JAVA中对象创建和初始化过程" class="headerlink" title="JAVA中对象创建和初始化过程"></a>JAVA中对象创建和初始化过程</h2><p>分析一下JAVA中对象创建和初始化过程中涉及的相关概念问题，java中<strong>栈</strong>(stack)与<strong>堆</strong>(heap)，<strong>对象</strong>、<strong>引用</strong>、<strong>句柄</strong>的概念。</p><h3 id="1-Java中的数据类型"><a href="#1-Java中的数据类型" class="headerlink" title="1.Java中的数据类型"></a>1.Java中的数据类型</h3><p>Java中有3个数据类型：<strong>基本数据类型</strong>(在Java中，boolean、byte、short、int、long、char、float、double这八种是基本数据类型)、<strong>引用类型</strong>和<strong>null类型</strong>。其中，<strong>引用类型包括类类型(含数组)、接口类型。（和struck有点类似哈）</strong></p><p>下列语句声明了一些变量：</p><p>int k ;</p><p>A a; //a是A数据类型的对象变量名（仅作声明）。</p><p>B b1,b2,…,b10000;// 假定B是抽象类或接口。</p><p>String s;</p><p>注意：从数据类型与变量的角度看，基本数据类型变量k、类类型变量a和s、抽象类或接口类型变量b(1万个)，它们都是变量(标识符)。</p><h2 id="2-关于句柄-handle"><a href="#2-关于句柄-handle" class="headerlink" title="2.关于句柄(handle)"></a>2.关于句柄(handle)</h2><p>为了区别<strong>引用类型</strong>的变量标识符和<strong>基本数据类型</strong>变量标识符，我们特别的<strong>使用Handle来称呼引用类型的变量标识符</strong>。上面例子中b1至b10000、a、s都是Handle。Handle直观的看就是手柄、把手，我们采用计算机界常用的中文翻译“句柄”。</p><h3 id="2-1【Windows编程中的】句柄的含义"><a href="#2-1【Windows编程中的】句柄的含义" class="headerlink" title="2.1【Windows编程中的】句柄的含义"></a>2.1【Windows编程中的】句柄的含义</h3><p>句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。WINDOWS句柄有点象C语言中的文件句柄。</p><p>从上面的定义中的我们可以看到，句柄是一个标识符，是拿来标识对象或者项目的，它就象我们的姓名一样，每个人都会有一个，不同的人的姓名不一样，但是，也可能有一个名字和你一样的人。从数据类型上来看它只是一个16位的无符号整数。应用程序几乎总是通过调用一个WINDOWS函数来获得一个句柄，之后其他的WINDOWS函数就可以使用该句柄，以引用相应的对象。</p><p>如果想更透彻一点地认识句柄，我可以告诉大家，<strong>句柄是一种指向指针的指针。我们知道，所谓指针是一种内存地址</strong>。应用程序启动后，组成这个程序的各对象是驻留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢?</p><p>为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。</p><p><strong>句柄地址(稳定)→记载着对象在内存中的地址────→对象在内存中的地址(不稳定)→实际对象</strong></p><h3 id="2-2Java中句柄的意义"><a href="#2-2Java中句柄的意义" class="headerlink" title="2.2Java中句柄的意义"></a>2.2Java中句柄的意义</h3><p>对句柄以前的【Windows编程中的】含义有了深刻的认识，我们可以说Handle是一个我们学习Java时非常需要的术语。它的意义在于区别“对象本身”和对象变量(或者严格点：对象所属的数据类型的变量标识符)。</p><h3 id="2-3回到1中的变量声明："><a href="#2-3回到1中的变量声明：" class="headerlink" title="2.3回到1中的变量声明："></a>2.3回到1中的变量声明：</h3><p>现在，你应该对下面的注释一目了然。</p><p>int k, j ;//k里面存放的是一个整型数。</p><p>A a; //a里面存放地址。</p><p>B b1,b2,…,b10000;// b1，…，b10000里面存放地址。</p><p>String s; //s里面存放地址。</p><h2 id="3-关于引用-reference"><a href="#3-关于引用-reference" class="headerlink" title="3.关于引用(reference)"></a>3.关于引用(reference)</h2><p>什么是“引用”? “the identifier you manipulate is actually a ‘reference’ to an object”。(Thinking in Java 2e )</p><p>翻译是：你操纵的标识符实际上是一个对象的“引用”。或者精确些，翻译成：你操作的标识符实际上是指向一个对象的“引用”。显然，原文中reference是一个有方向感的东西。（说为“指向”也是蛮好）</p><p>回到Java中来，引用可以想象成对象的身份证号码、对象的ID或者对象的手机号码。当然，更多的说法是，引用是对象在内存中住的房间号码。直观的说，对象的引用是创建对象时的返回值!引用是new表达式的返回值。</p><p>new A(); 这里真正创建了一个对象，但我们没有用句柄去持有(hold、拿着、保存)该引用。从微观上看，new表达式完成了对象初始化的任务(三步曲，下文详细分析)，整体上看则返回一个引用。</p><p>再次回到1中的变量声明，再看看下面的注释。</p><p>A a; //声明句柄a，但未初始化，所以里面的值为null。</p><p>B b1,b2,…,b10000;// 声明句柄b1，…，b10000，但未初始化，所以里面的值为null。</p><p>String s; //声明句柄s，但未初始化，所以里面的值为null。</p><h2 id="4-句柄与引用的关系"><a href="#4-句柄与引用的关系" class="headerlink" title="4.句柄与引用的关系"></a>4.句柄与引用的关系</h2><p>A a;//声明句柄a，值为null</p><p>a=new A();//句柄的初始化(句柄 = 引用;即把引用赋值给句柄)</p><p>引用：new A()的值。引用可以简单的看作对象占据内存空间的地址;通过对象的引用，就可以方便的与其他对象区别开来，引用就是对象独特的身份标识。</p><p>完成句柄的初始化后，就可以用句柄遥控对象了。</p><p>当然，这只是从一方面解释对象的创建和初始化，理解了句柄和引用的关系后，下面分析对象初始化的整个过程。先做以下准备工作，说说栈与堆。</p><h2 id="5-java中栈-stack-与堆-heap"><a href="#5-java中栈-stack-与堆-heap" class="headerlink" title="5.java中栈(stack)与堆(heap)"></a>5.java中栈(stack)与堆(heap)</h2><p>在java中内存分为“栈”和“堆”这两种(Stack and Heap).基本数据类型存储在“栈”中，对象引用类型实际存储在“堆”中，在栈中只是保留了引用内存的地址值。</p><p>顺便说说“==”与“equals()方法”，以帮助理解两者(Stack and Heap)的概念。</p><p>在Java中利用”==”比较变量时候，系统使用变量在stack(栈)中所存的值来作为对比的依据，基本数据类型在stack中所存的值就是其?容值，而引用类型在stack中所存放的值是本身所指向Heap中对象的地址值。<strong>Java.lang包中的Object类有public boolean equals (Object obj)方法。它比较两个对象是否相等。仅当被比较的两个引用指向同一对象时(句柄相等)，对象的equals()方法返回true（是对象的比较哦)</strong>。(至于String类的equals()方法，它重写(override)equals()方法，不在本文讨论之列。)</p><h2 id="6-对象的创建和初始化过程"><a href="#6-对象的创建和初始化过程" class="headerlink" title="6.对象的创建和初始化过程"></a>6.对象的创建和初始化过程</h2><p>在java中对象就是类的实例。在一般情况下，当把一个类实例化时，此类的所有成员，包括变量和方法，都被复制到属于此数据类型的一个新的实例中去。分析以下两段代码。</p><h3 id="6-1-Vehicle-veh1-new-Vehicle"><a href="#6-1-Vehicle-veh1-new-Vehicle" class="headerlink" title="6.1 Vehicle veh1 = new Vehicle();"></a>6.1 Vehicle veh1 = new Vehicle();</h3><p>上面的语句做了如下的事情：</p><p>①右边的“new Vehicle”，是以Vehicle类为模板，在堆空间里创建一个Vehicle类对象(也简称为Vehicle对象)。</p><p>②末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果没创建，Java会补上一个默认的构造函数。(一般根据类型为null，0）</p><p>③左边的“Vehicle veh1”创建了一个Vehicle类引用变量。</p><p>④“=”操作符使对象引用指向刚创建的那个Vehicle对象。(回想一下句柄与引用)</p><p>将上面的语句分为两个步骤：</p><p>Vehicle veh1;</p><p>veh1 = new Vehicle();</p><p>这样写，就比较清楚了，有两个实体：</p><p>一是对象引用变量，一是对象本身。</p><p>在堆空间里创建的实体，与在栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是似乎很难准确的“抓”住它。我们仔细研究一下第二句，找找刚创建的对象叫什么名字?有人说，它叫“Vehicle”。不对，“Vehicle”是类(对象的创建模板)的名字。一个Vehicle类可以据此创建出无数个对象，这些对象不可能全叫“Vehicle”。对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。</p><h3 id="6-2-Vehicle-veh2"><a href="#6-2-Vehicle-veh2" class="headerlink" title="6.2 Vehicle veh2;"></a>6.2 Vehicle veh2;</h3><p>veh2 = veh1;</p><p>由于veh1和veh2只是对对象的引用，第二行所做的不过是把veh1的引用(地址)赋值给veh2，使得veh1和veh2同时指向唯一的一个Vehicle对象。</p><h3 id="6-3-veh2-new-Vehicle"><a href="#6-3-veh2-new-Vehicle" class="headerlink" title="6.3 veh2 = new Vehicle();"></a>6.3 veh2 = new Vehicle();</h3><p>则引用变量veh2改指向第二个对象。</p><p>从以上叙述再推演下去，我们可以获得以下结论：①一个对象引用可以指向0个（null）或1个对象;②一个对象可以有N个引用指向它。</p><p><a href="http://blog.sina.com.cn/s/blog_7ed8eb7d0101k057.html" target="_blank" rel="noopener">原文链接，稍作修改</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在java的学习过程中，对于对象/基本数据类型是如何创建于初始化和引用的，在这一过程中发生了什么，为什么？下面就是有一定的讲解：&lt;/p&gt;
&lt;h2 id=&quot;java对象与引用：&quot;&gt;&lt;a href=&quot;#java对象与引用：&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java日期处理</title>
    <link href="https://jefine.github.io/2020/03/01/java%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>https://jefine.github.io/2020/03/01/java%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</id>
    <published>2020-03-01T04:00:21.000Z</published>
    <updated>2020-08-10T04:09:22.763Z</updated>
    
    <content type="html"><![CDATA[<p> Java处理日期、日历和时间的方式一直被人所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。</p><p>新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。</p><p>(因为更安全，不可变了，所以就需要每一个日期搞一个变量（实例？）</p><p><a href="https://mp.weixin.qq.com/s/AGkp_0l_hvMye8QVOBlxwQ" target="_blank" rel="noopener">18 个 Java8 日期处理的实践，太有用了！</a></p><p><a href="https://www.notion.so/6ebff548541544f5a9ba2d6328513ee1" target="_blank" rel="noopener">java.time包</a></p><h2 id="示例1-Java-8中获取今天的日期"><a href="#示例1-Java-8中获取今天的日期" class="headerlink" title="示例1:Java 8中获取今天的日期"></a>示例1:Java 8中获取今天的日期</h2><p>Java 8 中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123; <br>        LocalDate today = LocalDate.now();<br>        System.out.println(<span class="hljs-string">"today is:"</span>+today);<br>  <br>    &#125;<br>&#125;<br><span class="hljs-comment">//output:</span><br><span class="hljs-comment">//today is:2020-02-29</span><br></code></pre></td></tr></table></figure><p>而如果需要将年月日信息分开：那么我们可以利用上面的today继续操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123; <br>        LocalDate today = LocalDate.now();<br>        System.out.println(<span class="hljs-string">"today is:"</span>+today);<br>        <span class="hljs-keyword">int</span> year = today.getYear();<br>        <span class="hljs-keyword">int</span> month = today.getMonthValue();<br>        <span class="hljs-keyword">int</span> day = today.getDayOfMonth();<br>        System.out.println(<span class="hljs-string">""</span>+year+month+day);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：其中还有getMonth()，返回的是一个枚举month里的值（是“FEBRUARY”这种）</p><p>而getMonthValue（）则返回一个值（2）所以我们还能发现许多这样的用法，比如day_of_year()等</p><h2 id="示例2：自定义日期："><a href="#示例2：自定义日期：" class="headerlink" title="示例2：自定义日期："></a>示例2：自定义日期：</h2><p>我们通过静态工厂方法now()非常容易地创建了当天的日期，我们还可以调用另一个有用的工厂方法<strong>LocalDate.of()</strong>创建任意日期， 该方法需要<strong>传入年、月、日做参数，返回对应的LocalDate实例。</strong>这个方法的好处是没再犯老API的设计错误（而且我们也可以使用localDate的方法了），比如年度起始于1900，月份是从0开 始等等（这些问题就不提了哎，文末可能会吐槽一下，并演示一下有多么讨厌）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123; <br>        LocalDate fakeDate = LocalDate.of(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">28</span>);<br>        System.out.println(<span class="hljs-string">"yesterday is:"</span>+fakeDate);<br>        <br>   &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//yesterday is:2020-02-28</span><br></code></pre></td></tr></table></figure><h2 id="示例三：判断两个日期是否相同使用-equals"><a href="#示例三：判断两个日期是否相同使用-equals" class="headerlink" title="示例三：判断两个日期是否相同使用.equals()"></a>示例三：判断两个日期是否相同使用.equals()</h2><h2 id="示例四：检查像生日这种周期性事件：MonthDay："><a href="#示例四：检查像生日这种周期性事件：MonthDay：" class="headerlink" title="示例四：检查像生日这种周期性事件：MonthDay："></a>示例四：检查像生日这种周期性事件：MonthDay：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;   LocalDate date1 = LocalDate.now();<br>        LocalDate date = LocalDate.of(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">28</span>);<br>        MonthDay birthday = MonthDay.of(date.getMonthValue(),date.getDayOfMonth());<br>        MonthDay nowMonthDay = MonthDay.now();<br>        <span class="hljs-keyword">if</span>(nowMonthDay.equals(birthday))<br>        System.out.println(<span class="hljs-string">"yes"</span>);<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">"nonono"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//nonono</span><br></code></pre></td></tr></table></figure><p>注意在这里getMonthValue（）和getMonth（）都是可以使用的。</p><h1 id="说完日期，说说时间："><a href="#说完日期，说说时间：" class="headerlink" title="说完日期，说说时间："></a>说完日期，说说时间：</h1><h2 id="示例五：获取当前时间"><a href="#示例五：获取当前时间" class="headerlink" title="示例五：获取当前时间"></a>示例五：获取当前时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        LocalTime now = LocalTime.now();<br>        System.out.println(now);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-number">19</span>:<span class="hljs-number">27</span>:<span class="hljs-number">01.708</span><br></code></pre></td></tr></table></figure><p>这个时间的精度。。可以了</p><h2 id="示例六：计算一段时间前-后的时间-plus-val-ChronoUnit-WEEKS"><a href="#示例六：计算一段时间前-后的时间-plus-val-ChronoUnit-WEEKS" class="headerlink" title="示例六：计算一段时间前/后的时间.plus(val,ChronoUnit.WEEKS)"></a>示例六：计算一段时间前/后的时间.plus(val,ChronoUnit.WEEKS)</h2><p>/.minus(val,ChronoUnit.WEEKS))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.temporal.ChronoUnit;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        LocalDate now = LocalDate.now();<br>        LocalDate after = now.plus(<span class="hljs-number">1</span>,ChronoUnit.WEEKS);<br><br>        System.out.println(after);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是日期，那么就要用localDate了</p><h2 id="示例七-Java-8的Clock时钟类"><a href="#示例七-Java-8的Clock时钟类" class="headerlink" title="示例七:Java 8的Clock时钟类"></a>示例七:Java 8的Clock时钟类</h2><p>Java 8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis()和TimeZone.getDefault()的地方都可用Clock替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        Clock clock = Clock.systemUTC();<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + clock.instant());<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + clock.millis());<br>        <span class="hljs-comment">// Returns time based on system clock zone</span><br>        Clock defaultClock = Clock.systemDefaultZone();<br>        System.out.println(<span class="hljs-string">"Clock : "</span> + defaultClock.millis());<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//Clock : 2020-03-01T03:06:27.520Z</span><br><span class="hljs-comment">//Clock : 1583031987647</span><br><span class="hljs-comment">//Clock : 1583031987687</span><br></code></pre></td></tr></table></figure><h2 id="示例八-如何用Java判断日期是早于还是晚于另一个日期"><a href="#示例八-如何用Java判断日期是早于还是晚于另一个日期" class="headerlink" title="示例八:如何用Java判断日期是早于还是晚于另一个日期"></a>示例八:如何用Java判断日期是早于还是晚于另一个日期</h2><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java 8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。调用isBefore()方法时，如果给定日期小于当前日期则返回true。当然也可判断是否日期相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        LocalDate today = LocalDate.now();<br>        LocalDate fakeDate = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(fakeDate.isBefore(today))<br>        &#123;<br>            System.out.print(<span class="hljs-string">"yes"</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">"nono"</span>);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//yes</span><br></code></pre></td></tr></table></figure><h2 id="示例九-Java-8中处理时区"><a href="#示例九-Java-8中处理时区" class="headerlink" title="示例九:Java 8中处理时区"></a>示例九:Java 8中处理时区</h2><p>Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java 8以前都是 GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><p><strong>其他：同样也可以检查闰年，独立的年月计算两个日期之间天数（between）</strong></p><h2 id="示例十：Java-8中如何使用预定义的格式化工具去解析或格式化日期"><a href="#示例十：Java-8中如何使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="示例十：Java 8中如何使用预定义的格式化工具去解析或格式化日期"></a>示例十：Java 8中如何使用预定义的格式化工具去解析或格式化日期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        String dayAfterTommorrow = <span class="hljs-string">"20200302"</span>;<br>        LocalDate formatted = LocalDate.parse(dayAfterTommorrow,DateTimeFormatter.BASIC_ISO_DATE);<br>        System.out.println(dayAfterTommorrow+<span class="hljs-string">"  格式化后的日期为:  "</span>+formatted);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//20200302  格式化后的日期为:  2020-03-02</span><br></code></pre></td></tr></table></figure><h2 id="示例十一：字符串互转日期类型"><a href="#示例十一：字符串互转日期类型" class="headerlink" title="示例十一：字符串互转日期类型"></a>示例十一：字符串互转日期类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        LocalDateTime date = LocalDateTime.now();<br><br>        DateTimeFormatter format1 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy/MM/dd hh:mm:ss"</span>);<br>    <span class="hljs-comment">//日期转字符串</span><br>        String str = date.format(format1);<br><br>        System.out.println(<span class="hljs-string">"日期转换为字符串:"</span>+str);<br><br>        DateTimeFormatter format2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy/MM/dd HH:mm:ss"</span>);<br>    <span class="hljs-comment">//字符串转日期</span><br>        LocalDate date2 = LocalDate.parse(str,format2);<br>        System.out.println(<span class="hljs-string">"日期类型:"</span>+date2);<br><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//日期转换为字符串:2020/03/01 11:44:03</span><br><span class="hljs-comment">//日期类型:2020-03-01</span><br></code></pre></td></tr></table></figure><p>如果我们将str的内容更换一下，只要format的内容一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        String str = <span class="hljs-string">"20190112120101"</span>;<br><br>        DateTimeFormatter format2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyyMMddHHmmss"</span>);<br>    <span class="hljs-comment">//字符串转日期</span><br>        LocalDate date2 = LocalDate.parse(str,format2);<br>        System.out.println(<span class="hljs-string">"日期类型:"</span>+date2);<br><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//output：</span><br><span class="hljs-comment">//日期类型:2019-01-12</span><br></code></pre></td></tr></table></figure><p>在这其中我们还是有很多可以去挖掘的。。。</p><p>对了，最后吐槽一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dealWithTime</span><br></span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <br></span>&#123;<br>        <br>        <span class="hljs-keyword">long</span> t = System.currentTimeMillis();<br><br>        System.out.println(t);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这玩意返回的必须是long类型但是把现在也用不到。返回的时间是距离1970年一月一日零点零分的毫秒数。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; Java处理日期、日历和时间的方式一直被人所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。&lt;/p&gt;
&lt;p&gt;新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://jefine.github.io/categories/java/"/>
    
    
    <category term="time" scheme="https://jefine.github.io/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>P1023税收与补贴问题</title>
    <link href="https://jefine.github.io/2020/02/29/P1023%E7%A8%8E%E6%94%B6%E4%B8%8E%E8%A1%A5%E8%B4%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://jefine.github.io/2020/02/29/P1023%E7%A8%8E%E6%94%B6%E4%B8%8E%E8%A1%A5%E8%B4%B4%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-29T04:26:23.000Z</published>
    <updated>2020-02-29T04:44:02.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）</p><p>对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。</p><p>总利润=单位商品利润   × × 销量</p><p>单位商品利润=单位商品价格 - 单位商品成本 （- 税金  or  + 补贴）</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行−1-1−1，−1-1−1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。</p><p>如在政府预期价上不能得到最大总利润，则输出“NO SOLUTION”。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">31</span><br><span class="hljs-number">28</span> <span class="hljs-number">130</span><br><span class="hljs-number">30</span> <span class="hljs-number">120</span><br><span class="hljs-number">31</span> <span class="hljs-number">110</span><br><span class="hljs-number">-1</span>  <span class="hljs-number">-1</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>所有数字均小于100000</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h3 id="tips：说实话，这个题目看了很久。。。"><a href="#tips：说实话，这个题目看了很久。。。" class="headerlink" title="tips：说实话，这个题目看了很久。。。"></a>tips：说实话，这个题目看了很久。。。</h3><p>最后，发现所求的是什么了。是要求政府给定一个预期的价格，然后你去尝试不同的补贴或者税收，得到他们的利润，并<strong>看看在每种税收或补贴下总利润最高的价格是不是政府预期价</strong> 。（可以好好思考一下这句，那么我们就计算出不同补贴或税收下，利润最大的价格，再比较）</p><p>（最后，好像没有不符合条件的，所以不用管。。。）</p><p>那么：</p><ol><li><p>我们可以先将购买者的价格和所对应的销量全部存起来，但这又有两个问题：</p><p>1）在题目给出的价格和销量之间，销量是随价格线性变化的，我们可通过计算得出期间的对应价格与销量，并都储存起来。（具体实施方法见代码）即 价格-销量表。 </p><p>2）再输入的最后给定了之后的销量减少值，我们就可以从中得到其后，一直到销量小于0的对应关系，并储存起来。</p></li><li><p>最后再根据不同的补贴（税收）（用一个循环从1开始跑到10000）依次计算其最大利润，并比较在该最大利润的价格是否与政府的价格相同。</p></li></ol><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码来源：https://www.luogu.com.cn/user/174034</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>][<span class="hljs-number">3</span>];<span class="hljs-comment">//用于存放价格和销量的数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,k,expect,down,<span class="hljs-built_in">max</span>,temp,cha,xl,num,s,price,p;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;expect;<span class="hljs-comment">//读入预期价</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a[i][<span class="hljs-number">1</span>]&gt;&gt;a[i][<span class="hljs-number">2</span>]&amp;&amp;a[i][<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>&amp;&amp;a[i] [<span class="hljs-number">2</span>]!=<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果输入的两个数不是-1，-1</span><br>    &#123;<br>        i++;<span class="hljs-comment">//循环变量i++</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">2</span>&amp;&amp;a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-a[i<span class="hljs-number">-2</span>][<span class="hljs-number">1</span>]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果两个价格之间差大于一</span><br>        &#123;<br>            i--;<span class="hljs-comment">//回到上一个读入的销量</span><br>            cha=(a[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-a[i][<span class="hljs-number">2</span>])/(a[i][<span class="hljs-number">1</span>]-a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//求出每次销量减少多少：销量差/价格差</span><br>            temp=a[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//记录下价格</span><br>            <span class="hljs-keyword">for</span>(j=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;j&lt;=temp;j++)<span class="hljs-comment">//按价格递增顺序依次写入</span><br>            &#123;<br>                a[i][<span class="hljs-number">1</span>]=j;<span class="hljs-comment">//写入价格</span><br>                a[i][<span class="hljs-number">2</span>]=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]-cha;<span class="hljs-comment">//按销量差写入销量</span><br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;down;<span class="hljs-comment">//输入超过最大价格之后每次销量降低多少</span><br>    i--;<span class="hljs-comment">//因为上面的while循环最后有i++所以用i--抵消……</span><br>    xl=a[i][<span class="hljs-number">2</span>];<span class="hljs-comment">//记录目前的销量</span><br>    <span class="hljs-keyword">while</span>(xl&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(xl-down&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如销量小于零则退出</span><br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//否则</span><br>        &#123;<br>            xl-=down;<span class="hljs-comment">//销量每次减掉down</span><br>            i++;<span class="hljs-comment">//循环变量++</span><br>            a[i][<span class="hljs-number">1</span>]=a[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-comment">//每次价格+1</span><br>            a[i][<span class="hljs-number">2</span>]=xl;<span class="hljs-comment">//销量就是xl</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">10000</span>;j++)<span class="hljs-comment">//该遍历了，因为收税相当于补贴*-1所以记录一下符号即可</span><br>    &#123;<br>        <span class="hljs-built_in">max</span>=<span class="hljs-number">-99999</span>;<span class="hljs-comment">//用于存储最大的总利润</span><br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=i;k++)<span class="hljs-comment">//每次扫一遍每一种价格</span><br>        &#123;<br>            num=(a[k][<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+j)*a[k][<span class="hljs-number">2</span>];<span class="hljs-comment">//套公式算出总利润</span><br>            <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-built_in">max</span>)<span class="hljs-comment">//如果总利润比目前最大的大</span><br>            &#123;<br>                <span class="hljs-built_in">max</span>=num;<span class="hljs-comment">//更新max</span><br>                price=a[k][<span class="hljs-number">1</span>];<span class="hljs-comment">//记录下价格</span><br>                p=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录下符号</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(price==expect)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;j*p;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//如果价格就是政府预期价则打印出来，因为本身就是从小到大遍历所以不用求绝对值最小的</span><br>        <span class="hljs-built_in">max</span>=<span class="hljs-number">-99999</span>;<span class="hljs-comment">//后面是收税，原理同上</span><br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=i;k++)<br>        &#123;<br>            num=(a[k][<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-j)*a[k][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-built_in">max</span>)<br>            &#123;<br>               <span class="hljs-built_in">max</span>=num;<br>                price=a[k][<span class="hljs-number">1</span>];  <br>                p=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(price==expect)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;j*p;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间</summary>
      
    
    
    
    <category term="编程" scheme="https://jefine.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="洛谷" scheme="https://jefine.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>概述STL</title>
    <link href="https://jefine.github.io/2020/02/28/%E6%A6%82%E8%BF%B0STL/"/>
    <id>https://jefine.github.io/2020/02/28/%E6%A6%82%E8%BF%B0STL/</id>
    <published>2020-02-28T05:27:31.000Z</published>
    <updated>2020-08-10T04:08:28.250Z</updated>
    
    <content type="html"><![CDATA[<p>使用stl可以大大提高算法设计的效率和可靠性。</p>  <a id="more"></a><ol><li>概述：</li></ol><p>STL 即Standard Template Library标准模板类库。</p><p>是标准c++库的子集</p><p>通用，强大</p><ol><li>构成：</li></ol><p>container：容器（储存元素）</p><p>algorithm：算法（操作元素）</p><p>iterator：迭代器（类似指针）</p><p>容器container:是一种数据结构</p><h2 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h2><p>1）</p><p><a href="https://jefine.github.io/2020/02/27/stlvector/">vector向量容器</a></p><p>2）</p><p>string 类似于上面的函数，有个别的例外。</p><p>3）</p><p>Dequen双端队列容器</p><p>是链表和字符串的调和产物，是多个连续的队列块。</p><p>4）list链表容器</p><p>是一个双链表类模板，只能使用++ - -来使用迭代器</p><h2 id="2-关联容器："><a href="#2-关联容器：" class="headerlink" title="2. 关联容器："></a>2. 关联容器：</h2><p>关联容器中每个元素都有一个关键字（key），通过key来储存和读取原损失，这些关键词可能于元素在容器中的位置无关，所以关联容器中不提供顺序容器中的front(),push_front(),pop_back()等操作，可以实现快速搜索（运用了分类的数据结构）</p><p>1）set（集合容器）/multiset（多重集合容器）</p><p>区别：</p><p>set中元素的关键字是唯一的，而multiset的关键字可以不唯一。<strong>默认情况下会对元素按照升序排列。</strong></p><p>而如果需要集合中的元素可以重复那么可以使用multiset。</p><p>又由于set没有重复的元素，所以如果添加的元素相同，那么不添加；而multiset可以有重复的元素，所以在删除的时候，会将其全部删除然后返回一个被删去元素个数。</p><p>特殊的函数有：</p><p>count（k）返回k在set中的次数。</p><p>find（k)如存在返回该元素的迭代器，否则返回end（）；</p><p>upper/lower_bound（k）返回关键字&gt;k或&gt;=k的第一个元素的迭代器</p><p>2）map（映射容器）/multimap（多重映射容器）</p><p>映射是实现关键字和值的各系的储存结构，可以用key来访问value</p><p>实现关键字和值关系的对应，而map是一一对应；而multimap是</p><p>同时map/multimap容器中的key和value是pair类型（不是像set一样两者都是key类型）pair是一个结构体声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pair</span><br>&#123;</span> T first;<span class="hljs-comment">//对应key值</span><br>  T second;<span class="hljs-comment">//对应value值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照key升序排列，以红黑树的形式。map支持【】；而multimap不允许【】（在使用map[key]的时侯如果不存在该key值那么就以其为关键字插入一个元素。</p><p>三种方式插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mym;<br>    mym[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;<br>    mym.insert(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>));<br>    mym.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">'c'</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span>(it = mym.<span class="hljs-built_in">begin</span>();it!=mym.<span class="hljs-built_in">end</span>();++it)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="适配器容器："><a href="#适配器容器：" class="headerlink" title="适配器容器："></a>适配器容器：</h2><p>是基于其他的容器实现的容器，在底层容器实现适配器容器的功能，实际上可以将其作为一个一般的容器去使用。后进后出（只能从顶部出入）</p><p>1）stark 栈容器：</p><p>后进后出默认的底层容器是deque，（当然也可以指定其他的容器作为stark的底层容器）</p><p>只有简单的pop（）出栈；push（）入栈；empty（）；size（）</p><p>2）queue队列容器：先进先出。</p><p>插入的元素在队尾，pop（）出的元素在队首。</p><p>3)priority_queue(优先队列容器）</p><p>可随意顺序入队列但是一旦进入就会被排序（按照值的大小排序）</p><p>在这个里面使用pop（）来找到队伍最前面的（也是最大值的）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用stl可以大大提高算法设计的效率和可靠性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jefine.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="stl" scheme="https://jefine.github.io/tags/stl/"/>
    
  </entry>
  
</feed>
